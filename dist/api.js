"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Kill Bill
 * Kill Bill is an open-source billing and payments platform
 *
 * The version of the OpenAPI document: 0.24.10
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.UsagePriceUsageTypeEnum = exports.TagDefinitionApplicableObjectTypesEnum = exports.TagObjectTypeEnum = exports.SubscriptionSourceTypeEnum = exports.SubscriptionStateEnum = exports.SubscriptionPhaseTypeEnum = exports.SubscriptionBillingPeriodEnum = exports.SubscriptionProductCategoryEnum = exports.SimplePlanTrialTimeUnitEnum = exports.SimplePlanBillingPeriodEnum = exports.SimplePlanCurrencyEnum = exports.SimplePlanProductCategoryEnum = exports.PriceCurrencyEnum = exports.PlanDetailFinalPhaseBillingPeriodEnum = exports.PlanBillingPeriodEnum = exports.PlanRecurringBillingModeEnum = exports.PaymentTransactionStatusEnum = exports.PaymentTransactionProcessedCurrencyEnum = exports.PaymentTransactionCurrencyEnum = exports.PaymentTransactionTransactionTypeEnum = exports.PaymentAttemptCurrencyEnum = exports.PaymentAttemptTransactionTypeEnum = exports.PaymentCurrencyEnum = exports.OverdueStateConfigSubscriptionCancellationPolicyEnum = exports.OverdueConditionResponseForLastFailedPaymentEnum = exports.OverdueConditionControlTagExclusionEnum = exports.OverdueConditionControlTagInclusionEnum = exports.InvoicePaymentTransactionStatusEnum = exports.InvoicePaymentTransactionProcessedCurrencyEnum = exports.InvoicePaymentTransactionCurrencyEnum = exports.InvoicePaymentTransactionTransactionTypeEnum = exports.InvoicePaymentCurrencyEnum = exports.InvoiceItemCurrencyEnum = exports.InvoiceItemItemTypeEnum = exports.InvoiceDryRunBillingPolicyEnum = exports.InvoiceDryRunBillingPeriodEnum = exports.InvoiceDryRunProductCategoryEnum = exports.InvoiceDryRunPhaseTypeEnum = exports.InvoiceDryRunDryRunActionEnum = exports.InvoiceDryRunDryRunTypeEnum = exports.InvoiceStatusEnum = exports.InvoiceCurrencyEnum = exports.EventSubscriptionEventTypeEnum = exports.EventSubscriptionBillingPeriodEnum = exports.DurationUnitEnum = exports.CustomFieldObjectTypeEnum = exports.CatalogCurrenciesEnum = exports.BlockingStateTypeEnum = exports.AuditLogObjectTypeEnum = exports.AccountCurrencyEnum = void 0;
exports.OverdueApi = exports.OverdueApiFactory = exports.OverdueApiFp = exports.OverdueApiAxiosParamCreator = exports.NodesInfoApi = exports.NodesInfoApiFactory = exports.NodesInfoApiFp = exports.NodesInfoApiAxiosParamCreator = exports.InvoicePaymentApi = exports.InvoicePaymentApiFactory = exports.InvoicePaymentApiFp = exports.InvoicePaymentApiAxiosParamCreator = exports.InvoiceItemApi = exports.InvoiceItemApiFactory = exports.InvoiceItemApiFp = exports.InvoiceItemApiAxiosParamCreator = exports.InvoiceApi = exports.InvoiceApiFactory = exports.InvoiceApiFp = exports.InvoiceApiAxiosParamCreator = exports.ExportApi = exports.ExportApiFactory = exports.ExportApiFp = exports.ExportApiAxiosParamCreator = exports.CustomFieldApi = exports.CustomFieldApiFactory = exports.CustomFieldApiFp = exports.CustomFieldApiAxiosParamCreator = exports.CreditApi = exports.CreditApiFactory = exports.CreditApiFp = exports.CreditApiAxiosParamCreator = exports.CatalogApi = exports.CatalogApiFactory = exports.CatalogApiFp = exports.CatalogApiAxiosParamCreator = exports.BundleApi = exports.BundleApiFactory = exports.BundleApiFp = exports.BundleApiAxiosParamCreator = exports.AdminApi = exports.AdminApiFactory = exports.AdminApiFp = exports.AdminApiAxiosParamCreator = exports.AccountApi = exports.AccountApiFactory = exports.AccountApiFp = exports.AccountApiAxiosParamCreator = exports.UsagePriceTierBlockPolicyEnum = exports.UsagePriceBillingModeEnum = void 0;
exports.UsageApi = exports.UsageApiFactory = exports.UsageApiFp = exports.UsageApiAxiosParamCreator = exports.TenantApi = exports.TenantApiFactory = exports.TenantApiFp = exports.TenantApiAxiosParamCreator = exports.TagDefinitionApi = exports.TagDefinitionApiFactory = exports.TagDefinitionApiFp = exports.TagDefinitionApiAxiosParamCreator = exports.TagApi = exports.TagApiFactory = exports.TagApiFp = exports.TagApiAxiosParamCreator = exports.SubscriptionApi = exports.SubscriptionApiFactory = exports.SubscriptionApiFp = exports.SubscriptionApiAxiosParamCreator = exports.SecurityApi = exports.SecurityApiFactory = exports.SecurityApiFp = exports.SecurityApiAxiosParamCreator = exports.PluginInfoApi = exports.PluginInfoApiFactory = exports.PluginInfoApiFp = exports.PluginInfoApiAxiosParamCreator = exports.PaymentTransactionApi = exports.PaymentTransactionApiFactory = exports.PaymentTransactionApiFp = exports.PaymentTransactionApiAxiosParamCreator = exports.PaymentMethodApi = exports.PaymentMethodApiFactory = exports.PaymentMethodApiFp = exports.PaymentMethodApiAxiosParamCreator = exports.PaymentGatewayApi = exports.PaymentGatewayApiFactory = exports.PaymentGatewayApiFp = exports.PaymentGatewayApiAxiosParamCreator = exports.PaymentApi = exports.PaymentApiFactory = exports.PaymentApiFp = exports.PaymentApiAxiosParamCreator = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.AccountCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
};
exports.AuditLogObjectTypeEnum = {
    Account: 'ACCOUNT',
    AccountEmail: 'ACCOUNT_EMAIL',
    BlockingStates: 'BLOCKING_STATES',
    Bundle: 'BUNDLE',
    CustomField: 'CUSTOM_FIELD',
    Invoice: 'INVOICE',
    Payment: 'PAYMENT',
    Transaction: 'TRANSACTION',
    InvoiceItem: 'INVOICE_ITEM',
    InvoicePayment: 'INVOICE_PAYMENT',
    Subscription: 'SUBSCRIPTION',
    SubscriptionEvent: 'SUBSCRIPTION_EVENT',
    ServiceBroadcast: 'SERVICE_BROADCAST',
    PaymentAttempt: 'PAYMENT_ATTEMPT',
    PaymentMethod: 'PAYMENT_METHOD',
    Tag: 'TAG',
    TagDefinition: 'TAG_DEFINITION',
    Tenant: 'TENANT',
    TenantKvs: 'TENANT_KVS'
};
exports.BlockingStateTypeEnum = {
    Subscription: 'SUBSCRIPTION',
    SubscriptionBundle: 'SUBSCRIPTION_BUNDLE',
    Account: 'ACCOUNT'
};
exports.CatalogCurrenciesEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
};
exports.CustomFieldObjectTypeEnum = {
    Account: 'ACCOUNT',
    AccountEmail: 'ACCOUNT_EMAIL',
    BlockingStates: 'BLOCKING_STATES',
    Bundle: 'BUNDLE',
    CustomField: 'CUSTOM_FIELD',
    Invoice: 'INVOICE',
    Payment: 'PAYMENT',
    Transaction: 'TRANSACTION',
    InvoiceItem: 'INVOICE_ITEM',
    InvoicePayment: 'INVOICE_PAYMENT',
    Subscription: 'SUBSCRIPTION',
    SubscriptionEvent: 'SUBSCRIPTION_EVENT',
    ServiceBroadcast: 'SERVICE_BROADCAST',
    PaymentAttempt: 'PAYMENT_ATTEMPT',
    PaymentMethod: 'PAYMENT_METHOD',
    Tag: 'TAG',
    TagDefinition: 'TAG_DEFINITION',
    Tenant: 'TENANT',
    TenantKvs: 'TENANT_KVS'
};
exports.DurationUnitEnum = {
    Days: 'DAYS',
    Weeks: 'WEEKS',
    Months: 'MONTHS',
    Years: 'YEARS',
    Unlimited: 'UNLIMITED'
};
exports.EventSubscriptionBillingPeriodEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Biweekly: 'BIWEEKLY',
    ThirtyDays: 'THIRTY_DAYS',
    ThirtyOneDays: 'THIRTY_ONE_DAYS',
    SixtyDays: 'SIXTY_DAYS',
    NinetyDays: 'NINETY_DAYS',
    Monthly: 'MONTHLY',
    Bimestrial: 'BIMESTRIAL',
    Quarterly: 'QUARTERLY',
    Triannual: 'TRIANNUAL',
    Biannual: 'BIANNUAL',
    Annual: 'ANNUAL',
    Sesquiennial: 'SESQUIENNIAL',
    Biennial: 'BIENNIAL',
    Triennial: 'TRIENNIAL',
    NoBillingPeriod: 'NO_BILLING_PERIOD'
};
exports.EventSubscriptionEventTypeEnum = {
    StartEntitlement: 'START_ENTITLEMENT',
    StartBilling: 'START_BILLING',
    PauseEntitlement: 'PAUSE_ENTITLEMENT',
    PauseBilling: 'PAUSE_BILLING',
    ResumeEntitlement: 'RESUME_ENTITLEMENT',
    ResumeBilling: 'RESUME_BILLING',
    Phase: 'PHASE',
    Change: 'CHANGE',
    StopEntitlement: 'STOP_ENTITLEMENT',
    StopBilling: 'STOP_BILLING',
    ServiceStateChange: 'SERVICE_STATE_CHANGE'
};
exports.InvoiceCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
};
exports.InvoiceStatusEnum = {
    Draft: 'DRAFT',
    Committed: 'COMMITTED',
    Void: 'VOID'
};
exports.InvoiceDryRunDryRunTypeEnum = {
    TargetDate: 'TARGET_DATE',
    UpcomingInvoice: 'UPCOMING_INVOICE',
    SubscriptionAction: 'SUBSCRIPTION_ACTION'
};
exports.InvoiceDryRunDryRunActionEnum = {
    StartEntitlement: 'START_ENTITLEMENT',
    StartBilling: 'START_BILLING',
    PauseEntitlement: 'PAUSE_ENTITLEMENT',
    PauseBilling: 'PAUSE_BILLING',
    ResumeEntitlement: 'RESUME_ENTITLEMENT',
    ResumeBilling: 'RESUME_BILLING',
    Phase: 'PHASE',
    Change: 'CHANGE',
    StopEntitlement: 'STOP_ENTITLEMENT',
    StopBilling: 'STOP_BILLING',
    ServiceStateChange: 'SERVICE_STATE_CHANGE'
};
exports.InvoiceDryRunPhaseTypeEnum = {
    Trial: 'TRIAL',
    Discount: 'DISCOUNT',
    Fixedterm: 'FIXEDTERM',
    Evergreen: 'EVERGREEN'
};
exports.InvoiceDryRunProductCategoryEnum = {
    Base: 'BASE',
    AddOn: 'ADD_ON',
    Standalone: 'STANDALONE'
};
exports.InvoiceDryRunBillingPeriodEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Biweekly: 'BIWEEKLY',
    ThirtyDays: 'THIRTY_DAYS',
    ThirtyOneDays: 'THIRTY_ONE_DAYS',
    SixtyDays: 'SIXTY_DAYS',
    NinetyDays: 'NINETY_DAYS',
    Monthly: 'MONTHLY',
    Bimestrial: 'BIMESTRIAL',
    Quarterly: 'QUARTERLY',
    Triannual: 'TRIANNUAL',
    Biannual: 'BIANNUAL',
    Annual: 'ANNUAL',
    Sesquiennial: 'SESQUIENNIAL',
    Biennial: 'BIENNIAL',
    Triennial: 'TRIENNIAL',
    NoBillingPeriod: 'NO_BILLING_PERIOD'
};
exports.InvoiceDryRunBillingPolicyEnum = {
    StartOfTerm: 'START_OF_TERM',
    EndOfTerm: 'END_OF_TERM',
    Immediate: 'IMMEDIATE',
    Illegal: 'ILLEGAL'
};
exports.InvoiceItemItemTypeEnum = {
    ExternalCharge: 'EXTERNAL_CHARGE',
    Fixed: 'FIXED',
    Recurring: 'RECURRING',
    RepairAdj: 'REPAIR_ADJ',
    CbaAdj: 'CBA_ADJ',
    CreditAdj: 'CREDIT_ADJ',
    ItemAdj: 'ITEM_ADJ',
    Usage: 'USAGE',
    Tax: 'TAX',
    ParentSummary: 'PARENT_SUMMARY'
};
exports.InvoiceItemCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
};
exports.InvoicePaymentCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
};
exports.InvoicePaymentTransactionTransactionTypeEnum = {
    Authorize: 'AUTHORIZE',
    Capture: 'CAPTURE',
    Chargeback: 'CHARGEBACK',
    Credit: 'CREDIT',
    Purchase: 'PURCHASE',
    Refund: 'REFUND',
    Void: 'VOID'
};
exports.InvoicePaymentTransactionCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
};
exports.InvoicePaymentTransactionProcessedCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
};
exports.InvoicePaymentTransactionStatusEnum = {
    Success: 'SUCCESS',
    Unknown: 'UNKNOWN',
    Pending: 'PENDING',
    PaymentFailure: 'PAYMENT_FAILURE',
    PluginFailure: 'PLUGIN_FAILURE',
    PaymentSystemOff: 'PAYMENT_SYSTEM_OFF'
};
exports.OverdueConditionControlTagInclusionEnum = {
    AutoPayOff: 'AUTO_PAY_OFF',
    AutoInvoicingOff: 'AUTO_INVOICING_OFF',
    OverdueEnforcementOff: 'OVERDUE_ENFORCEMENT_OFF',
    WrittenOff: 'WRITTEN_OFF',
    ManualPay: 'MANUAL_PAY',
    Test: 'TEST',
    Partner: 'PARTNER',
    AutoInvoicingDraft: 'AUTO_INVOICING_DRAFT',
    AutoInvoicingReuseDraft: 'AUTO_INVOICING_REUSE_DRAFT'
};
exports.OverdueConditionControlTagExclusionEnum = {
    AutoPayOff: 'AUTO_PAY_OFF',
    AutoInvoicingOff: 'AUTO_INVOICING_OFF',
    OverdueEnforcementOff: 'OVERDUE_ENFORCEMENT_OFF',
    WrittenOff: 'WRITTEN_OFF',
    ManualPay: 'MANUAL_PAY',
    Test: 'TEST',
    Partner: 'PARTNER',
    AutoInvoicingDraft: 'AUTO_INVOICING_DRAFT',
    AutoInvoicingReuseDraft: 'AUTO_INVOICING_REUSE_DRAFT'
};
exports.OverdueConditionResponseForLastFailedPaymentEnum = {
    InvalidCard: 'INVALID_CARD',
    ExpiredCard: 'EXPIRED_CARD',
    LostOrStolenCard: 'LOST_OR_STOLEN_CARD',
    DoNotHonor: 'DO_NOT_HONOR',
    InsufficientFunds: 'INSUFFICIENT_FUNDS',
    Decline: 'DECLINE',
    ProcessingError: 'PROCESSING_ERROR',
    InvalidAmount: 'INVALID_AMOUNT',
    DuplicateTransaction: 'DUPLICATE_TRANSACTION',
    Other: 'OTHER'
};
exports.OverdueStateConfigSubscriptionCancellationPolicyEnum = {
    EndOfTerm: 'END_OF_TERM',
    Immediate: 'IMMEDIATE',
    None: 'NONE'
};
exports.PaymentCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
};
exports.PaymentAttemptTransactionTypeEnum = {
    Authorize: 'AUTHORIZE',
    Capture: 'CAPTURE',
    Chargeback: 'CHARGEBACK',
    Credit: 'CREDIT',
    Purchase: 'PURCHASE',
    Refund: 'REFUND',
    Void: 'VOID'
};
exports.PaymentAttemptCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
};
exports.PaymentTransactionTransactionTypeEnum = {
    Authorize: 'AUTHORIZE',
    Capture: 'CAPTURE',
    Chargeback: 'CHARGEBACK',
    Credit: 'CREDIT',
    Purchase: 'PURCHASE',
    Refund: 'REFUND',
    Void: 'VOID'
};
exports.PaymentTransactionCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
};
exports.PaymentTransactionProcessedCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
};
exports.PaymentTransactionStatusEnum = {
    Success: 'SUCCESS',
    Unknown: 'UNKNOWN',
    Pending: 'PENDING',
    PaymentFailure: 'PAYMENT_FAILURE',
    PluginFailure: 'PLUGIN_FAILURE',
    PaymentSystemOff: 'PAYMENT_SYSTEM_OFF'
};
exports.PlanRecurringBillingModeEnum = {
    Advance: 'IN_ADVANCE',
    Arrear: 'IN_ARREAR'
};
exports.PlanBillingPeriodEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Biweekly: 'BIWEEKLY',
    ThirtyDays: 'THIRTY_DAYS',
    ThirtyOneDays: 'THIRTY_ONE_DAYS',
    SixtyDays: 'SIXTY_DAYS',
    NinetyDays: 'NINETY_DAYS',
    Monthly: 'MONTHLY',
    Bimestrial: 'BIMESTRIAL',
    Quarterly: 'QUARTERLY',
    Triannual: 'TRIANNUAL',
    Biannual: 'BIANNUAL',
    Annual: 'ANNUAL',
    Sesquiennial: 'SESQUIENNIAL',
    Biennial: 'BIENNIAL',
    Triennial: 'TRIENNIAL',
    NoBillingPeriod: 'NO_BILLING_PERIOD'
};
exports.PlanDetailFinalPhaseBillingPeriodEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Biweekly: 'BIWEEKLY',
    ThirtyDays: 'THIRTY_DAYS',
    ThirtyOneDays: 'THIRTY_ONE_DAYS',
    SixtyDays: 'SIXTY_DAYS',
    NinetyDays: 'NINETY_DAYS',
    Monthly: 'MONTHLY',
    Bimestrial: 'BIMESTRIAL',
    Quarterly: 'QUARTERLY',
    Triannual: 'TRIANNUAL',
    Biannual: 'BIANNUAL',
    Annual: 'ANNUAL',
    Sesquiennial: 'SESQUIENNIAL',
    Biennial: 'BIENNIAL',
    Triennial: 'TRIENNIAL',
    NoBillingPeriod: 'NO_BILLING_PERIOD'
};
exports.PriceCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
};
exports.SimplePlanProductCategoryEnum = {
    Base: 'BASE',
    AddOn: 'ADD_ON',
    Standalone: 'STANDALONE'
};
exports.SimplePlanCurrencyEnum = {
    Aed: 'AED',
    Afn: 'AFN',
    All: 'ALL',
    Amd: 'AMD',
    Ang: 'ANG',
    Aoa: 'AOA',
    Ars: 'ARS',
    Aud: 'AUD',
    Awg: 'AWG',
    Azn: 'AZN',
    Bam: 'BAM',
    Bbd: 'BBD',
    Bdt: 'BDT',
    Bgn: 'BGN',
    Bhd: 'BHD',
    Bif: 'BIF',
    Bmd: 'BMD',
    Bnd: 'BND',
    Bob: 'BOB',
    Brl: 'BRL',
    Bsd: 'BSD',
    Btn: 'BTN',
    Bwp: 'BWP',
    Byr: 'BYR',
    Bzd: 'BZD',
    Cad: 'CAD',
    Cdf: 'CDF',
    Chf: 'CHF',
    Clp: 'CLP',
    Cny: 'CNY',
    Cop: 'COP',
    Crc: 'CRC',
    Cuc: 'CUC',
    Cup: 'CUP',
    Cve: 'CVE',
    Czk: 'CZK',
    Djf: 'DJF',
    Dkk: 'DKK',
    Dop: 'DOP',
    Dzd: 'DZD',
    Egp: 'EGP',
    Ern: 'ERN',
    Etb: 'ETB',
    Eur: 'EUR',
    Fjd: 'FJD',
    Fkp: 'FKP',
    Gbp: 'GBP',
    Gel: 'GEL',
    Ggp: 'GGP',
    Ghs: 'GHS',
    Gip: 'GIP',
    Gmd: 'GMD',
    Gnf: 'GNF',
    Gtq: 'GTQ',
    Gyd: 'GYD',
    Hkd: 'HKD',
    Hnl: 'HNL',
    Hrk: 'HRK',
    Htg: 'HTG',
    Huf: 'HUF',
    Idr: 'IDR',
    Ils: 'ILS',
    Imp: 'IMP',
    Inr: 'INR',
    Iqd: 'IQD',
    Irr: 'IRR',
    Isk: 'ISK',
    Jep: 'JEP',
    Jmd: 'JMD',
    Jod: 'JOD',
    Jpy: 'JPY',
    Kes: 'KES',
    Kgs: 'KGS',
    Khr: 'KHR',
    Kmf: 'KMF',
    Kpw: 'KPW',
    Krw: 'KRW',
    Kwd: 'KWD',
    Kyd: 'KYD',
    Kzt: 'KZT',
    Lak: 'LAK',
    Lbp: 'LBP',
    Lkr: 'LKR',
    Lrd: 'LRD',
    Lsl: 'LSL',
    Ltl: 'LTL',
    Lvl: 'LVL',
    Lyd: 'LYD',
    Mad: 'MAD',
    Mdl: 'MDL',
    Mga: 'MGA',
    Mkd: 'MKD',
    Mmk: 'MMK',
    Mnt: 'MNT',
    Mop: 'MOP',
    Mro: 'MRO',
    Mur: 'MUR',
    Mvr: 'MVR',
    Mwk: 'MWK',
    Mxn: 'MXN',
    Myr: 'MYR',
    Mzn: 'MZN',
    Nad: 'NAD',
    Ngn: 'NGN',
    Nio: 'NIO',
    Nok: 'NOK',
    Npr: 'NPR',
    Nzd: 'NZD',
    Omr: 'OMR',
    Pab: 'PAB',
    Pen: 'PEN',
    Pgk: 'PGK',
    Php: 'PHP',
    Pkr: 'PKR',
    Pln: 'PLN',
    Pyg: 'PYG',
    Qar: 'QAR',
    Ron: 'RON',
    Rsd: 'RSD',
    Rub: 'RUB',
    Rwf: 'RWF',
    Sar: 'SAR',
    Sbd: 'SBD',
    Scr: 'SCR',
    Sdg: 'SDG',
    Sek: 'SEK',
    Sgd: 'SGD',
    Shp: 'SHP',
    Sll: 'SLL',
    Sos: 'SOS',
    Spl: 'SPL',
    Srd: 'SRD',
    Std: 'STD',
    Svc: 'SVC',
    Syp: 'SYP',
    Szl: 'SZL',
    Thb: 'THB',
    Tjs: 'TJS',
    Tmt: 'TMT',
    Tnd: 'TND',
    Top: 'TOP',
    Try: 'TRY',
    Ttd: 'TTD',
    Tvd: 'TVD',
    Twd: 'TWD',
    Tzs: 'TZS',
    Uah: 'UAH',
    Ugx: 'UGX',
    Usd: 'USD',
    Uyu: 'UYU',
    Uzs: 'UZS',
    Vef: 'VEF',
    Vnd: 'VND',
    Vuv: 'VUV',
    Wst: 'WST',
    Xaf: 'XAF',
    Xcd: 'XCD',
    Xdr: 'XDR',
    Xof: 'XOF',
    Xpf: 'XPF',
    Yer: 'YER',
    Zar: 'ZAR',
    Zmw: 'ZMW',
    Zwd: 'ZWD',
    Btc: 'BTC'
};
exports.SimplePlanBillingPeriodEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Biweekly: 'BIWEEKLY',
    ThirtyDays: 'THIRTY_DAYS',
    ThirtyOneDays: 'THIRTY_ONE_DAYS',
    SixtyDays: 'SIXTY_DAYS',
    NinetyDays: 'NINETY_DAYS',
    Monthly: 'MONTHLY',
    Bimestrial: 'BIMESTRIAL',
    Quarterly: 'QUARTERLY',
    Triannual: 'TRIANNUAL',
    Biannual: 'BIANNUAL',
    Annual: 'ANNUAL',
    Sesquiennial: 'SESQUIENNIAL',
    Biennial: 'BIENNIAL',
    Triennial: 'TRIENNIAL',
    NoBillingPeriod: 'NO_BILLING_PERIOD'
};
exports.SimplePlanTrialTimeUnitEnum = {
    Days: 'DAYS',
    Weeks: 'WEEKS',
    Months: 'MONTHS',
    Years: 'YEARS',
    Unlimited: 'UNLIMITED'
};
exports.SubscriptionProductCategoryEnum = {
    Base: 'BASE',
    AddOn: 'ADD_ON',
    Standalone: 'STANDALONE'
};
exports.SubscriptionBillingPeriodEnum = {
    Daily: 'DAILY',
    Weekly: 'WEEKLY',
    Biweekly: 'BIWEEKLY',
    ThirtyDays: 'THIRTY_DAYS',
    ThirtyOneDays: 'THIRTY_ONE_DAYS',
    SixtyDays: 'SIXTY_DAYS',
    NinetyDays: 'NINETY_DAYS',
    Monthly: 'MONTHLY',
    Bimestrial: 'BIMESTRIAL',
    Quarterly: 'QUARTERLY',
    Triannual: 'TRIANNUAL',
    Biannual: 'BIANNUAL',
    Annual: 'ANNUAL',
    Sesquiennial: 'SESQUIENNIAL',
    Biennial: 'BIENNIAL',
    Triennial: 'TRIENNIAL',
    NoBillingPeriod: 'NO_BILLING_PERIOD'
};
exports.SubscriptionPhaseTypeEnum = {
    Trial: 'TRIAL',
    Discount: 'DISCOUNT',
    Fixedterm: 'FIXEDTERM',
    Evergreen: 'EVERGREEN'
};
exports.SubscriptionStateEnum = {
    Pending: 'PENDING',
    Active: 'ACTIVE',
    Blocked: 'BLOCKED',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED'
};
exports.SubscriptionSourceTypeEnum = {
    Native: 'NATIVE',
    Migrated: 'MIGRATED',
    Transferred: 'TRANSFERRED'
};
exports.TagObjectTypeEnum = {
    Account: 'ACCOUNT',
    AccountEmail: 'ACCOUNT_EMAIL',
    BlockingStates: 'BLOCKING_STATES',
    Bundle: 'BUNDLE',
    CustomField: 'CUSTOM_FIELD',
    Invoice: 'INVOICE',
    Payment: 'PAYMENT',
    Transaction: 'TRANSACTION',
    InvoiceItem: 'INVOICE_ITEM',
    InvoicePayment: 'INVOICE_PAYMENT',
    Subscription: 'SUBSCRIPTION',
    SubscriptionEvent: 'SUBSCRIPTION_EVENT',
    ServiceBroadcast: 'SERVICE_BROADCAST',
    PaymentAttempt: 'PAYMENT_ATTEMPT',
    PaymentMethod: 'PAYMENT_METHOD',
    Tag: 'TAG',
    TagDefinition: 'TAG_DEFINITION',
    Tenant: 'TENANT',
    TenantKvs: 'TENANT_KVS'
};
exports.TagDefinitionApplicableObjectTypesEnum = {
    Account: 'ACCOUNT',
    AccountEmail: 'ACCOUNT_EMAIL',
    BlockingStates: 'BLOCKING_STATES',
    Bundle: 'BUNDLE',
    CustomField: 'CUSTOM_FIELD',
    Invoice: 'INVOICE',
    Payment: 'PAYMENT',
    Transaction: 'TRANSACTION',
    InvoiceItem: 'INVOICE_ITEM',
    InvoicePayment: 'INVOICE_PAYMENT',
    Subscription: 'SUBSCRIPTION',
    SubscriptionEvent: 'SUBSCRIPTION_EVENT',
    ServiceBroadcast: 'SERVICE_BROADCAST',
    PaymentAttempt: 'PAYMENT_ATTEMPT',
    PaymentMethod: 'PAYMENT_METHOD',
    Tag: 'TAG',
    TagDefinition: 'TAG_DEFINITION',
    Tenant: 'TENANT',
    TenantKvs: 'TENANT_KVS'
};
exports.UsagePriceUsageTypeEnum = {
    Capacity: 'CAPACITY',
    Consumable: 'CONSUMABLE'
};
exports.UsagePriceBillingModeEnum = {
    Advance: 'IN_ADVANCE',
    Arrear: 'IN_ARREAR'
};
exports.UsagePriceTierBlockPolicyEnum = {
    AllTiers: 'ALL_TIERS',
    TopTier: 'TOP_TIER'
};
/**
 * AccountApi - axios parameter creator
 * @export
 */
const AccountApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Block an account
         * @param {BlockingState} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountBlockingState: (body_1, accountId_1, xKillbillCreatedBy_1, requestedDate_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [body_1, accountId_1, xKillbillCreatedBy_1, requestedDate_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (body, accountId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('addAccountBlockingState', 'body', body);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('addAccountBlockingState', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('addAccountBlockingState', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}/block`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString().substr(0, 10) :
                    requestedDate;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add account email
         * @param {AccountEmail} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEmail: (body_2, accountId_2, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2) => __awaiter(this, [body_2, accountId_2, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2], void 0, function* (body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('addEmail', 'body', body);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('addEmail', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('addEmail', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}/emails`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Close account
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [cancelAllSubscriptions]
         * @param {boolean} [writeOffUnpaidInvoices]
         * @param {boolean} [itemAdjustUnpaidInvoices]
         * @param {boolean} [removeFutureNotifications]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeAccount: (accountId_3, xKillbillCreatedBy_3, cancelAllSubscriptions_1, writeOffUnpaidInvoices_1, itemAdjustUnpaidInvoices_1, removeFutureNotifications_1, xKillbillReason_3, xKillbillComment_3, ...args_3) => __awaiter(this, [accountId_3, xKillbillCreatedBy_3, cancelAllSubscriptions_1, writeOffUnpaidInvoices_1, itemAdjustUnpaidInvoices_1, removeFutureNotifications_1, xKillbillReason_3, xKillbillComment_3, ...args_3], void 0, function* (accountId, xKillbillCreatedBy, cancelAllSubscriptions, writeOffUnpaidInvoices, itemAdjustUnpaidInvoices, removeFutureNotifications, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('closeAccount', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('closeAccount', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (cancelAllSubscriptions !== undefined) {
                localVarQueryParameter['cancelAllSubscriptions'] = cancelAllSubscriptions;
            }
            if (writeOffUnpaidInvoices !== undefined) {
                localVarQueryParameter['writeOffUnpaidInvoices'] = writeOffUnpaidInvoices;
            }
            if (itemAdjustUnpaidInvoices !== undefined) {
                localVarQueryParameter['itemAdjustUnpaidInvoices'] = itemAdjustUnpaidInvoices;
            }
            if (removeFutureNotifications !== undefined) {
                localVarQueryParameter['removeFutureNotifications'] = removeFutureNotifications;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create account
         * @param {Account} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount: (body_3, xKillbillCreatedBy_4, xKillbillReason_4, xKillbillComment_4, ...args_4) => __awaiter(this, [body_3, xKillbillCreatedBy_4, xKillbillReason_4, xKillbillComment_4, ...args_4], void 0, function* (body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createAccount', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createAccount', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add custom fields to account
         * @param {Array<CustomField>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountCustomFields: (body_4, accountId_4, xKillbillCreatedBy_5, xKillbillReason_5, xKillbillComment_5, ...args_5) => __awaiter(this, [body_4, accountId_4, xKillbillCreatedBy_5, xKillbillReason_5, xKillbillComment_5, ...args_5], void 0, function* (body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createAccountCustomFields', 'body', body);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createAccountCustomFields', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createAccountCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}/customFields`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add tags to account
         * @param {Array<string>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountTags: (body_5, accountId_5, xKillbillCreatedBy_6, xKillbillReason_6, xKillbillComment_6, ...args_6) => __awaiter(this, [body_5, accountId_5, xKillbillCreatedBy_6, xKillbillReason_6, xKillbillComment_6, ...args_6], void 0, function* (body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createAccountTags', 'body', body);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createAccountTags', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createAccountTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}/tags`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add a payment method
         * @param {PaymentMethod} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [isDefault]
         * @param {boolean} [payAllUnpaidInvoices]
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod: (body_6, accountId_6, xKillbillCreatedBy_7, isDefault_1, payAllUnpaidInvoices_1, controlPluginName_1, pluginProperty_2, xKillbillReason_7, xKillbillComment_7, ...args_7) => __awaiter(this, [body_6, accountId_6, xKillbillCreatedBy_7, isDefault_1, payAllUnpaidInvoices_1, controlPluginName_1, pluginProperty_2, xKillbillReason_7, xKillbillComment_7, ...args_7], void 0, function* (body, accountId, xKillbillCreatedBy, isDefault, payAllUnpaidInvoices, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentMethod', 'body', body);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentMethod', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentMethod', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}/paymentMethods`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (isDefault !== undefined) {
                localVarQueryParameter['isDefault'] = isDefault;
            }
            if (payAllUnpaidInvoices !== undefined) {
                localVarQueryParameter['payAllUnpaidInvoices'] = payAllUnpaidInvoices;
            }
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove custom fields from account
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountCustomFields: (accountId_7, xKillbillCreatedBy_8, customField_1, xKillbillReason_8, xKillbillComment_8, ...args_8) => __awaiter(this, [accountId_7, xKillbillCreatedBy_8, customField_1, xKillbillReason_8, xKillbillComment_8, ...args_8], void 0, function* (accountId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAccountCustomFields', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteAccountCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}/customFields`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove tags from account
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountTags: (accountId_8, xKillbillCreatedBy_9, tagDef_1, xKillbillReason_9, xKillbillComment_9, ...args_9) => __awaiter(this, [accountId_8, xKillbillCreatedBy_9, tagDef_1, xKillbillReason_9, xKillbillComment_9, ...args_9], void 0, function* (accountId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('deleteAccountTags', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteAccountTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}/tags`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve an account by id
         * @param {string} accountId
         * @param {boolean} [accountWithBalance]
         * @param {boolean} [accountWithBalanceAndCBA]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: (accountId_9, accountWithBalance_1, accountWithBalanceAndCBA_1, audit_1, ...args_10) => __awaiter(this, [accountId_9, accountWithBalance_1, accountWithBalanceAndCBA_1, audit_1, ...args_10], void 0, function* (accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getAccount', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (accountWithBalance !== undefined) {
                localVarQueryParameter['accountWithBalance'] = accountWithBalance;
            }
            if (accountWithBalanceAndCBA !== undefined) {
                localVarQueryParameter['accountWithBalanceAndCBA'] = accountWithBalanceAndCBA;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve audit logs by account id
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAuditLogs: (accountId_10, ...args_11) => __awaiter(this, [accountId_10, ...args_11], void 0, function* (accountId, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getAccountAuditLogs', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/auditLogs`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve account audit logs with history by account id
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAuditLogsWithHistory: (accountId_11, ...args_12) => __awaiter(this, [accountId_11, ...args_12], void 0, function* (accountId, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getAccountAuditLogsWithHistory', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/auditLogsWithHistory`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve bundles for account
         * @param {string} accountId
         * @param {string} [externalKey]
         * @param {string} [bundlesFilter]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBundles: (accountId_12, externalKey_1, bundlesFilter_1, audit_2, ...args_13) => __awaiter(this, [accountId_12, externalKey_1, bundlesFilter_1, audit_2, ...args_13], void 0, function* (accountId, externalKey, bundlesFilter, audit, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getAccountBundles', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/bundles`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }
            if (bundlesFilter !== undefined) {
                localVarQueryParameter['bundlesFilter'] = bundlesFilter;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve paginated bundles for account
         * @param {string} accountId
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBundlesPaginated: (accountId_13, offset_1, limit_1, audit_3, ...args_14) => __awaiter(this, [accountId_13, offset_1, limit_1, audit_3, ...args_14], void 0, function* (accountId, offset, limit, audit, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getAccountBundlesPaginated', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/bundles/pagination`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve an account by external key
         * @param {string} externalKey
         * @param {boolean} [accountWithBalance]
         * @param {boolean} [accountWithBalanceAndCBA]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByKey: (externalKey_2, accountWithBalance_2, accountWithBalanceAndCBA_2, audit_4, ...args_15) => __awaiter(this, [externalKey_2, accountWithBalance_2, accountWithBalanceAndCBA_2, audit_4, ...args_15], void 0, function* (externalKey, accountWithBalance, accountWithBalanceAndCBA, audit, options = {}) {
            // verify required parameter 'externalKey' is not null or undefined
            (0, common_1.assertParamExists)('getAccountByKey', 'externalKey', externalKey);
            const localVarPath = `/1.0/kb/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }
            if (accountWithBalance !== undefined) {
                localVarQueryParameter['accountWithBalance'] = accountWithBalance;
            }
            if (accountWithBalanceAndCBA !== undefined) {
                localVarQueryParameter['accountWithBalanceAndCBA'] = accountWithBalanceAndCBA;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve account custom fields
         * @param {string} accountId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCustomFields: (accountId_14, audit_5, ...args_16) => __awaiter(this, [accountId_14, audit_5, ...args_16], void 0, function* (accountId, audit, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getAccountCustomFields', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/customFields`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve account email audit logs with history by id
         * @param {string} accountId
         * @param {string} accountEmailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEmailAuditLogsWithHistory: (accountId_15, accountEmailId_1, ...args_17) => __awaiter(this, [accountId_15, accountEmailId_1, ...args_17], void 0, function* (accountId, accountEmailId, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getAccountEmailAuditLogsWithHistory', 'accountId', accountId);
            // verify required parameter 'accountEmailId' is not null or undefined
            (0, common_1.assertParamExists)('getAccountEmailAuditLogsWithHistory', 'accountEmailId', accountEmailId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/emails/{accountEmailId}/auditLogsWithHistory`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"accountEmailId"}}`, encodeURIComponent(String(accountEmailId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve account tags
         * @param {string} accountId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTags: (accountId_16, includedDeleted_1, audit_6, ...args_18) => __awaiter(this, [accountId_16, includedDeleted_1, audit_6, ...args_18], void 0, function* (accountId, includedDeleted, audit, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getAccountTags', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/tags`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve account timeline
         * @param {string} accountId
         * @param {boolean} [parallel]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTimeline: (accountId_17, parallel_1, audit_7, ...args_19) => __awaiter(this, [accountId_17, parallel_1, audit_7, ...args_19], void 0, function* (accountId, parallel, audit, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getAccountTimeline', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/timeline`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (parallel !== undefined) {
                localVarQueryParameter['parallel'] = parallel;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List accounts
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {boolean} [accountWithBalance]
         * @param {boolean} [accountWithBalanceAndCBA]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: (offset_2, limit_2, accountWithBalance_3, accountWithBalanceAndCBA_3, audit_8, ...args_20) => __awaiter(this, [offset_2, limit_2, accountWithBalance_3, accountWithBalanceAndCBA_3, audit_8, ...args_20], void 0, function* (offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options = {}) {
            const localVarPath = `/1.0/kb/accounts/pagination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (accountWithBalance !== undefined) {
                localVarQueryParameter['accountWithBalance'] = accountWithBalance;
            }
            if (accountWithBalanceAndCBA !== undefined) {
                localVarQueryParameter['accountWithBalanceAndCBA'] = accountWithBalanceAndCBA;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve account customFields
         * @param {string} accountId
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCustomFields: (accountId_18, objectType_1, audit_9, ...args_21) => __awaiter(this, [accountId_18, objectType_1, audit_9, ...args_21], void 0, function* (accountId, objectType, audit, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getAllCustomFields', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/allCustomFields`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (objectType !== undefined) {
                localVarQueryParameter['objectType'] = objectType;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve account tags
         * @param {string} accountId
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType]
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags: (accountId_19, objectType_2, includedDeleted_2, audit_10, ...args_22) => __awaiter(this, [accountId_19, objectType_2, includedDeleted_2, audit_10, ...args_22], void 0, function* (accountId, objectType, includedDeleted, audit, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getAllTags', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/allTags`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (objectType !== undefined) {
                localVarQueryParameter['objectType'] = objectType;
            }
            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve blocking state audit logs with history by id
         * @param {string} blockingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockingStateAuditLogsWithHistory: (blockingId_1, ...args_23) => __awaiter(this, [blockingId_1, ...args_23], void 0, function* (blockingId, options = {}) {
            // verify required parameter 'blockingId' is not null or undefined
            (0, common_1.assertParamExists)('getBlockingStateAuditLogsWithHistory', 'blockingId', blockingId);
            const localVarPath = `/1.0/kb/accounts/block/{blockingId}/auditLogsWithHistory`
                .replace(`{${"blockingId"}}`, encodeURIComponent(String(blockingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve blocking states for account
         * @param {string} accountId
         * @param {Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>} [blockingStateTypes]
         * @param {Array<string>} [blockingStateSvcs]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockingStates: (accountId_20, blockingStateTypes_1, blockingStateSvcs_1, audit_11, ...args_24) => __awaiter(this, [accountId_20, blockingStateTypes_1, blockingStateSvcs_1, audit_11, ...args_24], void 0, function* (accountId, blockingStateTypes, blockingStateSvcs, audit, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getBlockingStates', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/block`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (blockingStateTypes) {
                localVarQueryParameter['blockingStateTypes'] = blockingStateTypes;
            }
            if (blockingStateSvcs) {
                localVarQueryParameter['blockingStateSvcs'] = blockingStateSvcs;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List children accounts
         * @param {string} accountId
         * @param {boolean} [accountWithBalance]
         * @param {boolean} [accountWithBalanceAndCBA]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChildrenAccounts: (accountId_21, accountWithBalance_4, accountWithBalanceAndCBA_4, audit_12, ...args_25) => __awaiter(this, [accountId_21, accountWithBalance_4, accountWithBalanceAndCBA_4, audit_12, ...args_25], void 0, function* (accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getChildrenAccounts', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/children`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (accountWithBalance !== undefined) {
                localVarQueryParameter['accountWithBalance'] = accountWithBalance;
            }
            if (accountWithBalanceAndCBA !== undefined) {
                localVarQueryParameter['accountWithBalanceAndCBA'] = accountWithBalanceAndCBA;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve an account emails
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails: (accountId_22, ...args_26) => __awaiter(this, [accountId_22, ...args_26], void 0, function* (accountId, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getEmails', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/emails`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve account invoice payments
         * @param {string} accountId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePayments: (accountId_23, withPluginInfo_1, withAttempts_1, pluginProperty_3, audit_13, ...args_27) => __awaiter(this, [accountId_23, withPluginInfo_1, withAttempts_1, pluginProperty_3, audit_13, ...args_27], void 0, function* (accountId, withPluginInfo, withAttempts, pluginProperty, audit, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoicePayments', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/invoicePayments`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }
            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve account invoices
         * @param {string} accountId
         * @param {string} [startDate]
         * @param {string} [endDate]
         * @param {boolean} [withMigrationInvoices]
         * @param {boolean} [unpaidInvoicesOnly]
         * @param {boolean} [includeVoidedInvoices]
         * @param {boolean} [includeInvoiceComponents]
         * @param {string} [invoicesFilter]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesForAccount: (accountId_24, startDate_1, endDate_1, withMigrationInvoices_1, unpaidInvoicesOnly_1, includeVoidedInvoices_1, includeInvoiceComponents_1, invoicesFilter_1, audit_14, ...args_28) => __awaiter(this, [accountId_24, startDate_1, endDate_1, withMigrationInvoices_1, unpaidInvoicesOnly_1, includeVoidedInvoices_1, includeInvoiceComponents_1, invoicesFilter_1, audit_14, ...args_28], void 0, function* (accountId, startDate, endDate, withMigrationInvoices, unpaidInvoicesOnly, includeVoidedInvoices, includeInvoiceComponents, invoicesFilter, audit, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoicesForAccount', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/invoices`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate instanceof Date) ?
                    startDate.toISOString().substr(0, 10) :
                    startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate instanceof Date) ?
                    endDate.toISOString().substr(0, 10) :
                    endDate;
            }
            if (withMigrationInvoices !== undefined) {
                localVarQueryParameter['withMigrationInvoices'] = withMigrationInvoices;
            }
            if (unpaidInvoicesOnly !== undefined) {
                localVarQueryParameter['unpaidInvoicesOnly'] = unpaidInvoicesOnly;
            }
            if (includeVoidedInvoices !== undefined) {
                localVarQueryParameter['includeVoidedInvoices'] = includeVoidedInvoices;
            }
            if (includeInvoiceComponents !== undefined) {
                localVarQueryParameter['includeInvoiceComponents'] = includeInvoiceComponents;
            }
            if (invoicesFilter !== undefined) {
                localVarQueryParameter['invoicesFilter'] = invoicesFilter;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve paginated invoices for account
         * @param {string} accountId
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesForAccountPaginated: (accountId_25, offset_3, limit_3, audit_15, ...args_29) => __awaiter(this, [accountId_25, offset_3, limit_3, audit_15, ...args_29], void 0, function* (accountId, offset, limit, audit, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoicesForAccountPaginated', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/invoices/pagination`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve overdue state for account
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueAccount: (accountId_26, ...args_30) => __awaiter(this, [accountId_26, ...args_30], void 0, function* (accountId, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getOverdueAccount', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/overdue`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve account payment methods
         * @param {string} accountId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [includedDeleted]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodsForAccount: (accountId_27, withPluginInfo_2, includedDeleted_3, pluginProperty_4, audit_16, ...args_31) => __awaiter(this, [accountId_27, withPluginInfo_2, includedDeleted_3, pluginProperty_4, audit_16, ...args_31], void 0, function* (accountId, withPluginInfo, includedDeleted, pluginProperty, audit, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentMethodsForAccount', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/paymentMethods`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }
            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve account payments
         * @param {string} accountId
         * @param {boolean} [withAttempts]
         * @param {boolean} [withPluginInfo]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForAccount: (accountId_28, withAttempts_2, withPluginInfo_3, pluginProperty_5, audit_17, ...args_32) => __awaiter(this, [accountId_28, withAttempts_2, withPluginInfo_3, pluginProperty_5, audit_17, ...args_32], void 0, function* (accountId, withAttempts, withPluginInfo, pluginProperty, audit, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentsForAccount', 'accountId', accountId);
            const localVarPath = `/1.0/kb/accounts/{accountId}/payments`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }
            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Modify custom fields to account
         * @param {Array<CustomField>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyAccountCustomFields: (body_7, accountId_29, xKillbillCreatedBy_10, xKillbillReason_10, xKillbillComment_10, ...args_33) => __awaiter(this, [body_7, accountId_29, xKillbillCreatedBy_10, xKillbillReason_10, xKillbillComment_10, ...args_33], void 0, function* (body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('modifyAccountCustomFields', 'body', body);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('modifyAccountCustomFields', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('modifyAccountCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}/customFields`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Trigger a payment for all unpaid invoices
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [paymentMethodId]
         * @param {boolean} [externalPayment]
         * @param {number} [paymentAmount]
         * @param {string} [targetDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payAllInvoices: (accountId_30, xKillbillCreatedBy_11, paymentMethodId_1, externalPayment_1, paymentAmount_1, targetDate_1, pluginProperty_6, xKillbillReason_11, xKillbillComment_11, ...args_34) => __awaiter(this, [accountId_30, xKillbillCreatedBy_11, paymentMethodId_1, externalPayment_1, paymentAmount_1, targetDate_1, pluginProperty_6, xKillbillReason_11, xKillbillComment_11, ...args_34], void 0, function* (accountId, xKillbillCreatedBy, paymentMethodId, externalPayment, paymentAmount, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('payAllInvoices', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('payAllInvoices', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}/invoicePayments`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }
            if (externalPayment !== undefined) {
                localVarQueryParameter['externalPayment'] = externalPayment;
            }
            if (paymentAmount !== undefined) {
                localVarQueryParameter['paymentAmount'] = paymentAmount;
            }
            if (targetDate !== undefined) {
                localVarQueryParameter['targetDate'] = (targetDate instanceof Date) ?
                    targetDate.toISOString().substr(0, 10) :
                    targetDate;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Trigger a payment (authorization, purchase or credit)
         * @param {PaymentTransaction} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [paymentMethodId]
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPayment: (body_8, accountId_31, xKillbillCreatedBy_12, paymentMethodId_2, controlPluginName_2, pluginProperty_7, xKillbillReason_12, xKillbillComment_12, ...args_35) => __awaiter(this, [body_8, accountId_31, xKillbillCreatedBy_12, paymentMethodId_2, controlPluginName_2, pluginProperty_7, xKillbillReason_12, xKillbillComment_12, ...args_35], void 0, function* (body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('processPayment', 'body', body);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('processPayment', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('processPayment', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}/payments`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Trigger a payment using the account external key (authorization, purchase or credit)
         * @param {PaymentTransaction} body
         * @param {string} externalKey
         * @param {string} xKillbillCreatedBy
         * @param {string} [paymentMethodId]
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPaymentByExternalKey: (body_9, externalKey_3, xKillbillCreatedBy_13, paymentMethodId_3, controlPluginName_3, pluginProperty_8, xKillbillReason_13, xKillbillComment_13, ...args_36) => __awaiter(this, [body_9, externalKey_3, xKillbillCreatedBy_13, paymentMethodId_3, controlPluginName_3, pluginProperty_8, xKillbillReason_13, xKillbillComment_13, ...args_36], void 0, function* (body, externalKey, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('processPaymentByExternalKey', 'body', body);
            // verify required parameter 'externalKey' is not null or undefined
            (0, common_1.assertParamExists)('processPaymentByExternalKey', 'externalKey', externalKey);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('processPaymentByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }
            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Rebalance account CBA
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebalanceExistingCBAOnAccount: (accountId_32, xKillbillCreatedBy_14, xKillbillReason_14, xKillbillComment_14, ...args_37) => __awaiter(this, [accountId_32, xKillbillCreatedBy_14, xKillbillReason_14, xKillbillComment_14, ...args_37], void 0, function* (accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('rebalanceExistingCBAOnAccount', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('rebalanceExistingCBAOnAccount', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}/cbaRebalancing`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Refresh account payment methods
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [pluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPaymentMethods: (accountId_33, xKillbillCreatedBy_15, pluginName_1, pluginProperty_9, xKillbillReason_15, xKillbillComment_15, ...args_38) => __awaiter(this, [accountId_33, xKillbillCreatedBy_15, pluginName_1, pluginProperty_9, xKillbillReason_15, xKillbillComment_15, ...args_38], void 0, function* (accountId, xKillbillCreatedBy, pluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('refreshPaymentMethods', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('refreshPaymentMethods', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}/paymentMethods/refresh`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (pluginName !== undefined) {
                localVarQueryParameter['pluginName'] = pluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete email from account
         * @param {string} accountId
         * @param {string} email
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEmail: (accountId_34, email_1, xKillbillCreatedBy_16, xKillbillReason_16, xKillbillComment_16, ...args_39) => __awaiter(this, [accountId_34, email_1, xKillbillCreatedBy_16, xKillbillReason_16, xKillbillComment_16, ...args_39], void 0, function* (accountId, email, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('removeEmail', 'accountId', accountId);
            // verify required parameter 'email' is not null or undefined
            (0, common_1.assertParamExists)('removeEmail', 'email', email);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('removeEmail', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}/emails/{email}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Search accounts
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {boolean} [accountWithBalance]
         * @param {boolean} [accountWithBalanceAndCBA]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts: (searchKey_1, offset_4, limit_4, accountWithBalance_5, accountWithBalanceAndCBA_5, audit_18, ...args_40) => __awaiter(this, [searchKey_1, offset_4, limit_4, accountWithBalance_5, accountWithBalanceAndCBA_5, audit_18, ...args_40], void 0, function* (searchKey, offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options = {}) {
            // verify required parameter 'searchKey' is not null or undefined
            (0, common_1.assertParamExists)('searchAccounts', 'searchKey', searchKey);
            const localVarPath = `/1.0/kb/accounts/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (accountWithBalance !== undefined) {
                localVarQueryParameter['accountWithBalance'] = accountWithBalance;
            }
            if (accountWithBalanceAndCBA !== undefined) {
                localVarQueryParameter['accountWithBalanceAndCBA'] = accountWithBalanceAndCBA;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Set the default payment method
         * @param {string} accountId
         * @param {string} paymentMethodId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [payAllUnpaidInvoices]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod: (accountId_35, paymentMethodId_4, xKillbillCreatedBy_17, payAllUnpaidInvoices_2, pluginProperty_10, xKillbillReason_17, xKillbillComment_17, ...args_41) => __awaiter(this, [accountId_35, paymentMethodId_4, xKillbillCreatedBy_17, payAllUnpaidInvoices_2, pluginProperty_10, xKillbillReason_17, xKillbillComment_17, ...args_41], void 0, function* (accountId, paymentMethodId, xKillbillCreatedBy, payAllUnpaidInvoices, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('setDefaultPaymentMethod', 'accountId', accountId);
            // verify required parameter 'paymentMethodId' is not null or undefined
            (0, common_1.assertParamExists)('setDefaultPaymentMethod', 'paymentMethodId', paymentMethodId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('setDefaultPaymentMethod', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}/paymentMethods/{paymentMethodId}/setDefault`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (payAllUnpaidInvoices !== undefined) {
                localVarQueryParameter['payAllUnpaidInvoices'] = payAllUnpaidInvoices;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Move a given child credit to the parent level
         * @param {string} childAccountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferChildCreditToParent: (childAccountId_1, xKillbillCreatedBy_18, xKillbillReason_18, xKillbillComment_18, ...args_42) => __awaiter(this, [childAccountId_1, xKillbillCreatedBy_18, xKillbillReason_18, xKillbillComment_18, ...args_42], void 0, function* (childAccountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'childAccountId' is not null or undefined
            (0, common_1.assertParamExists)('transferChildCreditToParent', 'childAccountId', childAccountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('transferChildCreditToParent', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{childAccountId}/transferCredit`
                .replace(`{${"childAccountId"}}`, encodeURIComponent(String(childAccountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update account
         * @param {Account} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [treatNullAsReset]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount: (body_10, accountId_36, xKillbillCreatedBy_19, treatNullAsReset_1, xKillbillReason_19, xKillbillComment_19, ...args_43) => __awaiter(this, [body_10, accountId_36, xKillbillCreatedBy_19, treatNullAsReset_1, xKillbillReason_19, xKillbillComment_19, ...args_43], void 0, function* (body, accountId, xKillbillCreatedBy, treatNullAsReset, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateAccount', 'body', body);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('updateAccount', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('updateAccount', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (treatNullAsReset !== undefined) {
                localVarQueryParameter['treatNullAsReset'] = treatNullAsReset;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AccountApiAxiosParamCreator = AccountApiAxiosParamCreator;
/**
 * AccountApi - functional programming interface
 * @export
 */
const AccountApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AccountApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Block an account
         * @param {BlockingState} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountBlockingState(body, accountId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addAccountBlockingState(body, accountId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add account email
         * @param {AccountEmail} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEmail(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addEmail(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Close account
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [cancelAllSubscriptions]
         * @param {boolean} [writeOffUnpaidInvoices]
         * @param {boolean} [itemAdjustUnpaidInvoices]
         * @param {boolean} [removeFutureNotifications]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeAccount(accountId, xKillbillCreatedBy, cancelAllSubscriptions, writeOffUnpaidInvoices, itemAdjustUnpaidInvoices, removeFutureNotifications, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.closeAccount(accountId, xKillbillCreatedBy, cancelAllSubscriptions, writeOffUnpaidInvoices, itemAdjustUnpaidInvoices, removeFutureNotifications, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Create account
         * @param {Account} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createAccount(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add custom fields to account
         * @param {Array<CustomField>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add tags to account
         * @param {Array<string>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountTags(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createAccountTags(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add a payment method
         * @param {PaymentMethod} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [isDefault]
         * @param {boolean} [payAllUnpaidInvoices]
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod(body, accountId, xKillbillCreatedBy, isDefault, payAllUnpaidInvoices, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPaymentMethod(body, accountId, xKillbillCreatedBy, isDefault, payAllUnpaidInvoices, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove custom fields from account
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountCustomFields(accountId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAccountCustomFields(accountId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove tags from account
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountTags(accountId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteAccountTags(accountId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve an account by id
         * @param {string} accountId
         * @param {boolean} [accountWithBalance]
         * @param {boolean} [accountWithBalanceAndCBA]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccount(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve audit logs by account id
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAuditLogs(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountAuditLogs(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve account audit logs with history by account id
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAuditLogsWithHistory(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountAuditLogsWithHistory(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve bundles for account
         * @param {string} accountId
         * @param {string} [externalKey]
         * @param {string} [bundlesFilter]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBundles(accountId, externalKey, bundlesFilter, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountBundles(accountId, externalKey, bundlesFilter, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve paginated bundles for account
         * @param {string} accountId
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBundlesPaginated(accountId, offset, limit, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountBundlesPaginated(accountId, offset, limit, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve an account by external key
         * @param {string} externalKey
         * @param {boolean} [accountWithBalance]
         * @param {boolean} [accountWithBalanceAndCBA]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByKey(externalKey, accountWithBalance, accountWithBalanceAndCBA, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountByKey(externalKey, accountWithBalance, accountWithBalanceAndCBA, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve account custom fields
         * @param {string} accountId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCustomFields(accountId, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountCustomFields(accountId, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve account email audit logs with history by id
         * @param {string} accountId
         * @param {string} accountEmailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEmailAuditLogsWithHistory(accountId, accountEmailId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountEmailAuditLogsWithHistory(accountId, accountEmailId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve account tags
         * @param {string} accountId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTags(accountId, includedDeleted, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountTags(accountId, includedDeleted, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve account timeline
         * @param {string} accountId
         * @param {boolean} [parallel]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTimeline(accountId, parallel, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccountTimeline(accountId, parallel, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List accounts
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {boolean} [accountWithBalance]
         * @param {boolean} [accountWithBalanceAndCBA]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAccounts(offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve account customFields
         * @param {string} accountId
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCustomFields(accountId, objectType, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllCustomFields(accountId, objectType, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve account tags
         * @param {string} accountId
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType]
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags(accountId, objectType, includedDeleted, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllTags(accountId, objectType, includedDeleted, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve blocking state audit logs with history by id
         * @param {string} blockingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockingStateAuditLogsWithHistory(blockingId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBlockingStateAuditLogsWithHistory(blockingId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve blocking states for account
         * @param {string} accountId
         * @param {Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>} [blockingStateTypes]
         * @param {Array<string>} [blockingStateSvcs]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockingStates(accountId, blockingStateTypes, blockingStateSvcs, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBlockingStates(accountId, blockingStateTypes, blockingStateSvcs, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List children accounts
         * @param {string} accountId
         * @param {boolean} [accountWithBalance]
         * @param {boolean} [accountWithBalanceAndCBA]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChildrenAccounts(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getChildrenAccounts(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve an account emails
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getEmails(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve account invoice payments
         * @param {string} accountId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePayments(accountId, withPluginInfo, withAttempts, pluginProperty, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoicePayments(accountId, withPluginInfo, withAttempts, pluginProperty, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve account invoices
         * @param {string} accountId
         * @param {string} [startDate]
         * @param {string} [endDate]
         * @param {boolean} [withMigrationInvoices]
         * @param {boolean} [unpaidInvoicesOnly]
         * @param {boolean} [includeVoidedInvoices]
         * @param {boolean} [includeInvoiceComponents]
         * @param {string} [invoicesFilter]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesForAccount(accountId, startDate, endDate, withMigrationInvoices, unpaidInvoicesOnly, includeVoidedInvoices, includeInvoiceComponents, invoicesFilter, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoicesForAccount(accountId, startDate, endDate, withMigrationInvoices, unpaidInvoicesOnly, includeVoidedInvoices, includeInvoiceComponents, invoicesFilter, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve paginated invoices for account
         * @param {string} accountId
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesForAccountPaginated(accountId, offset, limit, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoicesForAccountPaginated(accountId, offset, limit, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve overdue state for account
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueAccount(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOverdueAccount(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve account payment methods
         * @param {string} accountId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [includedDeleted]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodsForAccount(accountId, withPluginInfo, includedDeleted, pluginProperty, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentMethodsForAccount(accountId, withPluginInfo, includedDeleted, pluginProperty, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve account payments
         * @param {string} accountId
         * @param {boolean} [withAttempts]
         * @param {boolean} [withPluginInfo]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForAccount(accountId, withAttempts, withPluginInfo, pluginProperty, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentsForAccount(accountId, withAttempts, withPluginInfo, pluginProperty, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Modify custom fields to account
         * @param {Array<CustomField>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.modifyAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Trigger a payment for all unpaid invoices
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [paymentMethodId]
         * @param {boolean} [externalPayment]
         * @param {number} [paymentAmount]
         * @param {string} [targetDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payAllInvoices(accountId, xKillbillCreatedBy, paymentMethodId, externalPayment, paymentAmount, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.payAllInvoices(accountId, xKillbillCreatedBy, paymentMethodId, externalPayment, paymentAmount, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Trigger a payment (authorization, purchase or credit)
         * @param {PaymentTransaction} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [paymentMethodId]
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPayment(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.processPayment(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Trigger a payment using the account external key (authorization, purchase or credit)
         * @param {PaymentTransaction} body
         * @param {string} externalKey
         * @param {string} xKillbillCreatedBy
         * @param {string} [paymentMethodId]
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPaymentByExternalKey(body, externalKey, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.processPaymentByExternalKey(body, externalKey, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Rebalance account CBA
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebalanceExistingCBAOnAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.rebalanceExistingCBAOnAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Refresh account payment methods
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [pluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPaymentMethods(accountId, xKillbillCreatedBy, pluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.refreshPaymentMethods(accountId, xKillbillCreatedBy, pluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Delete email from account
         * @param {string} accountId
         * @param {string} email
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEmail(accountId, email, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.removeEmail(accountId, email, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Search accounts
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {boolean} [accountWithBalance]
         * @param {boolean} [accountWithBalanceAndCBA]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts(searchKey, offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchAccounts(searchKey, offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Set the default payment method
         * @param {string} accountId
         * @param {string} paymentMethodId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [payAllUnpaidInvoices]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod(accountId, paymentMethodId, xKillbillCreatedBy, payAllUnpaidInvoices, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.setDefaultPaymentMethod(accountId, paymentMethodId, xKillbillCreatedBy, payAllUnpaidInvoices, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Move a given child credit to the parent level
         * @param {string} childAccountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferChildCreditToParent(childAccountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.transferChildCreditToParent(childAccountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Update account
         * @param {Account} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [treatNullAsReset]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(body, accountId, xKillbillCreatedBy, treatNullAsReset, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateAccount(body, accountId, xKillbillCreatedBy, treatNullAsReset, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.AccountApiFp = AccountApiFp;
/**
 * AccountApi - factory interface
 * @export
 */
const AccountApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AccountApiFp)(configuration);
    return {
        /**
         *
         * @summary Block an account
         * @param {BlockingState} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountBlockingState(body, accountId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.addAccountBlockingState(body, accountId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add account email
         * @param {AccountEmail} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEmail(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.addEmail(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Close account
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [cancelAllSubscriptions]
         * @param {boolean} [writeOffUnpaidInvoices]
         * @param {boolean} [itemAdjustUnpaidInvoices]
         * @param {boolean} [removeFutureNotifications]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        closeAccount(accountId, xKillbillCreatedBy, cancelAllSubscriptions, writeOffUnpaidInvoices, itemAdjustUnpaidInvoices, removeFutureNotifications, xKillbillReason, xKillbillComment, options) {
            return localVarFp.closeAccount(accountId, xKillbillCreatedBy, cancelAllSubscriptions, writeOffUnpaidInvoices, itemAdjustUnpaidInvoices, removeFutureNotifications, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create account
         * @param {Account} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccount(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createAccount(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add custom fields to account
         * @param {Array<CustomField>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add tags to account
         * @param {Array<string>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAccountTags(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createAccountTags(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add a payment method
         * @param {PaymentMethod} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [isDefault]
         * @param {boolean} [payAllUnpaidInvoices]
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethod(body, accountId, xKillbillCreatedBy, isDefault, payAllUnpaidInvoices, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createPaymentMethod(body, accountId, xKillbillCreatedBy, isDefault, payAllUnpaidInvoices, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove custom fields from account
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountCustomFields(accountId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteAccountCustomFields(accountId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove tags from account
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountTags(accountId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteAccountTags(accountId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve an account by id
         * @param {string} accountId
         * @param {boolean} [accountWithBalance]
         * @param {boolean} [accountWithBalanceAndCBA]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options) {
            return localVarFp.getAccount(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve audit logs by account id
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAuditLogs(accountId, options) {
            return localVarFp.getAccountAuditLogs(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve account audit logs with history by account id
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAuditLogsWithHistory(accountId, options) {
            return localVarFp.getAccountAuditLogsWithHistory(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve bundles for account
         * @param {string} accountId
         * @param {string} [externalKey]
         * @param {string} [bundlesFilter]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBundles(accountId, externalKey, bundlesFilter, audit, options) {
            return localVarFp.getAccountBundles(accountId, externalKey, bundlesFilter, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve paginated bundles for account
         * @param {string} accountId
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountBundlesPaginated(accountId, offset, limit, audit, options) {
            return localVarFp.getAccountBundlesPaginated(accountId, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve an account by external key
         * @param {string} externalKey
         * @param {boolean} [accountWithBalance]
         * @param {boolean} [accountWithBalanceAndCBA]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountByKey(externalKey, accountWithBalance, accountWithBalanceAndCBA, audit, options) {
            return localVarFp.getAccountByKey(externalKey, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve account custom fields
         * @param {string} accountId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountCustomFields(accountId, audit, options) {
            return localVarFp.getAccountCustomFields(accountId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve account email audit logs with history by id
         * @param {string} accountId
         * @param {string} accountEmailId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountEmailAuditLogsWithHistory(accountId, accountEmailId, options) {
            return localVarFp.getAccountEmailAuditLogsWithHistory(accountId, accountEmailId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve account tags
         * @param {string} accountId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTags(accountId, includedDeleted, audit, options) {
            return localVarFp.getAccountTags(accountId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve account timeline
         * @param {string} accountId
         * @param {boolean} [parallel]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTimeline(accountId, parallel, audit, options) {
            return localVarFp.getAccountTimeline(accountId, parallel, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List accounts
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {boolean} [accountWithBalance]
         * @param {boolean} [accountWithBalanceAndCBA]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options) {
            return localVarFp.getAccounts(offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve account customFields
         * @param {string} accountId
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllCustomFields(accountId, objectType, audit, options) {
            return localVarFp.getAllCustomFields(accountId, objectType, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve account tags
         * @param {string} accountId
         * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType]
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags(accountId, objectType, includedDeleted, audit, options) {
            return localVarFp.getAllTags(accountId, objectType, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve blocking state audit logs with history by id
         * @param {string} blockingId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockingStateAuditLogsWithHistory(blockingId, options) {
            return localVarFp.getBlockingStateAuditLogsWithHistory(blockingId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve blocking states for account
         * @param {string} accountId
         * @param {Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>} [blockingStateTypes]
         * @param {Array<string>} [blockingStateSvcs]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockingStates(accountId, blockingStateTypes, blockingStateSvcs, audit, options) {
            return localVarFp.getBlockingStates(accountId, blockingStateTypes, blockingStateSvcs, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List children accounts
         * @param {string} accountId
         * @param {boolean} [accountWithBalance]
         * @param {boolean} [accountWithBalanceAndCBA]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChildrenAccounts(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options) {
            return localVarFp.getChildrenAccounts(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve an account emails
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(accountId, options) {
            return localVarFp.getEmails(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve account invoice payments
         * @param {string} accountId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePayments(accountId, withPluginInfo, withAttempts, pluginProperty, audit, options) {
            return localVarFp.getInvoicePayments(accountId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve account invoices
         * @param {string} accountId
         * @param {string} [startDate]
         * @param {string} [endDate]
         * @param {boolean} [withMigrationInvoices]
         * @param {boolean} [unpaidInvoicesOnly]
         * @param {boolean} [includeVoidedInvoices]
         * @param {boolean} [includeInvoiceComponents]
         * @param {string} [invoicesFilter]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesForAccount(accountId, startDate, endDate, withMigrationInvoices, unpaidInvoicesOnly, includeVoidedInvoices, includeInvoiceComponents, invoicesFilter, audit, options) {
            return localVarFp.getInvoicesForAccount(accountId, startDate, endDate, withMigrationInvoices, unpaidInvoicesOnly, includeVoidedInvoices, includeInvoiceComponents, invoicesFilter, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve paginated invoices for account
         * @param {string} accountId
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesForAccountPaginated(accountId, offset, limit, audit, options) {
            return localVarFp.getInvoicesForAccountPaginated(accountId, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve overdue state for account
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueAccount(accountId, options) {
            return localVarFp.getOverdueAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve account payment methods
         * @param {string} accountId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [includedDeleted]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodsForAccount(accountId, withPluginInfo, includedDeleted, pluginProperty, audit, options) {
            return localVarFp.getPaymentMethodsForAccount(accountId, withPluginInfo, includedDeleted, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve account payments
         * @param {string} accountId
         * @param {boolean} [withAttempts]
         * @param {boolean} [withPluginInfo]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForAccount(accountId, withAttempts, withPluginInfo, pluginProperty, audit, options) {
            return localVarFp.getPaymentsForAccount(accountId, withAttempts, withPluginInfo, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Modify custom fields to account
         * @param {Array<CustomField>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.modifyAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Trigger a payment for all unpaid invoices
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [paymentMethodId]
         * @param {boolean} [externalPayment]
         * @param {number} [paymentAmount]
         * @param {string} [targetDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payAllInvoices(accountId, xKillbillCreatedBy, paymentMethodId, externalPayment, paymentAmount, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.payAllInvoices(accountId, xKillbillCreatedBy, paymentMethodId, externalPayment, paymentAmount, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Trigger a payment (authorization, purchase or credit)
         * @param {PaymentTransaction} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [paymentMethodId]
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPayment(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.processPayment(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Trigger a payment using the account external key (authorization, purchase or credit)
         * @param {PaymentTransaction} body
         * @param {string} externalKey
         * @param {string} xKillbillCreatedBy
         * @param {string} [paymentMethodId]
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processPaymentByExternalKey(body, externalKey, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.processPaymentByExternalKey(body, externalKey, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Rebalance account CBA
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rebalanceExistingCBAOnAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.rebalanceExistingCBAOnAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Refresh account payment methods
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [pluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshPaymentMethods(accountId, xKillbillCreatedBy, pluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.refreshPaymentMethods(accountId, xKillbillCreatedBy, pluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete email from account
         * @param {string} accountId
         * @param {string} email
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeEmail(accountId, email, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.removeEmail(accountId, email, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Search accounts
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {boolean} [accountWithBalance]
         * @param {boolean} [accountWithBalanceAndCBA]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts(searchKey, offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options) {
            return localVarFp.searchAccounts(searchKey, offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Set the default payment method
         * @param {string} accountId
         * @param {string} paymentMethodId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [payAllUnpaidInvoices]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDefaultPaymentMethod(accountId, paymentMethodId, xKillbillCreatedBy, payAllUnpaidInvoices, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.setDefaultPaymentMethod(accountId, paymentMethodId, xKillbillCreatedBy, payAllUnpaidInvoices, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Move a given child credit to the parent level
         * @param {string} childAccountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferChildCreditToParent(childAccountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.transferChildCreditToParent(childAccountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update account
         * @param {Account} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [treatNullAsReset]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccount(body, accountId, xKillbillCreatedBy, treatNullAsReset, xKillbillReason, xKillbillComment, options) {
            return localVarFp.updateAccount(body, accountId, xKillbillCreatedBy, treatNullAsReset, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AccountApiFactory = AccountApiFactory;
/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
class AccountApi extends base_1.BaseAPI {
    /**
     *
     * @summary Block an account
     * @param {BlockingState} body
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [requestedDate]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    addAccountBlockingState(body, accountId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).addAccountBlockingState(body, accountId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add account email
     * @param {AccountEmail} body
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    addEmail(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).addEmail(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Close account
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {boolean} [cancelAllSubscriptions]
     * @param {boolean} [writeOffUnpaidInvoices]
     * @param {boolean} [itemAdjustUnpaidInvoices]
     * @param {boolean} [removeFutureNotifications]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    closeAccount(accountId, xKillbillCreatedBy, cancelAllSubscriptions, writeOffUnpaidInvoices, itemAdjustUnpaidInvoices, removeFutureNotifications, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).closeAccount(accountId, xKillbillCreatedBy, cancelAllSubscriptions, writeOffUnpaidInvoices, itemAdjustUnpaidInvoices, removeFutureNotifications, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create account
     * @param {Account} body
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    createAccount(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).createAccount(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add custom fields to account
     * @param {Array<CustomField>} body
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    createAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).createAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add tags to account
     * @param {Array<string>} body
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    createAccountTags(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).createAccountTags(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add a payment method
     * @param {PaymentMethod} body
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {boolean} [isDefault]
     * @param {boolean} [payAllUnpaidInvoices]
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    createPaymentMethod(body, accountId, xKillbillCreatedBy, isDefault, payAllUnpaidInvoices, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).createPaymentMethod(body, accountId, xKillbillCreatedBy, isDefault, payAllUnpaidInvoices, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove custom fields from account
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [customField]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    deleteAccountCustomFields(accountId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).deleteAccountCustomFields(accountId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove tags from account
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [tagDef]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    deleteAccountTags(accountId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).deleteAccountTags(accountId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve an account by id
     * @param {string} accountId
     * @param {boolean} [accountWithBalance]
     * @param {boolean} [accountWithBalanceAndCBA]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccount(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getAccount(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve audit logs by account id
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccountAuditLogs(accountId, options) {
        return (0, exports.AccountApiFp)(this.configuration).getAccountAuditLogs(accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve account audit logs with history by account id
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccountAuditLogsWithHistory(accountId, options) {
        return (0, exports.AccountApiFp)(this.configuration).getAccountAuditLogsWithHistory(accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve bundles for account
     * @param {string} accountId
     * @param {string} [externalKey]
     * @param {string} [bundlesFilter]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccountBundles(accountId, externalKey, bundlesFilter, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getAccountBundles(accountId, externalKey, bundlesFilter, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve paginated bundles for account
     * @param {string} accountId
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccountBundlesPaginated(accountId, offset, limit, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getAccountBundlesPaginated(accountId, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve an account by external key
     * @param {string} externalKey
     * @param {boolean} [accountWithBalance]
     * @param {boolean} [accountWithBalanceAndCBA]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccountByKey(externalKey, accountWithBalance, accountWithBalanceAndCBA, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getAccountByKey(externalKey, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve account custom fields
     * @param {string} accountId
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccountCustomFields(accountId, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getAccountCustomFields(accountId, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve account email audit logs with history by id
     * @param {string} accountId
     * @param {string} accountEmailId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccountEmailAuditLogsWithHistory(accountId, accountEmailId, options) {
        return (0, exports.AccountApiFp)(this.configuration).getAccountEmailAuditLogsWithHistory(accountId, accountEmailId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve account tags
     * @param {string} accountId
     * @param {boolean} [includedDeleted]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccountTags(accountId, includedDeleted, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getAccountTags(accountId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve account timeline
     * @param {string} accountId
     * @param {boolean} [parallel]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccountTimeline(accountId, parallel, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getAccountTimeline(accountId, parallel, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List accounts
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {boolean} [accountWithBalance]
     * @param {boolean} [accountWithBalanceAndCBA]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAccounts(offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getAccounts(offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve account customFields
     * @param {string} accountId
     * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAllCustomFields(accountId, objectType, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getAllCustomFields(accountId, objectType, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve account tags
     * @param {string} accountId
     * @param {'ACCOUNT' | 'ACCOUNT_EMAIL' | 'BLOCKING_STATES' | 'BUNDLE' | 'CUSTOM_FIELD' | 'INVOICE' | 'PAYMENT' | 'TRANSACTION' | 'INVOICE_ITEM' | 'INVOICE_PAYMENT' | 'SUBSCRIPTION' | 'SUBSCRIPTION_EVENT' | 'SERVICE_BROADCAST' | 'PAYMENT_ATTEMPT' | 'PAYMENT_METHOD' | 'TAG' | 'TAG_DEFINITION' | 'TENANT' | 'TENANT_KVS'} [objectType]
     * @param {boolean} [includedDeleted]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getAllTags(accountId, objectType, includedDeleted, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getAllTags(accountId, objectType, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve blocking state audit logs with history by id
     * @param {string} blockingId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getBlockingStateAuditLogsWithHistory(blockingId, options) {
        return (0, exports.AccountApiFp)(this.configuration).getBlockingStateAuditLogsWithHistory(blockingId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve blocking states for account
     * @param {string} accountId
     * @param {Array<'SUBSCRIPTION' | 'SUBSCRIPTION_BUNDLE' | 'ACCOUNT'>} [blockingStateTypes]
     * @param {Array<string>} [blockingStateSvcs]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getBlockingStates(accountId, blockingStateTypes, blockingStateSvcs, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getBlockingStates(accountId, blockingStateTypes, blockingStateSvcs, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List children accounts
     * @param {string} accountId
     * @param {boolean} [accountWithBalance]
     * @param {boolean} [accountWithBalanceAndCBA]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getChildrenAccounts(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getChildrenAccounts(accountId, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve an account emails
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getEmails(accountId, options) {
        return (0, exports.AccountApiFp)(this.configuration).getEmails(accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve account invoice payments
     * @param {string} accountId
     * @param {boolean} [withPluginInfo]
     * @param {boolean} [withAttempts]
     * @param {Array<string>} [pluginProperty]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getInvoicePayments(accountId, withPluginInfo, withAttempts, pluginProperty, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getInvoicePayments(accountId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve account invoices
     * @param {string} accountId
     * @param {string} [startDate]
     * @param {string} [endDate]
     * @param {boolean} [withMigrationInvoices]
     * @param {boolean} [unpaidInvoicesOnly]
     * @param {boolean} [includeVoidedInvoices]
     * @param {boolean} [includeInvoiceComponents]
     * @param {string} [invoicesFilter]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getInvoicesForAccount(accountId, startDate, endDate, withMigrationInvoices, unpaidInvoicesOnly, includeVoidedInvoices, includeInvoiceComponents, invoicesFilter, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getInvoicesForAccount(accountId, startDate, endDate, withMigrationInvoices, unpaidInvoicesOnly, includeVoidedInvoices, includeInvoiceComponents, invoicesFilter, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve paginated invoices for account
     * @param {string} accountId
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getInvoicesForAccountPaginated(accountId, offset, limit, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getInvoicesForAccountPaginated(accountId, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve overdue state for account
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getOverdueAccount(accountId, options) {
        return (0, exports.AccountApiFp)(this.configuration).getOverdueAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve account payment methods
     * @param {string} accountId
     * @param {boolean} [withPluginInfo]
     * @param {boolean} [includedDeleted]
     * @param {Array<string>} [pluginProperty]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getPaymentMethodsForAccount(accountId, withPluginInfo, includedDeleted, pluginProperty, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getPaymentMethodsForAccount(accountId, withPluginInfo, includedDeleted, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve account payments
     * @param {string} accountId
     * @param {boolean} [withAttempts]
     * @param {boolean} [withPluginInfo]
     * @param {Array<string>} [pluginProperty]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    getPaymentsForAccount(accountId, withAttempts, withPluginInfo, pluginProperty, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).getPaymentsForAccount(accountId, withAttempts, withPluginInfo, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Modify custom fields to account
     * @param {Array<CustomField>} body
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    modifyAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).modifyAccountCustomFields(body, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Trigger a payment for all unpaid invoices
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [paymentMethodId]
     * @param {boolean} [externalPayment]
     * @param {number} [paymentAmount]
     * @param {string} [targetDate]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    payAllInvoices(accountId, xKillbillCreatedBy, paymentMethodId, externalPayment, paymentAmount, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).payAllInvoices(accountId, xKillbillCreatedBy, paymentMethodId, externalPayment, paymentAmount, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Trigger a payment (authorization, purchase or credit)
     * @param {PaymentTransaction} body
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [paymentMethodId]
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    processPayment(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).processPayment(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Trigger a payment using the account external key (authorization, purchase or credit)
     * @param {PaymentTransaction} body
     * @param {string} externalKey
     * @param {string} xKillbillCreatedBy
     * @param {string} [paymentMethodId]
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    processPaymentByExternalKey(body, externalKey, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).processPaymentByExternalKey(body, externalKey, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Rebalance account CBA
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    rebalanceExistingCBAOnAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).rebalanceExistingCBAOnAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Refresh account payment methods
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [pluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    refreshPaymentMethods(accountId, xKillbillCreatedBy, pluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).refreshPaymentMethods(accountId, xKillbillCreatedBy, pluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete email from account
     * @param {string} accountId
     * @param {string} email
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    removeEmail(accountId, email, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).removeEmail(accountId, email, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Search accounts
     * @param {string} searchKey
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {boolean} [accountWithBalance]
     * @param {boolean} [accountWithBalanceAndCBA]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    searchAccounts(searchKey, offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options) {
        return (0, exports.AccountApiFp)(this.configuration).searchAccounts(searchKey, offset, limit, accountWithBalance, accountWithBalanceAndCBA, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Set the default payment method
     * @param {string} accountId
     * @param {string} paymentMethodId
     * @param {string} xKillbillCreatedBy
     * @param {boolean} [payAllUnpaidInvoices]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    setDefaultPaymentMethod(accountId, paymentMethodId, xKillbillCreatedBy, payAllUnpaidInvoices, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).setDefaultPaymentMethod(accountId, paymentMethodId, xKillbillCreatedBy, payAllUnpaidInvoices, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Move a given child credit to the parent level
     * @param {string} childAccountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    transferChildCreditToParent(childAccountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).transferChildCreditToParent(childAccountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update account
     * @param {Account} body
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {boolean} [treatNullAsReset]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    updateAccount(body, accountId, xKillbillCreatedBy, treatNullAsReset, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AccountApiFp)(this.configuration).updateAccount(body, accountId, xKillbillCreatedBy, treatNullAsReset, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AccountApi = AccountApi;
/**
 * AdminApi - axios parameter creator
 * @export
 */
const AdminApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Get queues entries
         * @param {string} [accountId]
         * @param {string} [queueName]
         * @param {string} [serviceName]
         * @param {boolean} [withHistory]
         * @param {string} [minDate]
         * @param {string} [maxDate]
         * @param {boolean} [withInProcessing]
         * @param {boolean} [withBusEvents]
         * @param {boolean} [withNotifications]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueEntries: (accountId_1, queueName_1, serviceName_1, withHistory_1, minDate_1, maxDate_1, withInProcessing_1, withBusEvents_1, withNotifications_1, ...args_1) => __awaiter(this, [accountId_1, queueName_1, serviceName_1, withHistory_1, minDate_1, maxDate_1, withInProcessing_1, withBusEvents_1, withNotifications_1, ...args_1], void 0, function* (accountId, queueName, serviceName, withHistory, minDate, maxDate, withInProcessing, withBusEvents, withNotifications, options = {}) {
            const localVarPath = `/1.0/kb/admin/queues`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            if (queueName !== undefined) {
                localVarQueryParameter['queueName'] = queueName;
            }
            if (serviceName !== undefined) {
                localVarQueryParameter['serviceName'] = serviceName;
            }
            if (withHistory !== undefined) {
                localVarQueryParameter['withHistory'] = withHistory;
            }
            if (minDate !== undefined) {
                localVarQueryParameter['minDate'] = minDate;
            }
            if (maxDate !== undefined) {
                localVarQueryParameter['maxDate'] = maxDate;
            }
            if (withInProcessing !== undefined) {
                localVarQueryParameter['withInProcessing'] = withInProcessing;
            }
            if (withBusEvents !== undefined) {
                localVarQueryParameter['withBusEvents'] = withBusEvents;
            }
            if (withNotifications !== undefined) {
                localVarQueryParameter['withNotifications'] = withNotifications;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Invalidates the given Cache if specified, otherwise invalidates all caches
         * @param {string} [cacheName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCache: (cacheName_1, ...args_2) => __awaiter(this, [cacheName_1, ...args_2], void 0, function* (cacheName, options = {}) {
            const localVarPath = `/1.0/kb/admin/cache`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (cacheName !== undefined) {
                localVarQueryParameter['cacheName'] = cacheName;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Invalidates Caches per account level
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCacheByAccount: (accountId_2, ...args_3) => __awaiter(this, [accountId_2, ...args_3], void 0, function* (accountId, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('invalidatesCacheByAccount', 'accountId', accountId);
            const localVarPath = `/1.0/kb/admin/cache/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Invalidates Caches per tenant level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCacheByTenant: (...args_4) => __awaiter(this, [...args_4], void 0, function* (options = {}) {
            const localVarPath = `/1.0/kb/admin/cache/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Put the host back into rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInRotation: (...args_5) => __awaiter(this, [...args_5], void 0, function* (options = {}) {
            const localVarPath = `/1.0/kb/admin/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Put the host out of rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOutOfRotation: (...args_6) => __awaiter(this, [...args_6], void 0, function* (options = {}) {
            const localVarPath = `/1.0/kb/admin/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Trigger an invoice generation for all parked accounts
         * @param {string} xKillbillCreatedBy
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerInvoiceGenerationForParkedAccounts: (xKillbillCreatedBy_1, offset_1, limit_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_7) => __awaiter(this, [xKillbillCreatedBy_1, offset_1, limit_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_7], void 0, function* (xKillbillCreatedBy, offset, limit, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('triggerInvoiceGenerationForParkedAccounts', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/admin/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update existing paymentTransaction and associated payment state
         * @param {AdminPayment} body
         * @param {string} paymentId
         * @param {string} paymentTransactionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentTransactionState: (body_1, paymentId_1, paymentTransactionId_1, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_8) => __awaiter(this, [body_1, paymentId_1, paymentTransactionId_1, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_8], void 0, function* (body, paymentId, paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updatePaymentTransactionState', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('updatePaymentTransactionState', 'paymentId', paymentId);
            // verify required parameter 'paymentTransactionId' is not null or undefined
            (0, common_1.assertParamExists)('updatePaymentTransactionState', 'paymentTransactionId', paymentTransactionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('updatePaymentTransactionState', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/admin/payments/{paymentId}/transactions/{paymentTransactionId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)))
                .replace(`{${"paymentTransactionId"}}`, encodeURIComponent(String(paymentTransactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AdminApiAxiosParamCreator = AdminApiAxiosParamCreator;
/**
 * AdminApi - functional programming interface
 * @export
 */
const AdminApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AdminApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Get queues entries
         * @param {string} [accountId]
         * @param {string} [queueName]
         * @param {string} [serviceName]
         * @param {boolean} [withHistory]
         * @param {string} [minDate]
         * @param {string} [maxDate]
         * @param {boolean} [withInProcessing]
         * @param {boolean} [withBusEvents]
         * @param {boolean} [withNotifications]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueEntries(accountId, queueName, serviceName, withHistory, minDate, maxDate, withInProcessing, withBusEvents, withNotifications, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getQueueEntries(accountId, queueName, serviceName, withHistory, minDate, maxDate, withInProcessing, withBusEvents, withNotifications, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Invalidates the given Cache if specified, otherwise invalidates all caches
         * @param {string} [cacheName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCache(cacheName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.invalidatesCache(cacheName, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Invalidates Caches per account level
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCacheByAccount(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.invalidatesCacheByAccount(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Invalidates Caches per tenant level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCacheByTenant(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.invalidatesCacheByTenant(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Put the host back into rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInRotation(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.putInRotation(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Put the host out of rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOutOfRotation(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.putOutOfRotation(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Trigger an invoice generation for all parked accounts
         * @param {string} xKillbillCreatedBy
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy, offset, limit, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy, offset, limit, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Update existing paymentTransaction and associated payment state
         * @param {AdminPayment} body
         * @param {string} paymentId
         * @param {string} paymentTransactionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentTransactionState(body, paymentId, paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updatePaymentTransactionState(body, paymentId, paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.AdminApiFp = AdminApiFp;
/**
 * AdminApi - factory interface
 * @export
 */
const AdminApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AdminApiFp)(configuration);
    return {
        /**
         *
         * @summary Get queues entries
         * @param {string} [accountId]
         * @param {string} [queueName]
         * @param {string} [serviceName]
         * @param {boolean} [withHistory]
         * @param {string} [minDate]
         * @param {string} [maxDate]
         * @param {boolean} [withInProcessing]
         * @param {boolean} [withBusEvents]
         * @param {boolean} [withNotifications]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getQueueEntries(accountId, queueName, serviceName, withHistory, minDate, maxDate, withInProcessing, withBusEvents, withNotifications, options) {
            return localVarFp.getQueueEntries(accountId, queueName, serviceName, withHistory, minDate, maxDate, withInProcessing, withBusEvents, withNotifications, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Invalidates the given Cache if specified, otherwise invalidates all caches
         * @param {string} [cacheName]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCache(cacheName, options) {
            return localVarFp.invalidatesCache(cacheName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Invalidates Caches per account level
         * @param {string} accountId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCacheByAccount(accountId, options) {
            return localVarFp.invalidatesCacheByAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Invalidates Caches per tenant level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidatesCacheByTenant(options) {
            return localVarFp.invalidatesCacheByTenant(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put the host back into rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putInRotation(options) {
            return localVarFp.putInRotation(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Put the host out of rotation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putOutOfRotation(options) {
            return localVarFp.putOutOfRotation(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Trigger an invoice generation for all parked accounts
         * @param {string} xKillbillCreatedBy
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy, offset, limit, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy, offset, limit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update existing paymentTransaction and associated payment state
         * @param {AdminPayment} body
         * @param {string} paymentId
         * @param {string} paymentTransactionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentTransactionState(body, paymentId, paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.updatePaymentTransactionState(body, paymentId, paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.AdminApiFactory = AdminApiFactory;
/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
class AdminApi extends base_1.BaseAPI {
    /**
     *
     * @summary Get queues entries
     * @param {string} [accountId]
     * @param {string} [queueName]
     * @param {string} [serviceName]
     * @param {boolean} [withHistory]
     * @param {string} [minDate]
     * @param {string} [maxDate]
     * @param {boolean} [withInProcessing]
     * @param {boolean} [withBusEvents]
     * @param {boolean} [withNotifications]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    getQueueEntries(accountId, queueName, serviceName, withHistory, minDate, maxDate, withInProcessing, withBusEvents, withNotifications, options) {
        return (0, exports.AdminApiFp)(this.configuration).getQueueEntries(accountId, queueName, serviceName, withHistory, minDate, maxDate, withInProcessing, withBusEvents, withNotifications, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Invalidates the given Cache if specified, otherwise invalidates all caches
     * @param {string} [cacheName]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    invalidatesCache(cacheName, options) {
        return (0, exports.AdminApiFp)(this.configuration).invalidatesCache(cacheName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Invalidates Caches per account level
     * @param {string} accountId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    invalidatesCacheByAccount(accountId, options) {
        return (0, exports.AdminApiFp)(this.configuration).invalidatesCacheByAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Invalidates Caches per tenant level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    invalidatesCacheByTenant(options) {
        return (0, exports.AdminApiFp)(this.configuration).invalidatesCacheByTenant(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put the host back into rotation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    putInRotation(options) {
        return (0, exports.AdminApiFp)(this.configuration).putInRotation(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Put the host out of rotation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    putOutOfRotation(options) {
        return (0, exports.AdminApiFp)(this.configuration).putOutOfRotation(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Trigger an invoice generation for all parked accounts
     * @param {string} xKillbillCreatedBy
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy, offset, limit, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AdminApiFp)(this.configuration).triggerInvoiceGenerationForParkedAccounts(xKillbillCreatedBy, offset, limit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update existing paymentTransaction and associated payment state
     * @param {AdminPayment} body
     * @param {string} paymentId
     * @param {string} paymentTransactionId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    updatePaymentTransactionState(body, paymentId, paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.AdminApiFp)(this.configuration).updatePaymentTransactionState(body, paymentId, paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.AdminApi = AdminApi;
/**
 * BundleApi - axios parameter creator
 * @export
 */
const BundleApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Block a bundle
         * @param {BlockingState} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBundleBlockingState: (body_1, bundleId_1, xKillbillCreatedBy_1, requestedDate_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [body_1, bundleId_1, xKillbillCreatedBy_1, requestedDate_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (body, bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('addBundleBlockingState', 'body', body);
            // verify required parameter 'bundleId' is not null or undefined
            (0, common_1.assertParamExists)('addBundleBlockingState', 'bundleId', bundleId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('addBundleBlockingState', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/bundles/{bundleId}/block`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString().substr(0, 10) :
                    requestedDate;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add custom fields to bundle
         * @param {Array<CustomField>} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundleCustomFields: (body_2, bundleId_2, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2) => __awaiter(this, [body_2, bundleId_2, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2], void 0, function* (body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createBundleCustomFields', 'body', body);
            // verify required parameter 'bundleId' is not null or undefined
            (0, common_1.assertParamExists)('createBundleCustomFields', 'bundleId', bundleId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createBundleCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/bundles/{bundleId}/customFields`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add tags to bundle
         * @param {Array<string>} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundleTags: (body_3, bundleId_3, xKillbillCreatedBy_3, xKillbillReason_3, xKillbillComment_3, ...args_3) => __awaiter(this, [body_3, bundleId_3, xKillbillCreatedBy_3, xKillbillReason_3, xKillbillComment_3, ...args_3], void 0, function* (body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createBundleTags', 'body', body);
            // verify required parameter 'bundleId' is not null or undefined
            (0, common_1.assertParamExists)('createBundleTags', 'bundleId', bundleId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createBundleTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/bundles/{bundleId}/tags`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove custom fields from bundle
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBundleCustomFields: (bundleId_4, xKillbillCreatedBy_4, customField_1, xKillbillReason_4, xKillbillComment_4, ...args_4) => __awaiter(this, [bundleId_4, xKillbillCreatedBy_4, customField_1, xKillbillReason_4, xKillbillComment_4, ...args_4], void 0, function* (bundleId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'bundleId' is not null or undefined
            (0, common_1.assertParamExists)('deleteBundleCustomFields', 'bundleId', bundleId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteBundleCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/bundles/{bundleId}/customFields`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove tags from bundle
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBundleTags: (bundleId_5, xKillbillCreatedBy_5, tagDef_1, xKillbillReason_5, xKillbillComment_5, ...args_5) => __awaiter(this, [bundleId_5, xKillbillCreatedBy_5, tagDef_1, xKillbillReason_5, xKillbillComment_5, ...args_5], void 0, function* (bundleId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'bundleId' is not null or undefined
            (0, common_1.assertParamExists)('deleteBundleTags', 'bundleId', bundleId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteBundleTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/bundles/{bundleId}/tags`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a bundle by id
         * @param {string} bundleId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundle: (bundleId_6, audit_1, ...args_6) => __awaiter(this, [bundleId_6, audit_1, ...args_6], void 0, function* (bundleId, audit, options = {}) {
            // verify required parameter 'bundleId' is not null or undefined
            (0, common_1.assertParamExists)('getBundle', 'bundleId', bundleId);
            const localVarPath = `/1.0/kb/bundles/{bundleId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve bundle audit logs with history by id
         * @param {string} bundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleAuditLogsWithHistory: (bundleId_7, ...args_7) => __awaiter(this, [bundleId_7, ...args_7], void 0, function* (bundleId, options = {}) {
            // verify required parameter 'bundleId' is not null or undefined
            (0, common_1.assertParamExists)('getBundleAuditLogsWithHistory', 'bundleId', bundleId);
            const localVarPath = `/1.0/kb/bundles/{bundleId}/auditLogsWithHistory`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a bundle by external key
         * @param {string} externalKey
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleByKey: (externalKey_1, includedDeleted_1, audit_2, ...args_8) => __awaiter(this, [externalKey_1, includedDeleted_1, audit_2, ...args_8], void 0, function* (externalKey, includedDeleted, audit, options = {}) {
            // verify required parameter 'externalKey' is not null or undefined
            (0, common_1.assertParamExists)('getBundleByKey', 'externalKey', externalKey);
            const localVarPath = `/1.0/kb/bundles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }
            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve bundle custom fields
         * @param {string} bundleId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleCustomFields: (bundleId_8, audit_3, ...args_9) => __awaiter(this, [bundleId_8, audit_3, ...args_9], void 0, function* (bundleId, audit, options = {}) {
            // verify required parameter 'bundleId' is not null or undefined
            (0, common_1.assertParamExists)('getBundleCustomFields', 'bundleId', bundleId);
            const localVarPath = `/1.0/kb/bundles/{bundleId}/customFields`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve bundle tags
         * @param {string} bundleId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleTags: (bundleId_9, includedDeleted_2, audit_4, ...args_10) => __awaiter(this, [bundleId_9, includedDeleted_2, audit_4, ...args_10], void 0, function* (bundleId, includedDeleted, audit, options = {}) {
            // verify required parameter 'bundleId' is not null or undefined
            (0, common_1.assertParamExists)('getBundleTags', 'bundleId', bundleId);
            const localVarPath = `/1.0/kb/bundles/{bundleId}/tags`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List bundles
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundles: (offset_1, limit_1, audit_5, ...args_11) => __awaiter(this, [offset_1, limit_1, audit_5, ...args_11], void 0, function* (offset, limit, audit, options = {}) {
            const localVarPath = `/1.0/kb/bundles/pagination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Modify custom fields to bundle
         * @param {Array<CustomField>} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyBundleCustomFields: (body_4, bundleId_10, xKillbillCreatedBy_6, xKillbillReason_6, xKillbillComment_6, ...args_12) => __awaiter(this, [body_4, bundleId_10, xKillbillCreatedBy_6, xKillbillReason_6, xKillbillComment_6, ...args_12], void 0, function* (body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('modifyBundleCustomFields', 'body', body);
            // verify required parameter 'bundleId' is not null or undefined
            (0, common_1.assertParamExists)('modifyBundleCustomFields', 'bundleId', bundleId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('modifyBundleCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/bundles/{bundleId}/customFields`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Pause a bundle
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseBundle: (bundleId_11, xKillbillCreatedBy_7, requestedDate_2, pluginProperty_2, xKillbillReason_7, xKillbillComment_7, ...args_13) => __awaiter(this, [bundleId_11, xKillbillCreatedBy_7, requestedDate_2, pluginProperty_2, xKillbillReason_7, xKillbillComment_7, ...args_13], void 0, function* (bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'bundleId' is not null or undefined
            (0, common_1.assertParamExists)('pauseBundle', 'bundleId', bundleId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('pauseBundle', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/bundles/{bundleId}/pause`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString().substr(0, 10) :
                    requestedDate;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update a bundle externalKey
         * @param {Bundle} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameExternalKey: (body_5, bundleId_12, xKillbillCreatedBy_8, xKillbillReason_8, xKillbillComment_8, ...args_14) => __awaiter(this, [body_5, bundleId_12, xKillbillCreatedBy_8, xKillbillReason_8, xKillbillComment_8, ...args_14], void 0, function* (body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('renameExternalKey', 'body', body);
            // verify required parameter 'bundleId' is not null or undefined
            (0, common_1.assertParamExists)('renameExternalKey', 'bundleId', bundleId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('renameExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/bundles/{bundleId}/renameKey`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Resume a bundle
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeBundle: (bundleId_13, xKillbillCreatedBy_9, requestedDate_3, pluginProperty_3, xKillbillReason_9, xKillbillComment_9, ...args_15) => __awaiter(this, [bundleId_13, xKillbillCreatedBy_9, requestedDate_3, pluginProperty_3, xKillbillReason_9, xKillbillComment_9, ...args_15], void 0, function* (bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'bundleId' is not null or undefined
            (0, common_1.assertParamExists)('resumeBundle', 'bundleId', bundleId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('resumeBundle', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/bundles/{bundleId}/resume`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString().substr(0, 10) :
                    requestedDate;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Search bundles
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBundles: (searchKey_1, offset_2, limit_2, audit_6, ...args_16) => __awaiter(this, [searchKey_1, offset_2, limit_2, audit_6, ...args_16], void 0, function* (searchKey, offset, limit, audit, options = {}) {
            // verify required parameter 'searchKey' is not null or undefined
            (0, common_1.assertParamExists)('searchBundles', 'searchKey', searchKey);
            const localVarPath = `/1.0/kb/bundles/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Transfer a bundle to another account
         * @param {Bundle} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy]
         * @param {'NONE' | 'USE_EXISTING' | 'ALIGN_WITH_EFF_DT'} [bcdTransfer]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferBundle: (body_6, bundleId_14, xKillbillCreatedBy_10, requestedDate_4, billingPolicy_1, bcdTransfer_1, pluginProperty_4, xKillbillReason_10, xKillbillComment_10, ...args_17) => __awaiter(this, [body_6, bundleId_14, xKillbillCreatedBy_10, requestedDate_4, billingPolicy_1, bcdTransfer_1, pluginProperty_4, xKillbillReason_10, xKillbillComment_10, ...args_17], void 0, function* (body, bundleId, xKillbillCreatedBy, requestedDate, billingPolicy, bcdTransfer, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('transferBundle', 'body', body);
            // verify required parameter 'bundleId' is not null or undefined
            (0, common_1.assertParamExists)('transferBundle', 'bundleId', bundleId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('transferBundle', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/bundles/{bundleId}`
                .replace(`{${"bundleId"}}`, encodeURIComponent(String(bundleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString().substr(0, 10) :
                    requestedDate;
            }
            if (billingPolicy !== undefined) {
                localVarQueryParameter['billingPolicy'] = billingPolicy;
            }
            if (bcdTransfer !== undefined) {
                localVarQueryParameter['bcdTransfer'] = bcdTransfer;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.BundleApiAxiosParamCreator = BundleApiAxiosParamCreator;
/**
 * BundleApi - functional programming interface
 * @export
 */
const BundleApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.BundleApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Block a bundle
         * @param {BlockingState} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBundleBlockingState(body, bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addBundleBlockingState(body, bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add custom fields to bundle
         * @param {Array<CustomField>} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add tags to bundle
         * @param {Array<string>} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundleTags(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createBundleTags(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove custom fields from bundle
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBundleCustomFields(bundleId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteBundleCustomFields(bundleId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove tags from bundle
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBundleTags(bundleId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteBundleTags(bundleId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a bundle by id
         * @param {string} bundleId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundle(bundleId, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBundle(bundleId, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve bundle audit logs with history by id
         * @param {string} bundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleAuditLogsWithHistory(bundleId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBundleAuditLogsWithHistory(bundleId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a bundle by external key
         * @param {string} externalKey
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleByKey(externalKey, includedDeleted, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBundleByKey(externalKey, includedDeleted, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve bundle custom fields
         * @param {string} bundleId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleCustomFields(bundleId, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBundleCustomFields(bundleId, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve bundle tags
         * @param {string} bundleId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleTags(bundleId, includedDeleted, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBundleTags(bundleId, includedDeleted, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List bundles
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundles(offset, limit, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getBundles(offset, limit, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Modify custom fields to bundle
         * @param {Array<CustomField>} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.modifyBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Pause a bundle
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.pauseBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Update a bundle externalKey
         * @param {Bundle} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameExternalKey(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.renameExternalKey(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Resume a bundle
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.resumeBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Search bundles
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBundles(searchKey, offset, limit, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchBundles(searchKey, offset, limit, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Transfer a bundle to another account
         * @param {Bundle} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy]
         * @param {'NONE' | 'USE_EXISTING' | 'ALIGN_WITH_EFF_DT'} [bcdTransfer]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferBundle(body, bundleId, xKillbillCreatedBy, requestedDate, billingPolicy, bcdTransfer, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.transferBundle(body, bundleId, xKillbillCreatedBy, requestedDate, billingPolicy, bcdTransfer, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.BundleApiFp = BundleApiFp;
/**
 * BundleApi - factory interface
 * @export
 */
const BundleApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.BundleApiFp)(configuration);
    return {
        /**
         *
         * @summary Block a bundle
         * @param {BlockingState} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addBundleBlockingState(body, bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.addBundleBlockingState(body, bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add custom fields to bundle
         * @param {Array<CustomField>} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add tags to bundle
         * @param {Array<string>} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBundleTags(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createBundleTags(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove custom fields from bundle
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBundleCustomFields(bundleId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteBundleCustomFields(bundleId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove tags from bundle
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBundleTags(bundleId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteBundleTags(bundleId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a bundle by id
         * @param {string} bundleId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundle(bundleId, audit, options) {
            return localVarFp.getBundle(bundleId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve bundle audit logs with history by id
         * @param {string} bundleId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleAuditLogsWithHistory(bundleId, options) {
            return localVarFp.getBundleAuditLogsWithHistory(bundleId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a bundle by external key
         * @param {string} externalKey
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleByKey(externalKey, includedDeleted, audit, options) {
            return localVarFp.getBundleByKey(externalKey, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve bundle custom fields
         * @param {string} bundleId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleCustomFields(bundleId, audit, options) {
            return localVarFp.getBundleCustomFields(bundleId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve bundle tags
         * @param {string} bundleId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundleTags(bundleId, includedDeleted, audit, options) {
            return localVarFp.getBundleTags(bundleId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List bundles
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBundles(offset, limit, audit, options) {
            return localVarFp.getBundles(offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Modify custom fields to bundle
         * @param {Array<CustomField>} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.modifyBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Pause a bundle
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pauseBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.pauseBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a bundle externalKey
         * @param {Bundle} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        renameExternalKey(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.renameExternalKey(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Resume a bundle
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resumeBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.resumeBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Search bundles
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBundles(searchKey, offset, limit, audit, options) {
            return localVarFp.searchBundles(searchKey, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Transfer a bundle to another account
         * @param {Bundle} body
         * @param {string} bundleId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy]
         * @param {'NONE' | 'USE_EXISTING' | 'ALIGN_WITH_EFF_DT'} [bcdTransfer]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        transferBundle(body, bundleId, xKillbillCreatedBy, requestedDate, billingPolicy, bcdTransfer, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.transferBundle(body, bundleId, xKillbillCreatedBy, requestedDate, billingPolicy, bcdTransfer, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.BundleApiFactory = BundleApiFactory;
/**
 * BundleApi - object-oriented interface
 * @export
 * @class BundleApi
 * @extends {BaseAPI}
 */
class BundleApi extends base_1.BaseAPI {
    /**
     *
     * @summary Block a bundle
     * @param {BlockingState} body
     * @param {string} bundleId
     * @param {string} xKillbillCreatedBy
     * @param {string} [requestedDate]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    addBundleBlockingState(body, bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.BundleApiFp)(this.configuration).addBundleBlockingState(body, bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add custom fields to bundle
     * @param {Array<CustomField>} body
     * @param {string} bundleId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    createBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.BundleApiFp)(this.configuration).createBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add tags to bundle
     * @param {Array<string>} body
     * @param {string} bundleId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    createBundleTags(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.BundleApiFp)(this.configuration).createBundleTags(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove custom fields from bundle
     * @param {string} bundleId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [customField]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    deleteBundleCustomFields(bundleId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
        return (0, exports.BundleApiFp)(this.configuration).deleteBundleCustomFields(bundleId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove tags from bundle
     * @param {string} bundleId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [tagDef]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    deleteBundleTags(bundleId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
        return (0, exports.BundleApiFp)(this.configuration).deleteBundleTags(bundleId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a bundle by id
     * @param {string} bundleId
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    getBundle(bundleId, audit, options) {
        return (0, exports.BundleApiFp)(this.configuration).getBundle(bundleId, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve bundle audit logs with history by id
     * @param {string} bundleId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    getBundleAuditLogsWithHistory(bundleId, options) {
        return (0, exports.BundleApiFp)(this.configuration).getBundleAuditLogsWithHistory(bundleId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a bundle by external key
     * @param {string} externalKey
     * @param {boolean} [includedDeleted]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    getBundleByKey(externalKey, includedDeleted, audit, options) {
        return (0, exports.BundleApiFp)(this.configuration).getBundleByKey(externalKey, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve bundle custom fields
     * @param {string} bundleId
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    getBundleCustomFields(bundleId, audit, options) {
        return (0, exports.BundleApiFp)(this.configuration).getBundleCustomFields(bundleId, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve bundle tags
     * @param {string} bundleId
     * @param {boolean} [includedDeleted]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    getBundleTags(bundleId, includedDeleted, audit, options) {
        return (0, exports.BundleApiFp)(this.configuration).getBundleTags(bundleId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List bundles
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    getBundles(offset, limit, audit, options) {
        return (0, exports.BundleApiFp)(this.configuration).getBundles(offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Modify custom fields to bundle
     * @param {Array<CustomField>} body
     * @param {string} bundleId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    modifyBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.BundleApiFp)(this.configuration).modifyBundleCustomFields(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Pause a bundle
     * @param {string} bundleId
     * @param {string} xKillbillCreatedBy
     * @param {string} [requestedDate]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    pauseBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.BundleApiFp)(this.configuration).pauseBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a bundle externalKey
     * @param {Bundle} body
     * @param {string} bundleId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    renameExternalKey(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.BundleApiFp)(this.configuration).renameExternalKey(body, bundleId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Resume a bundle
     * @param {string} bundleId
     * @param {string} xKillbillCreatedBy
     * @param {string} [requestedDate]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    resumeBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.BundleApiFp)(this.configuration).resumeBundle(bundleId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Search bundles
     * @param {string} searchKey
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    searchBundles(searchKey, offset, limit, audit, options) {
        return (0, exports.BundleApiFp)(this.configuration).searchBundles(searchKey, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Transfer a bundle to another account
     * @param {Bundle} body
     * @param {string} bundleId
     * @param {string} xKillbillCreatedBy
     * @param {string} [requestedDate]
     * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy]
     * @param {'NONE' | 'USE_EXISTING' | 'ALIGN_WITH_EFF_DT'} [bcdTransfer]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BundleApi
     */
    transferBundle(body, bundleId, xKillbillCreatedBy, requestedDate, billingPolicy, bcdTransfer, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.BundleApiFp)(this.configuration).transferBundle(body, bundleId, xKillbillCreatedBy, requestedDate, billingPolicy, bcdTransfer, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.BundleApi = BundleApi;
/**
 * CatalogApi - axios parameter creator
 * @export
 */
const CatalogApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Add a simple plan entry in the current version of the catalog
         * @param {SimplePlan} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSimplePlan: (body_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [body_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('addSimplePlan', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('addSimplePlan', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/catalog/simplePlan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete all versions for a per tenant catalog
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCatalog: (xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2) => __awaiter(this, [xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2], void 0, function* (xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteCatalog', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/catalog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve available add-ons for a given product
         * @param {string} [baseProductName]
         * @param {string} [priceListName]
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableAddons: (baseProductName_1, priceListName_1, accountId_1, ...args_3) => __awaiter(this, [baseProductName_1, priceListName_1, accountId_1, ...args_3], void 0, function* (baseProductName, priceListName, accountId, options = {}) {
            const localVarPath = `/1.0/kb/catalog/availableAddons`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (baseProductName !== undefined) {
                localVarQueryParameter['baseProductName'] = baseProductName;
            }
            if (priceListName !== undefined) {
                localVarQueryParameter['priceListName'] = priceListName;
            }
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve available base plans
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBasePlans: (accountId_2, ...args_4) => __awaiter(this, [accountId_2, ...args_4], void 0, function* (accountId, options = {}) {
            const localVarPath = `/1.0/kb/catalog/availableBasePlans`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve the catalog as JSON
         * @param {string} [requestedDate]
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogJson: (requestedDate_1, accountId_3, ...args_5) => __awaiter(this, [requestedDate_1, accountId_3, ...args_5], void 0, function* (requestedDate, accountId, options = {}) {
            const localVarPath = `/1.0/kb/catalog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString() :
                    requestedDate;
            }
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a list of catalog versions
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogVersions: (accountId_4, ...args_6) => __awaiter(this, [accountId_4, ...args_6], void 0, function* (accountId, options = {}) {
            const localVarPath = `/1.0/kb/catalog/versions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve the full catalog as XML
         * @param {string} [requestedDate]
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogXml: (requestedDate_2, accountId_5, ...args_7) => __awaiter(this, [requestedDate_2, accountId_5, ...args_7], void 0, function* (requestedDate, accountId, options = {}) {
            const localVarPath = `/1.0/kb/catalog/xml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString() :
                    requestedDate;
            }
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve phase for a given subscription and date
         * @param {string} [subscriptionId]
         * @param {string} [requestedDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhaseForSubscriptionAndDate: (subscriptionId_1, requestedDate_3, ...args_8) => __awaiter(this, [subscriptionId_1, requestedDate_3, ...args_8], void 0, function* (subscriptionId, requestedDate, options = {}) {
            const localVarPath = `/1.0/kb/catalog/phase`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscriptionId'] = subscriptionId;
            }
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString().substr(0, 10) :
                    requestedDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve plan for a given subscription and date
         * @param {string} [subscriptionId]
         * @param {string} [requestedDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlanForSubscriptionAndDate: (subscriptionId_2, requestedDate_4, ...args_9) => __awaiter(this, [subscriptionId_2, requestedDate_4, ...args_9], void 0, function* (subscriptionId, requestedDate, options = {}) {
            const localVarPath = `/1.0/kb/catalog/plan`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscriptionId'] = subscriptionId;
            }
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString().substr(0, 10) :
                    requestedDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve priceList for a given subscription and date
         * @param {string} [subscriptionId]
         * @param {string} [requestedDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPriceListForSubscriptionAndDate: (subscriptionId_3, requestedDate_5, ...args_10) => __awaiter(this, [subscriptionId_3, requestedDate_5, ...args_10], void 0, function* (subscriptionId, requestedDate, options = {}) {
            const localVarPath = `/1.0/kb/catalog/priceList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscriptionId'] = subscriptionId;
            }
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString().substr(0, 10) :
                    requestedDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve product for a given subscription and date
         * @param {string} [subscriptionId]
         * @param {string} [requestedDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductForSubscriptionAndDate: (subscriptionId_4, requestedDate_6, ...args_11) => __awaiter(this, [subscriptionId_4, requestedDate_6, ...args_11], void 0, function* (subscriptionId, requestedDate, options = {}) {
            const localVarPath = `/1.0/kb/catalog/product`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (subscriptionId !== undefined) {
                localVarQueryParameter['subscriptionId'] = subscriptionId;
            }
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString().substr(0, 10) :
                    requestedDate;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Upload the full catalog as XML
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCatalogXml: (body_2, xKillbillCreatedBy_3, xKillbillReason_3, xKillbillComment_3, ...args_12) => __awaiter(this, [body_2, xKillbillCreatedBy_3, xKillbillReason_3, xKillbillComment_3, ...args_12], void 0, function* (body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('uploadCatalogXml', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('uploadCatalogXml', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/catalog/xml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'text/xml';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Validate a XML catalog
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateCatalogXml: (body_3, xKillbillCreatedBy_4, xKillbillReason_4, xKillbillComment_4, ...args_13) => __awaiter(this, [body_3, xKillbillCreatedBy_4, xKillbillReason_4, xKillbillComment_4, ...args_13], void 0, function* (body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('validateCatalogXml', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('validateCatalogXml', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/catalog/xml/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'text/xml';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CatalogApiAxiosParamCreator = CatalogApiAxiosParamCreator;
/**
 * CatalogApi - functional programming interface
 * @export
 */
const CatalogApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CatalogApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Add a simple plan entry in the current version of the catalog
         * @param {SimplePlan} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSimplePlan(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addSimplePlan(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Delete all versions for a per tenant catalog
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCatalog(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteCatalog(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve available add-ons for a given product
         * @param {string} [baseProductName]
         * @param {string} [priceListName]
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableAddons(baseProductName, priceListName, accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAvailableAddons(baseProductName, priceListName, accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve available base plans
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBasePlans(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAvailableBasePlans(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve the catalog as JSON
         * @param {string} [requestedDate]
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogJson(requestedDate, accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCatalogJson(requestedDate, accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a list of catalog versions
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogVersions(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCatalogVersions(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve the full catalog as XML
         * @param {string} [requestedDate]
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogXml(requestedDate, accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCatalogXml(requestedDate, accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve phase for a given subscription and date
         * @param {string} [subscriptionId]
         * @param {string} [requestedDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhaseForSubscriptionAndDate(subscriptionId, requestedDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPhaseForSubscriptionAndDate(subscriptionId, requestedDate, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve plan for a given subscription and date
         * @param {string} [subscriptionId]
         * @param {string} [requestedDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlanForSubscriptionAndDate(subscriptionId, requestedDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPlanForSubscriptionAndDate(subscriptionId, requestedDate, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve priceList for a given subscription and date
         * @param {string} [subscriptionId]
         * @param {string} [requestedDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPriceListForSubscriptionAndDate(subscriptionId, requestedDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPriceListForSubscriptionAndDate(subscriptionId, requestedDate, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve product for a given subscription and date
         * @param {string} [subscriptionId]
         * @param {string} [requestedDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductForSubscriptionAndDate(subscriptionId, requestedDate, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getProductForSubscriptionAndDate(subscriptionId, requestedDate, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Upload the full catalog as XML
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Validate a XML catalog
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.validateCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.CatalogApiFp = CatalogApiFp;
/**
 * CatalogApi - factory interface
 * @export
 */
const CatalogApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CatalogApiFp)(configuration);
    return {
        /**
         *
         * @summary Add a simple plan entry in the current version of the catalog
         * @param {SimplePlan} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSimplePlan(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.addSimplePlan(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete all versions for a per tenant catalog
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCatalog(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteCatalog(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve available add-ons for a given product
         * @param {string} [baseProductName]
         * @param {string} [priceListName]
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableAddons(baseProductName, priceListName, accountId, options) {
            return localVarFp.getAvailableAddons(baseProductName, priceListName, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve available base plans
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAvailableBasePlans(accountId, options) {
            return localVarFp.getAvailableBasePlans(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve the catalog as JSON
         * @param {string} [requestedDate]
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogJson(requestedDate, accountId, options) {
            return localVarFp.getCatalogJson(requestedDate, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a list of catalog versions
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogVersions(accountId, options) {
            return localVarFp.getCatalogVersions(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve the full catalog as XML
         * @param {string} [requestedDate]
         * @param {string} [accountId]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogXml(requestedDate, accountId, options) {
            return localVarFp.getCatalogXml(requestedDate, accountId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve phase for a given subscription and date
         * @param {string} [subscriptionId]
         * @param {string} [requestedDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPhaseForSubscriptionAndDate(subscriptionId, requestedDate, options) {
            return localVarFp.getPhaseForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve plan for a given subscription and date
         * @param {string} [subscriptionId]
         * @param {string} [requestedDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlanForSubscriptionAndDate(subscriptionId, requestedDate, options) {
            return localVarFp.getPlanForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve priceList for a given subscription and date
         * @param {string} [subscriptionId]
         * @param {string} [requestedDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPriceListForSubscriptionAndDate(subscriptionId, requestedDate, options) {
            return localVarFp.getPriceListForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve product for a given subscription and date
         * @param {string} [subscriptionId]
         * @param {string} [requestedDate]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductForSubscriptionAndDate(subscriptionId, requestedDate, options) {
            return localVarFp.getProductForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload the full catalog as XML
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.uploadCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Validate a XML catalog
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.validateCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CatalogApiFactory = CatalogApiFactory;
/**
 * CatalogApi - object-oriented interface
 * @export
 * @class CatalogApi
 * @extends {BaseAPI}
 */
class CatalogApi extends base_1.BaseAPI {
    /**
     *
     * @summary Add a simple plan entry in the current version of the catalog
     * @param {SimplePlan} body
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    addSimplePlan(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.CatalogApiFp)(this.configuration).addSimplePlan(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete all versions for a per tenant catalog
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    deleteCatalog(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.CatalogApiFp)(this.configuration).deleteCatalog(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve available add-ons for a given product
     * @param {string} [baseProductName]
     * @param {string} [priceListName]
     * @param {string} [accountId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    getAvailableAddons(baseProductName, priceListName, accountId, options) {
        return (0, exports.CatalogApiFp)(this.configuration).getAvailableAddons(baseProductName, priceListName, accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve available base plans
     * @param {string} [accountId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    getAvailableBasePlans(accountId, options) {
        return (0, exports.CatalogApiFp)(this.configuration).getAvailableBasePlans(accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve the catalog as JSON
     * @param {string} [requestedDate]
     * @param {string} [accountId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    getCatalogJson(requestedDate, accountId, options) {
        return (0, exports.CatalogApiFp)(this.configuration).getCatalogJson(requestedDate, accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a list of catalog versions
     * @param {string} [accountId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    getCatalogVersions(accountId, options) {
        return (0, exports.CatalogApiFp)(this.configuration).getCatalogVersions(accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve the full catalog as XML
     * @param {string} [requestedDate]
     * @param {string} [accountId]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    getCatalogXml(requestedDate, accountId, options) {
        return (0, exports.CatalogApiFp)(this.configuration).getCatalogXml(requestedDate, accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve phase for a given subscription and date
     * @param {string} [subscriptionId]
     * @param {string} [requestedDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    getPhaseForSubscriptionAndDate(subscriptionId, requestedDate, options) {
        return (0, exports.CatalogApiFp)(this.configuration).getPhaseForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve plan for a given subscription and date
     * @param {string} [subscriptionId]
     * @param {string} [requestedDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    getPlanForSubscriptionAndDate(subscriptionId, requestedDate, options) {
        return (0, exports.CatalogApiFp)(this.configuration).getPlanForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve priceList for a given subscription and date
     * @param {string} [subscriptionId]
     * @param {string} [requestedDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    getPriceListForSubscriptionAndDate(subscriptionId, requestedDate, options) {
        return (0, exports.CatalogApiFp)(this.configuration).getPriceListForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve product for a given subscription and date
     * @param {string} [subscriptionId]
     * @param {string} [requestedDate]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    getProductForSubscriptionAndDate(subscriptionId, requestedDate, options) {
        return (0, exports.CatalogApiFp)(this.configuration).getProductForSubscriptionAndDate(subscriptionId, requestedDate, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Upload the full catalog as XML
     * @param {string} body
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    uploadCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.CatalogApiFp)(this.configuration).uploadCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Validate a XML catalog
     * @param {string} body
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CatalogApi
     */
    validateCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.CatalogApiFp)(this.configuration).validateCatalogXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CatalogApi = CatalogApi;
/**
 * CreditApi - axios parameter creator
 * @export
 */
const CreditApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a credit
         * @param {Array<InvoiceItem>} body
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [autoCommit]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredits: (body_1, xKillbillCreatedBy_1, autoCommit_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [body_1, xKillbillCreatedBy_1, autoCommit_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (body, xKillbillCreatedBy, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createCredits', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createCredits', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/credits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (autoCommit !== undefined) {
                localVarQueryParameter['autoCommit'] = autoCommit;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a credit by id
         * @param {string} creditId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit: (creditId_1, ...args_2) => __awaiter(this, [creditId_1, ...args_2], void 0, function* (creditId, options = {}) {
            // verify required parameter 'creditId' is not null or undefined
            (0, common_1.assertParamExists)('getCredit', 'creditId', creditId);
            const localVarPath = `/1.0/kb/credits/{creditId}`
                .replace(`{${"creditId"}}`, encodeURIComponent(String(creditId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CreditApiAxiosParamCreator = CreditApiAxiosParamCreator;
/**
 * CreditApi - functional programming interface
 * @export
 */
const CreditApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CreditApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a credit
         * @param {Array<InvoiceItem>} body
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [autoCommit]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredits(body, xKillbillCreatedBy, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createCredits(body, xKillbillCreatedBy, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a credit by id
         * @param {string} creditId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit(creditId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCredit(creditId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.CreditApiFp = CreditApiFp;
/**
 * CreditApi - factory interface
 * @export
 */
const CreditApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CreditApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a credit
         * @param {Array<InvoiceItem>} body
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [autoCommit]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCredits(body, xKillbillCreatedBy, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createCredits(body, xKillbillCreatedBy, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a credit by id
         * @param {string} creditId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCredit(creditId, options) {
            return localVarFp.getCredit(creditId, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CreditApiFactory = CreditApiFactory;
/**
 * CreditApi - object-oriented interface
 * @export
 * @class CreditApi
 * @extends {BaseAPI}
 */
class CreditApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create a credit
     * @param {Array<InvoiceItem>} body
     * @param {string} xKillbillCreatedBy
     * @param {boolean} [autoCommit]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    createCredits(body, xKillbillCreatedBy, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.CreditApiFp)(this.configuration).createCredits(body, xKillbillCreatedBy, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a credit by id
     * @param {string} creditId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CreditApi
     */
    getCredit(creditId, options) {
        return (0, exports.CreditApiFp)(this.configuration).getCredit(creditId, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CreditApi = CreditApi;
/**
 * CustomFieldApi - axios parameter creator
 * @export
 */
const CustomFieldApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Retrieve custom field audit logs with history by id
         * @param {string} customFieldId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomFieldAuditLogsWithHistory: (customFieldId_1, ...args_1) => __awaiter(this, [customFieldId_1, ...args_1], void 0, function* (customFieldId, options = {}) {
            // verify required parameter 'customFieldId' is not null or undefined
            (0, common_1.assertParamExists)('getCustomFieldAuditLogsWithHistory', 'customFieldId', customFieldId);
            const localVarPath = `/1.0/kb/customFields/{customFieldId}/auditLogsWithHistory`
                .replace(`{${"customFieldId"}}`, encodeURIComponent(String(customFieldId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List custom fields
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomFields: (offset_1, limit_1, audit_1, ...args_2) => __awaiter(this, [offset_1, limit_1, audit_1, ...args_2], void 0, function* (offset, limit, audit, options = {}) {
            const localVarPath = `/1.0/kb/customFields/pagination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Search custom fields
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomFields: (searchKey_1, offset_2, limit_2, audit_2, ...args_3) => __awaiter(this, [searchKey_1, offset_2, limit_2, audit_2, ...args_3], void 0, function* (searchKey, offset, limit, audit, options = {}) {
            // verify required parameter 'searchKey' is not null or undefined
            (0, common_1.assertParamExists)('searchCustomFields', 'searchKey', searchKey);
            const localVarPath = `/1.0/kb/customFields/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Search custom fields by type, name and optional value
         * @param {string} [objectType]
         * @param {string} [fieldName]
         * @param {string} [fieldValue]
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomFieldsByTypeName: (objectType_1, fieldName_1, fieldValue_1, offset_3, limit_3, audit_3, ...args_4) => __awaiter(this, [objectType_1, fieldName_1, fieldValue_1, offset_3, limit_3, audit_3, ...args_4], void 0, function* (objectType, fieldName, fieldValue, offset, limit, audit, options = {}) {
            const localVarPath = `/1.0/kb/customFields/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (objectType !== undefined) {
                localVarQueryParameter['objectType'] = objectType;
            }
            if (fieldName !== undefined) {
                localVarQueryParameter['fieldName'] = fieldName;
            }
            if (fieldValue !== undefined) {
                localVarQueryParameter['fieldValue'] = fieldValue;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CustomFieldApiAxiosParamCreator = CustomFieldApiAxiosParamCreator;
/**
 * CustomFieldApi - functional programming interface
 * @export
 */
const CustomFieldApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CustomFieldApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve custom field audit logs with history by id
         * @param {string} customFieldId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomFieldAuditLogsWithHistory(customFieldId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCustomFieldAuditLogsWithHistory(customFieldId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List custom fields
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomFields(offset, limit, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCustomFields(offset, limit, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Search custom fields
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomFields(searchKey, offset, limit, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchCustomFields(searchKey, offset, limit, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Search custom fields by type, name and optional value
         * @param {string} [objectType]
         * @param {string} [fieldName]
         * @param {string} [fieldValue]
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomFieldsByTypeName(objectType, fieldName, fieldValue, offset, limit, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchCustomFieldsByTypeName(objectType, fieldName, fieldValue, offset, limit, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.CustomFieldApiFp = CustomFieldApiFp;
/**
 * CustomFieldApi - factory interface
 * @export
 */
const CustomFieldApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CustomFieldApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve custom field audit logs with history by id
         * @param {string} customFieldId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomFieldAuditLogsWithHistory(customFieldId, options) {
            return localVarFp.getCustomFieldAuditLogsWithHistory(customFieldId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List custom fields
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomFields(offset, limit, audit, options) {
            return localVarFp.getCustomFields(offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Search custom fields
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomFields(searchKey, offset, limit, audit, options) {
            return localVarFp.searchCustomFields(searchKey, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Search custom fields by type, name and optional value
         * @param {string} [objectType]
         * @param {string} [fieldName]
         * @param {string} [fieldValue]
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchCustomFieldsByTypeName(objectType, fieldName, fieldValue, offset, limit, audit, options) {
            return localVarFp.searchCustomFieldsByTypeName(objectType, fieldName, fieldValue, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CustomFieldApiFactory = CustomFieldApiFactory;
/**
 * CustomFieldApi - object-oriented interface
 * @export
 * @class CustomFieldApi
 * @extends {BaseAPI}
 */
class CustomFieldApi extends base_1.BaseAPI {
    /**
     *
     * @summary Retrieve custom field audit logs with history by id
     * @param {string} customFieldId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldApi
     */
    getCustomFieldAuditLogsWithHistory(customFieldId, options) {
        return (0, exports.CustomFieldApiFp)(this.configuration).getCustomFieldAuditLogsWithHistory(customFieldId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List custom fields
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldApi
     */
    getCustomFields(offset, limit, audit, options) {
        return (0, exports.CustomFieldApiFp)(this.configuration).getCustomFields(offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Search custom fields
     * @param {string} searchKey
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldApi
     */
    searchCustomFields(searchKey, offset, limit, audit, options) {
        return (0, exports.CustomFieldApiFp)(this.configuration).searchCustomFields(searchKey, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Search custom fields by type, name and optional value
     * @param {string} [objectType]
     * @param {string} [fieldName]
     * @param {string} [fieldValue]
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomFieldApi
     */
    searchCustomFieldsByTypeName(objectType, fieldName, fieldValue, offset, limit, audit, options) {
        return (0, exports.CustomFieldApiFp)(this.configuration).searchCustomFieldsByTypeName(objectType, fieldName, fieldValue, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CustomFieldApi = CustomFieldApi;
/**
 * ExportApi - axios parameter creator
 * @export
 */
const ExportApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Export account data
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDataForAccount: (accountId_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [accountId_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('exportDataForAccount', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('exportDataForAccount', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/export/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ExportApiAxiosParamCreator = ExportApiAxiosParamCreator;
/**
 * ExportApi - functional programming interface
 * @export
 */
const ExportApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ExportApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Export account data
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDataForAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.exportDataForAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ExportApiFp = ExportApiFp;
/**
 * ExportApi - factory interface
 * @export
 */
const ExportApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ExportApiFp)(configuration);
    return {
        /**
         *
         * @summary Export account data
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDataForAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.exportDataForAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.ExportApiFactory = ExportApiFactory;
/**
 * ExportApi - object-oriented interface
 * @export
 * @class ExportApi
 * @extends {BaseAPI}
 */
class ExportApi extends base_1.BaseAPI {
    /**
     *
     * @summary Export account data
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    exportDataForAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.ExportApiFp)(this.configuration).exportDataForAccount(accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.ExportApi = ExportApi;
/**
 * InvoiceApi - axios parameter creator
 * @export
 */
const InvoiceApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Adjust an invoice item
         * @param {InvoiceItem} body
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustInvoiceItem: (body_1, invoiceId_1, xKillbillCreatedBy_1, requestedDate_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [body_1, invoiceId_1, xKillbillCreatedBy_1, requestedDate_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (body, invoiceId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('adjustInvoiceItem', 'body', body);
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('adjustInvoiceItem', 'invoiceId', invoiceId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('adjustInvoiceItem', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString().substr(0, 10) :
                    requestedDate;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Perform the invoice status transition from DRAFT to COMMITTED
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitInvoice: (invoiceId_2, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2) => __awaiter(this, [invoiceId_2, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2], void 0, function* (invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('commitInvoice', 'invoiceId', invoiceId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('commitInvoice', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/commitInvoice`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create external charge(s)
         * @param {Array<InvoiceItem>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {boolean} [autoCommit]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalCharges: (body_2, accountId_1, xKillbillCreatedBy_3, requestedDate_2, autoCommit_1, pluginProperty_2, xKillbillReason_3, xKillbillComment_3, ...args_3) => __awaiter(this, [body_2, accountId_1, xKillbillCreatedBy_3, requestedDate_2, autoCommit_1, pluginProperty_2, xKillbillReason_3, xKillbillComment_3, ...args_3], void 0, function* (body, accountId, xKillbillCreatedBy, requestedDate, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createExternalCharges', 'body', body);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createExternalCharges', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createExternalCharges', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/charges/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString().substr(0, 10) :
                    requestedDate;
            }
            if (autoCommit !== undefined) {
                localVarQueryParameter['autoCommit'] = autoCommit;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Trigger an invoice generation
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [targetDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFutureInvoice: (accountId_2, xKillbillCreatedBy_4, targetDate_1, pluginProperty_3, xKillbillReason_4, xKillbillComment_4, ...args_4) => __awaiter(this, [accountId_2, xKillbillCreatedBy_4, targetDate_1, pluginProperty_3, xKillbillReason_4, xKillbillComment_4, ...args_4], void 0, function* (accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createFutureInvoice', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createFutureInvoice', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            if (targetDate !== undefined) {
                localVarQueryParameter['targetDate'] = (targetDate instanceof Date) ?
                    targetDate.toISOString().substr(0, 10) :
                    targetDate;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Trigger an invoice generation
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [targetDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFutureInvoiceGroup: (accountId_3, xKillbillCreatedBy_5, targetDate_2, pluginProperty_4, xKillbillReason_5, xKillbillComment_5, ...args_5) => __awaiter(this, [accountId_3, xKillbillCreatedBy_5, targetDate_2, pluginProperty_4, xKillbillReason_5, xKillbillComment_5, ...args_5], void 0, function* (accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createFutureInvoiceGroup', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createFutureInvoiceGroup', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/group`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            if (targetDate !== undefined) {
                localVarQueryParameter['targetDate'] = (targetDate instanceof Date) ?
                    targetDate.toISOString().substr(0, 10) :
                    targetDate;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Trigger a payment for invoice
         * @param {InvoicePayment} body
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [externalPayment]
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstantPayment: (body_3, invoiceId_3, xKillbillCreatedBy_6, externalPayment_1, controlPluginName_1, pluginProperty_5, xKillbillReason_6, xKillbillComment_6, ...args_6) => __awaiter(this, [body_3, invoiceId_3, xKillbillCreatedBy_6, externalPayment_1, controlPluginName_1, pluginProperty_5, xKillbillReason_6, xKillbillComment_6, ...args_6], void 0, function* (body, invoiceId, xKillbillCreatedBy, externalPayment, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createInstantPayment', 'body', body);
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('createInstantPayment', 'invoiceId', invoiceId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createInstantPayment', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/payments`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (externalPayment !== undefined) {
                localVarQueryParameter['externalPayment'] = externalPayment;
            }
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add custom fields to invoice
         * @param {Array<CustomField>} body
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceCustomFields: (body_4, invoiceId_4, xKillbillCreatedBy_7, xKillbillReason_7, xKillbillComment_7, ...args_7) => __awaiter(this, [body_4, invoiceId_4, xKillbillCreatedBy_7, xKillbillReason_7, xKillbillComment_7, ...args_7], void 0, function* (body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createInvoiceCustomFields', 'body', body);
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('createInvoiceCustomFields', 'invoiceId', invoiceId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createInvoiceCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/customFields`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add tags to invoice
         * @param {Array<string>} body
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceTags: (body_5, invoiceId_5, xKillbillCreatedBy_8, xKillbillReason_8, xKillbillComment_8, ...args_8) => __awaiter(this, [body_5, invoiceId_5, xKillbillCreatedBy_8, xKillbillReason_8, xKillbillComment_8, ...args_8], void 0, function* (body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createInvoiceTags', 'body', body);
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('createInvoiceTags', 'invoiceId', invoiceId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createInvoiceTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/tags`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create a migration invoice
         * @param {Array<InvoiceItem>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [targetDate]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMigrationInvoice: (body_6, accountId_4, xKillbillCreatedBy_9, targetDate_3, xKillbillReason_9, xKillbillComment_9, ...args_9) => __awaiter(this, [body_6, accountId_4, xKillbillCreatedBy_9, targetDate_3, xKillbillReason_9, xKillbillComment_9, ...args_9], void 0, function* (body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createMigrationInvoice', 'body', body);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createMigrationInvoice', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createMigrationInvoice', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/migration/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (targetDate !== undefined) {
                localVarQueryParameter['targetDate'] = (targetDate instanceof Date) ?
                    targetDate.toISOString().substr(0, 10) :
                    targetDate;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create tax items
         * @param {Array<InvoiceItem>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [autoCommit]
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaxItems: (body_7, accountId_5, xKillbillCreatedBy_10, autoCommit_2, requestedDate_3, pluginProperty_6, xKillbillReason_10, xKillbillComment_10, ...args_10) => __awaiter(this, [body_7, accountId_5, xKillbillCreatedBy_10, autoCommit_2, requestedDate_3, pluginProperty_6, xKillbillReason_10, xKillbillComment_10, ...args_10], void 0, function* (body, accountId, xKillbillCreatedBy, autoCommit, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createTaxItems', 'body', body);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('createTaxItems', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createTaxItems', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/taxes/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (autoCommit !== undefined) {
                localVarQueryParameter['autoCommit'] = autoCommit;
            }
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString().substr(0, 10) :
                    requestedDate;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a CBA item
         * @param {string} invoiceId
         * @param {string} invoiceItemId
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCBA: (invoiceId_6, invoiceItemId_1, accountId_6, xKillbillCreatedBy_11, xKillbillReason_11, xKillbillComment_11, ...args_11) => __awaiter(this, [invoiceId_6, invoiceItemId_1, accountId_6, xKillbillCreatedBy_11, xKillbillReason_11, xKillbillComment_11, ...args_11], void 0, function* (invoiceId, invoiceItemId, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('deleteCBA', 'invoiceId', invoiceId);
            // verify required parameter 'invoiceItemId' is not null or undefined
            (0, common_1.assertParamExists)('deleteCBA', 'invoiceItemId', invoiceItemId);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('deleteCBA', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteCBA', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/{invoiceItemId}/cba`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)))
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove custom fields from invoice
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceCustomFields: (invoiceId_7, xKillbillCreatedBy_12, customField_1, xKillbillReason_12, xKillbillComment_12, ...args_12) => __awaiter(this, [invoiceId_7, xKillbillCreatedBy_12, customField_1, xKillbillReason_12, xKillbillComment_12, ...args_12], void 0, function* (invoiceId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoiceCustomFields', 'invoiceId', invoiceId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoiceCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/customFields`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove tags from invoice
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceTags: (invoiceId_8, xKillbillCreatedBy_13, tagDef_1, xKillbillReason_13, xKillbillComment_13, ...args_13) => __awaiter(this, [invoiceId_8, xKillbillCreatedBy_13, tagDef_1, xKillbillReason_13, xKillbillComment_13, ...args_13], void 0, function* (invoiceId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoiceTags', 'invoiceId', invoiceId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoiceTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/tags`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Generate a dryRun invoice
         * @param {InvoiceDryRun} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [targetDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateDryRunInvoice: (body_8, accountId_7, xKillbillCreatedBy_14, targetDate_4, pluginProperty_7, xKillbillReason_14, xKillbillComment_14, ...args_14) => __awaiter(this, [body_8, accountId_7, xKillbillCreatedBy_14, targetDate_4, pluginProperty_7, xKillbillReason_14, xKillbillComment_14, ...args_14], void 0, function* (body, accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('generateDryRunInvoice', 'body', body);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('generateDryRunInvoice', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('generateDryRunInvoice', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/dryRun`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            if (targetDate !== undefined) {
                localVarQueryParameter['targetDate'] = (targetDate instanceof Date) ?
                    targetDate.toISOString().substr(0, 10) :
                    targetDate;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieves the catalog translation for the tenant
         * @param {string} locale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogTranslation: (locale_1, ...args_15) => __awaiter(this, [locale_1, ...args_15], void 0, function* (locale, options = {}) {
            // verify required parameter 'locale' is not null or undefined
            (0, common_1.assertParamExists)('getCatalogTranslation', 'locale', locale);
            const localVarPath = `/1.0/kb/invoices/catalogTranslation/{locale}`
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve an invoice by id
         * @param {string} invoiceId
         * @param {boolean} [withChildrenItems]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice: (invoiceId_9, withChildrenItems_1, audit_1, ...args_16) => __awaiter(this, [invoiceId_9, withChildrenItems_1, audit_1, ...args_16], void 0, function* (invoiceId, withChildrenItems, audit, options = {}) {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoice', 'invoiceId', invoiceId);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (withChildrenItems !== undefined) {
                localVarQueryParameter['withChildrenItems'] = withChildrenItems;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Render an invoice as HTML
         * @param {string} invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAsHTML: (invoiceId_10, ...args_17) => __awaiter(this, [invoiceId_10, ...args_17], void 0, function* (invoiceId, options = {}) {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoiceAsHTML', 'invoiceId', invoiceId);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/html`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve invoice audit logs with history by id
         * @param {string} invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAuditLogsWithHistory: (invoiceId_11, ...args_18) => __awaiter(this, [invoiceId_11, ...args_18], void 0, function* (invoiceId, options = {}) {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoiceAuditLogsWithHistory', 'invoiceId', invoiceId);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/auditLogsWithHistory`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve an invoice by invoice item id
         * @param {string} itemId
         * @param {boolean} [withChildrenItems]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceByItemId: (itemId_1, withChildrenItems_2, audit_2, ...args_19) => __awaiter(this, [itemId_1, withChildrenItems_2, audit_2, ...args_19], void 0, function* (itemId, withChildrenItems, audit, options = {}) {
            // verify required parameter 'itemId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoiceByItemId', 'itemId', itemId);
            const localVarPath = `/1.0/kb/invoices/byItemId/{itemId}`
                .replace(`{${"itemId"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (withChildrenItems !== undefined) {
                localVarQueryParameter['withChildrenItems'] = withChildrenItems;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve an invoice by number
         * @param {number} invoiceNumber
         * @param {boolean} [withChildrenItems]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceByNumber: (invoiceNumber_1, withChildrenItems_3, audit_3, ...args_20) => __awaiter(this, [invoiceNumber_1, withChildrenItems_3, audit_3, ...args_20], void 0, function* (invoiceNumber, withChildrenItems, audit, options = {}) {
            // verify required parameter 'invoiceNumber' is not null or undefined
            (0, common_1.assertParamExists)('getInvoiceByNumber', 'invoiceNumber', invoiceNumber);
            const localVarPath = `/1.0/kb/invoices/byNumber/{invoiceNumber}`
                .replace(`{${"invoiceNumber"}}`, encodeURIComponent(String(invoiceNumber)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (withChildrenItems !== undefined) {
                localVarQueryParameter['withChildrenItems'] = withChildrenItems;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve invoice custom fields
         * @param {string} invoiceId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceCustomFields: (invoiceId_12, audit_4, ...args_21) => __awaiter(this, [invoiceId_12, audit_4, ...args_21], void 0, function* (invoiceId, audit, options = {}) {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoiceCustomFields', 'invoiceId', invoiceId);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/customFields`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieves the manualPay invoice template for the tenant
         * @param {string} locale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceMPTemplate: (locale_2, ...args_22) => __awaiter(this, [locale_2, ...args_22], void 0, function* (locale, options = {}) {
            // verify required parameter 'locale' is not null or undefined
            (0, common_1.assertParamExists)('getInvoiceMPTemplate', 'locale', locale);
            const localVarPath = `/1.0/kb/invoices/manualPayTemplate/{locale}`
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve invoice tags
         * @param {string} invoiceId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTags: (invoiceId_13, includedDeleted_1, audit_5, ...args_23) => __awaiter(this, [invoiceId_13, includedDeleted_1, audit_5, ...args_23], void 0, function* (invoiceId, includedDeleted, audit, options = {}) {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoiceTags', 'invoiceId', invoiceId);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/tags`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieves the invoice template for the tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTemplate: (...args_24) => __awaiter(this, [...args_24], void 0, function* (options = {}) {
            const localVarPath = `/1.0/kb/invoices/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieves the invoice translation for the tenant
         * @param {string} locale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTranslation: (locale_3, ...args_25) => __awaiter(this, [locale_3, ...args_25], void 0, function* (locale, options = {}) {
            // verify required parameter 'locale' is not null or undefined
            (0, common_1.assertParamExists)('getInvoiceTranslation', 'locale', locale);
            const localVarPath = `/1.0/kb/invoices/translation/{locale}`
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List invoices
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices: (offset_1, limit_1, audit_6, ...args_26) => __awaiter(this, [offset_1, limit_1, audit_6, ...args_26], void 0, function* (offset, limit, audit, options = {}) {
            const localVarPath = `/1.0/kb/invoices/pagination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a set of invoices by group id
         * @param {string} groupId
         * @param {string} accountId
         * @param {boolean} [withChildrenItems]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesGroup: (groupId_1, accountId_8, withChildrenItems_4, audit_7, ...args_27) => __awaiter(this, [groupId_1, accountId_8, withChildrenItems_4, audit_7, ...args_27], void 0, function* (groupId, accountId, withChildrenItems, audit, options = {}) {
            // verify required parameter 'groupId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoicesGroup', 'groupId', groupId);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoicesGroup', 'accountId', accountId);
            const localVarPath = `/1.0/kb/invoices/{groupId}/group`
                .replace(`{${"groupId"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            if (withChildrenItems !== undefined) {
                localVarQueryParameter['withChildrenItems'] = withChildrenItems;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve payments associated with an invoice
         * @param {string} invoiceId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForInvoice: (invoiceId_14, withPluginInfo_1, withAttempts_1, audit_8, ...args_28) => __awaiter(this, [invoiceId_14, withPluginInfo_1, withAttempts_1, audit_8, ...args_28], void 0, function* (invoiceId, withPluginInfo, withAttempts, audit, options = {}) {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentsForInvoice', 'invoiceId', invoiceId);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/payments`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }
            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Modify custom fields to invoice
         * @param {Array<CustomField>} body
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoiceCustomFields: (body_9, invoiceId_15, xKillbillCreatedBy_15, xKillbillReason_15, xKillbillComment_15, ...args_29) => __awaiter(this, [body_9, invoiceId_15, xKillbillCreatedBy_15, xKillbillReason_15, xKillbillComment_15, ...args_29], void 0, function* (body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('modifyInvoiceCustomFields', 'body', body);
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('modifyInvoiceCustomFields', 'invoiceId', invoiceId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('modifyInvoiceCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/customFields`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Search invoices
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInvoices: (searchKey_1, offset_2, limit_2, audit_9, ...args_30) => __awaiter(this, [searchKey_1, offset_2, limit_2, audit_9, ...args_30], void 0, function* (searchKey, offset, limit, audit, options = {}) {
            // verify required parameter 'searchKey' is not null or undefined
            (0, common_1.assertParamExists)('searchInvoices', 'searchKey', searchKey);
            const localVarPath = `/1.0/kb/invoices/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Upload the catalog translation for the tenant
         * @param {string} body
         * @param {string} locale
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [deleteIfExists]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCatalogTranslation: (body_10, locale_4, xKillbillCreatedBy_16, deleteIfExists_1, xKillbillReason_16, xKillbillComment_16, ...args_31) => __awaiter(this, [body_10, locale_4, xKillbillCreatedBy_16, deleteIfExists_1, xKillbillReason_16, xKillbillComment_16, ...args_31], void 0, function* (body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('uploadCatalogTranslation', 'body', body);
            // verify required parameter 'locale' is not null or undefined
            (0, common_1.assertParamExists)('uploadCatalogTranslation', 'locale', locale);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('uploadCatalogTranslation', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/catalogTranslation/{locale}`
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (deleteIfExists !== undefined) {
                localVarQueryParameter['deleteIfExists'] = deleteIfExists;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'text/plain';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Upload the manualPay invoice template for the tenant
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [deleteIfExists]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceMPTemplate: (body_11, xKillbillCreatedBy_17, deleteIfExists_2, xKillbillReason_17, xKillbillComment_17, ...args_32) => __awaiter(this, [body_11, xKillbillCreatedBy_17, deleteIfExists_2, xKillbillReason_17, xKillbillComment_17, ...args_32], void 0, function* (body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('uploadInvoiceMPTemplate', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('uploadInvoiceMPTemplate', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/manualPayTemplate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (deleteIfExists !== undefined) {
                localVarQueryParameter['deleteIfExists'] = deleteIfExists;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'text/html';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Upload the invoice template for the tenant
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [deleteIfExists]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceTemplate: (body_12, xKillbillCreatedBy_18, deleteIfExists_3, xKillbillReason_18, xKillbillComment_18, ...args_33) => __awaiter(this, [body_12, xKillbillCreatedBy_18, deleteIfExists_3, xKillbillReason_18, xKillbillComment_18, ...args_33], void 0, function* (body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('uploadInvoiceTemplate', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('uploadInvoiceTemplate', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (deleteIfExists !== undefined) {
                localVarQueryParameter['deleteIfExists'] = deleteIfExists;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'text/html';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Upload the invoice translation for the tenant
         * @param {string} body
         * @param {string} locale
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [deleteIfExists]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceTranslation: (body_13, locale_5, xKillbillCreatedBy_19, deleteIfExists_4, xKillbillReason_19, xKillbillComment_19, ...args_34) => __awaiter(this, [body_13, locale_5, xKillbillCreatedBy_19, deleteIfExists_4, xKillbillReason_19, xKillbillComment_19, ...args_34], void 0, function* (body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('uploadInvoiceTranslation', 'body', body);
            // verify required parameter 'locale' is not null or undefined
            (0, common_1.assertParamExists)('uploadInvoiceTranslation', 'locale', locale);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('uploadInvoiceTranslation', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/translation/{locale}`
                .replace(`{${"locale"}}`, encodeURIComponent(String(locale)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (deleteIfExists !== undefined) {
                localVarQueryParameter['deleteIfExists'] = deleteIfExists;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'text/plain';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Perform the action of voiding an invoice
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidInvoice: (invoiceId_16, xKillbillCreatedBy_20, xKillbillReason_20, xKillbillComment_20, ...args_35) => __awaiter(this, [invoiceId_16, xKillbillCreatedBy_20, xKillbillReason_20, xKillbillComment_20, ...args_35], void 0, function* (invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'invoiceId' is not null or undefined
            (0, common_1.assertParamExists)('voidInvoice', 'invoiceId', invoiceId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('voidInvoice', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoices/{invoiceId}/voidInvoice`
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.InvoiceApiAxiosParamCreator = InvoiceApiAxiosParamCreator;
/**
 * InvoiceApi - functional programming interface
 * @export
 */
const InvoiceApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.InvoiceApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Adjust an invoice item
         * @param {InvoiceItem} body
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustInvoiceItem(body, invoiceId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.adjustInvoiceItem(body, invoiceId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Perform the invoice status transition from DRAFT to COMMITTED
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.commitInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Create external charge(s)
         * @param {Array<InvoiceItem>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {boolean} [autoCommit]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalCharges(body, accountId, xKillbillCreatedBy, requestedDate, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createExternalCharges(body, accountId, xKillbillCreatedBy, requestedDate, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Trigger an invoice generation
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [targetDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFutureInvoice(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createFutureInvoice(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Trigger an invoice generation
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [targetDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFutureInvoiceGroup(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createFutureInvoiceGroup(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Trigger a payment for invoice
         * @param {InvoicePayment} body
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [externalPayment]
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstantPayment(body, invoiceId, xKillbillCreatedBy, externalPayment, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createInstantPayment(body, invoiceId, xKillbillCreatedBy, externalPayment, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add custom fields to invoice
         * @param {Array<CustomField>} body
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add tags to invoice
         * @param {Array<string>} body
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceTags(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createInvoiceTags(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Create a migration invoice
         * @param {Array<InvoiceItem>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [targetDate]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMigrationInvoice(body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createMigrationInvoice(body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Create tax items
         * @param {Array<InvoiceItem>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [autoCommit]
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaxItems(body, accountId, xKillbillCreatedBy, autoCommit, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTaxItems(body, accountId, xKillbillCreatedBy, autoCommit, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Delete a CBA item
         * @param {string} invoiceId
         * @param {string} invoiceItemId
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCBA(invoiceId, invoiceItemId, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteCBA(invoiceId, invoiceItemId, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove custom fields from invoice
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceCustomFields(invoiceId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteInvoiceCustomFields(invoiceId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove tags from invoice
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceTags(invoiceId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteInvoiceTags(invoiceId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Generate a dryRun invoice
         * @param {InvoiceDryRun} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [targetDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateDryRunInvoice(body, accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.generateDryRunInvoice(body, accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieves the catalog translation for the tenant
         * @param {string} locale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogTranslation(locale, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCatalogTranslation(locale, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve an invoice by id
         * @param {string} invoiceId
         * @param {boolean} [withChildrenItems]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(invoiceId, withChildrenItems, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoice(invoiceId, withChildrenItems, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Render an invoice as HTML
         * @param {string} invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAsHTML(invoiceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoiceAsHTML(invoiceId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve invoice audit logs with history by id
         * @param {string} invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAuditLogsWithHistory(invoiceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoiceAuditLogsWithHistory(invoiceId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve an invoice by invoice item id
         * @param {string} itemId
         * @param {boolean} [withChildrenItems]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceByItemId(itemId, withChildrenItems, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoiceByItemId(itemId, withChildrenItems, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve an invoice by number
         * @param {number} invoiceNumber
         * @param {boolean} [withChildrenItems]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceByNumber(invoiceNumber, withChildrenItems, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoiceByNumber(invoiceNumber, withChildrenItems, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve invoice custom fields
         * @param {string} invoiceId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceCustomFields(invoiceId, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoiceCustomFields(invoiceId, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieves the manualPay invoice template for the tenant
         * @param {string} locale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceMPTemplate(locale, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoiceMPTemplate(locale, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve invoice tags
         * @param {string} invoiceId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTags(invoiceId, includedDeleted, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoiceTags(invoiceId, includedDeleted, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieves the invoice template for the tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTemplate(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoiceTemplate(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieves the invoice translation for the tenant
         * @param {string} locale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTranslation(locale, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoiceTranslation(locale, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List invoices
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices(offset, limit, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoices(offset, limit, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a set of invoices by group id
         * @param {string} groupId
         * @param {string} accountId
         * @param {boolean} [withChildrenItems]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesGroup(groupId, accountId, withChildrenItems, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoicesGroup(groupId, accountId, withChildrenItems, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve payments associated with an invoice
         * @param {string} invoiceId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForInvoice(invoiceId, withPluginInfo, withAttempts, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentsForInvoice(invoiceId, withPluginInfo, withAttempts, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Modify custom fields to invoice
         * @param {Array<CustomField>} body
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.modifyInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Search invoices
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInvoices(searchKey, offset, limit, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchInvoices(searchKey, offset, limit, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Upload the catalog translation for the tenant
         * @param {string} body
         * @param {string} locale
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [deleteIfExists]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCatalogTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadCatalogTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Upload the manualPay invoice template for the tenant
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [deleteIfExists]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceMPTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadInvoiceMPTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Upload the invoice template for the tenant
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [deleteIfExists]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadInvoiceTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Upload the invoice translation for the tenant
         * @param {string} body
         * @param {string} locale
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [deleteIfExists]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadInvoiceTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Perform the action of voiding an invoice
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.voidInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.InvoiceApiFp = InvoiceApiFp;
/**
 * InvoiceApi - factory interface
 * @export
 */
const InvoiceApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.InvoiceApiFp)(configuration);
    return {
        /**
         *
         * @summary Adjust an invoice item
         * @param {InvoiceItem} body
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        adjustInvoiceItem(body, invoiceId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.adjustInvoiceItem(body, invoiceId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Perform the invoice status transition from DRAFT to COMMITTED
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        commitInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.commitInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create external charge(s)
         * @param {Array<InvoiceItem>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {boolean} [autoCommit]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createExternalCharges(body, accountId, xKillbillCreatedBy, requestedDate, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createExternalCharges(body, accountId, xKillbillCreatedBy, requestedDate, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Trigger an invoice generation
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [targetDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFutureInvoice(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createFutureInvoice(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Trigger an invoice generation
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [targetDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFutureInvoiceGroup(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createFutureInvoiceGroup(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Trigger a payment for invoice
         * @param {InvoicePayment} body
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [externalPayment]
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInstantPayment(body, invoiceId, xKillbillCreatedBy, externalPayment, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createInstantPayment(body, invoiceId, xKillbillCreatedBy, externalPayment, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add custom fields to invoice
         * @param {Array<CustomField>} body
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add tags to invoice
         * @param {Array<string>} body
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceTags(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createInvoiceTags(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a migration invoice
         * @param {Array<InvoiceItem>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [targetDate]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMigrationInvoice(body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createMigrationInvoice(body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create tax items
         * @param {Array<InvoiceItem>} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [autoCommit]
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTaxItems(body, accountId, xKillbillCreatedBy, autoCommit, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createTaxItems(body, accountId, xKillbillCreatedBy, autoCommit, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a CBA item
         * @param {string} invoiceId
         * @param {string} invoiceItemId
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCBA(invoiceId, invoiceItemId, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteCBA(invoiceId, invoiceItemId, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove custom fields from invoice
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceCustomFields(invoiceId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteInvoiceCustomFields(invoiceId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove tags from invoice
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceTags(invoiceId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteInvoiceTags(invoiceId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Generate a dryRun invoice
         * @param {InvoiceDryRun} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [targetDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateDryRunInvoice(body, accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.generateDryRunInvoice(body, accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieves the catalog translation for the tenant
         * @param {string} locale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCatalogTranslation(locale, options) {
            return localVarFp.getCatalogTranslation(locale, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve an invoice by id
         * @param {string} invoiceId
         * @param {boolean} [withChildrenItems]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoice(invoiceId, withChildrenItems, audit, options) {
            return localVarFp.getInvoice(invoiceId, withChildrenItems, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Render an invoice as HTML
         * @param {string} invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAsHTML(invoiceId, options) {
            return localVarFp.getInvoiceAsHTML(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve invoice audit logs with history by id
         * @param {string} invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAuditLogsWithHistory(invoiceId, options) {
            return localVarFp.getInvoiceAuditLogsWithHistory(invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve an invoice by invoice item id
         * @param {string} itemId
         * @param {boolean} [withChildrenItems]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceByItemId(itemId, withChildrenItems, audit, options) {
            return localVarFp.getInvoiceByItemId(itemId, withChildrenItems, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve an invoice by number
         * @param {number} invoiceNumber
         * @param {boolean} [withChildrenItems]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceByNumber(invoiceNumber, withChildrenItems, audit, options) {
            return localVarFp.getInvoiceByNumber(invoiceNumber, withChildrenItems, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve invoice custom fields
         * @param {string} invoiceId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceCustomFields(invoiceId, audit, options) {
            return localVarFp.getInvoiceCustomFields(invoiceId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieves the manualPay invoice template for the tenant
         * @param {string} locale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceMPTemplate(locale, options) {
            return localVarFp.getInvoiceMPTemplate(locale, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve invoice tags
         * @param {string} invoiceId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTags(invoiceId, includedDeleted, audit, options) {
            return localVarFp.getInvoiceTags(invoiceId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieves the invoice template for the tenant
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTemplate(options) {
            return localVarFp.getInvoiceTemplate(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieves the invoice translation for the tenant
         * @param {string} locale
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceTranslation(locale, options) {
            return localVarFp.getInvoiceTranslation(locale, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List invoices
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices(offset, limit, audit, options) {
            return localVarFp.getInvoices(offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a set of invoices by group id
         * @param {string} groupId
         * @param {string} accountId
         * @param {boolean} [withChildrenItems]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicesGroup(groupId, accountId, withChildrenItems, audit, options) {
            return localVarFp.getInvoicesGroup(groupId, accountId, withChildrenItems, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve payments associated with an invoice
         * @param {string} invoiceId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentsForInvoice(invoiceId, withPluginInfo, withAttempts, audit, options) {
            return localVarFp.getPaymentsForInvoice(invoiceId, withPluginInfo, withAttempts, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Modify custom fields to invoice
         * @param {Array<CustomField>} body
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.modifyInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Search invoices
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchInvoices(searchKey, offset, limit, audit, options) {
            return localVarFp.searchInvoices(searchKey, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload the catalog translation for the tenant
         * @param {string} body
         * @param {string} locale
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [deleteIfExists]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadCatalogTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options) {
            return localVarFp.uploadCatalogTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload the manualPay invoice template for the tenant
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [deleteIfExists]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceMPTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options) {
            return localVarFp.uploadInvoiceMPTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload the invoice template for the tenant
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [deleteIfExists]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options) {
            return localVarFp.uploadInvoiceTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload the invoice translation for the tenant
         * @param {string} body
         * @param {string} locale
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [deleteIfExists]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadInvoiceTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options) {
            return localVarFp.uploadInvoiceTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Perform the action of voiding an invoice
         * @param {string} invoiceId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.voidInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.InvoiceApiFactory = InvoiceApiFactory;
/**
 * InvoiceApi - object-oriented interface
 * @export
 * @class InvoiceApi
 * @extends {BaseAPI}
 */
class InvoiceApi extends base_1.BaseAPI {
    /**
     *
     * @summary Adjust an invoice item
     * @param {InvoiceItem} body
     * @param {string} invoiceId
     * @param {string} xKillbillCreatedBy
     * @param {string} [requestedDate]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    adjustInvoiceItem(body, invoiceId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).adjustInvoiceItem(body, invoiceId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Perform the invoice status transition from DRAFT to COMMITTED
     * @param {string} invoiceId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    commitInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).commitInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create external charge(s)
     * @param {Array<InvoiceItem>} body
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [requestedDate]
     * @param {boolean} [autoCommit]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    createExternalCharges(body, accountId, xKillbillCreatedBy, requestedDate, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).createExternalCharges(body, accountId, xKillbillCreatedBy, requestedDate, autoCommit, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Trigger an invoice generation
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [targetDate]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    createFutureInvoice(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).createFutureInvoice(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Trigger an invoice generation
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [targetDate]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    createFutureInvoiceGroup(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).createFutureInvoiceGroup(accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Trigger a payment for invoice
     * @param {InvoicePayment} body
     * @param {string} invoiceId
     * @param {string} xKillbillCreatedBy
     * @param {boolean} [externalPayment]
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    createInstantPayment(body, invoiceId, xKillbillCreatedBy, externalPayment, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).createInstantPayment(body, invoiceId, xKillbillCreatedBy, externalPayment, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add custom fields to invoice
     * @param {Array<CustomField>} body
     * @param {string} invoiceId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    createInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).createInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add tags to invoice
     * @param {Array<string>} body
     * @param {string} invoiceId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    createInvoiceTags(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).createInvoiceTags(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a migration invoice
     * @param {Array<InvoiceItem>} body
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [targetDate]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    createMigrationInvoice(body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).createMigrationInvoice(body, accountId, xKillbillCreatedBy, targetDate, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create tax items
     * @param {Array<InvoiceItem>} body
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {boolean} [autoCommit]
     * @param {string} [requestedDate]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    createTaxItems(body, accountId, xKillbillCreatedBy, autoCommit, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).createTaxItems(body, accountId, xKillbillCreatedBy, autoCommit, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a CBA item
     * @param {string} invoiceId
     * @param {string} invoiceItemId
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    deleteCBA(invoiceId, invoiceItemId, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).deleteCBA(invoiceId, invoiceItemId, accountId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove custom fields from invoice
     * @param {string} invoiceId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [customField]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    deleteInvoiceCustomFields(invoiceId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).deleteInvoiceCustomFields(invoiceId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove tags from invoice
     * @param {string} invoiceId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [tagDef]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    deleteInvoiceTags(invoiceId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).deleteInvoiceTags(invoiceId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Generate a dryRun invoice
     * @param {InvoiceDryRun} body
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [targetDate]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    generateDryRunInvoice(body, accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).generateDryRunInvoice(body, accountId, xKillbillCreatedBy, targetDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieves the catalog translation for the tenant
     * @param {string} locale
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    getCatalogTranslation(locale, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).getCatalogTranslation(locale, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve an invoice by id
     * @param {string} invoiceId
     * @param {boolean} [withChildrenItems]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    getInvoice(invoiceId, withChildrenItems, audit, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).getInvoice(invoiceId, withChildrenItems, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Render an invoice as HTML
     * @param {string} invoiceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    getInvoiceAsHTML(invoiceId, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).getInvoiceAsHTML(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve invoice audit logs with history by id
     * @param {string} invoiceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    getInvoiceAuditLogsWithHistory(invoiceId, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).getInvoiceAuditLogsWithHistory(invoiceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve an invoice by invoice item id
     * @param {string} itemId
     * @param {boolean} [withChildrenItems]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    getInvoiceByItemId(itemId, withChildrenItems, audit, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).getInvoiceByItemId(itemId, withChildrenItems, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve an invoice by number
     * @param {number} invoiceNumber
     * @param {boolean} [withChildrenItems]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    getInvoiceByNumber(invoiceNumber, withChildrenItems, audit, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).getInvoiceByNumber(invoiceNumber, withChildrenItems, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve invoice custom fields
     * @param {string} invoiceId
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    getInvoiceCustomFields(invoiceId, audit, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).getInvoiceCustomFields(invoiceId, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieves the manualPay invoice template for the tenant
     * @param {string} locale
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    getInvoiceMPTemplate(locale, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).getInvoiceMPTemplate(locale, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve invoice tags
     * @param {string} invoiceId
     * @param {boolean} [includedDeleted]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    getInvoiceTags(invoiceId, includedDeleted, audit, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).getInvoiceTags(invoiceId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieves the invoice template for the tenant
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    getInvoiceTemplate(options) {
        return (0, exports.InvoiceApiFp)(this.configuration).getInvoiceTemplate(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieves the invoice translation for the tenant
     * @param {string} locale
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    getInvoiceTranslation(locale, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).getInvoiceTranslation(locale, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List invoices
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    getInvoices(offset, limit, audit, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).getInvoices(offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a set of invoices by group id
     * @param {string} groupId
     * @param {string} accountId
     * @param {boolean} [withChildrenItems]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    getInvoicesGroup(groupId, accountId, withChildrenItems, audit, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).getInvoicesGroup(groupId, accountId, withChildrenItems, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve payments associated with an invoice
     * @param {string} invoiceId
     * @param {boolean} [withPluginInfo]
     * @param {boolean} [withAttempts]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    getPaymentsForInvoice(invoiceId, withPluginInfo, withAttempts, audit, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).getPaymentsForInvoice(invoiceId, withPluginInfo, withAttempts, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Modify custom fields to invoice
     * @param {Array<CustomField>} body
     * @param {string} invoiceId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    modifyInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).modifyInvoiceCustomFields(body, invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Search invoices
     * @param {string} searchKey
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    searchInvoices(searchKey, offset, limit, audit, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).searchInvoices(searchKey, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Upload the catalog translation for the tenant
     * @param {string} body
     * @param {string} locale
     * @param {string} xKillbillCreatedBy
     * @param {boolean} [deleteIfExists]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    uploadCatalogTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).uploadCatalogTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Upload the manualPay invoice template for the tenant
     * @param {string} body
     * @param {string} xKillbillCreatedBy
     * @param {boolean} [deleteIfExists]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    uploadInvoiceMPTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).uploadInvoiceMPTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Upload the invoice template for the tenant
     * @param {string} body
     * @param {string} xKillbillCreatedBy
     * @param {boolean} [deleteIfExists]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    uploadInvoiceTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).uploadInvoiceTemplate(body, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Upload the invoice translation for the tenant
     * @param {string} body
     * @param {string} locale
     * @param {string} xKillbillCreatedBy
     * @param {boolean} [deleteIfExists]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    uploadInvoiceTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).uploadInvoiceTranslation(body, locale, xKillbillCreatedBy, deleteIfExists, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Perform the action of voiding an invoice
     * @param {string} invoiceId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    voidInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceApiFp)(this.configuration).voidInvoice(invoiceId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InvoiceApi = InvoiceApi;
/**
 * InvoiceItemApi - axios parameter creator
 * @export
 */
const InvoiceItemApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Add custom fields to invoice item
         * @param {Array<CustomField>} body
         * @param {string} invoiceItemId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItemCustomFields: (body_1, invoiceItemId_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [body_1, invoiceItemId_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createInvoiceItemCustomFields', 'body', body);
            // verify required parameter 'invoiceItemId' is not null or undefined
            (0, common_1.assertParamExists)('createInvoiceItemCustomFields', 'invoiceItemId', invoiceItemId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createInvoiceItemCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/customFields`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add tags to invoice item
         * @param {Array<string>} body
         * @param {string} invoiceItemId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItemTags: (body_2, invoiceItemId_2, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2) => __awaiter(this, [body_2, invoiceItemId_2, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2], void 0, function* (body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createInvoiceItemTags', 'body', body);
            // verify required parameter 'invoiceItemId' is not null or undefined
            (0, common_1.assertParamExists)('createInvoiceItemTags', 'invoiceItemId', invoiceItemId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createInvoiceItemTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/tags`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove custom fields from invoice item
         * @param {string} invoiceItemId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItemCustomFields: (invoiceItemId_3, xKillbillCreatedBy_3, customField_1, xKillbillReason_3, xKillbillComment_3, ...args_3) => __awaiter(this, [invoiceItemId_3, xKillbillCreatedBy_3, customField_1, xKillbillReason_3, xKillbillComment_3, ...args_3], void 0, function* (invoiceItemId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'invoiceItemId' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoiceItemCustomFields', 'invoiceItemId', invoiceItemId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoiceItemCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/customFields`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove tags from invoice item
         * @param {string} invoiceItemId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItemTags: (invoiceItemId_4, xKillbillCreatedBy_4, tagDef_1, xKillbillReason_4, xKillbillComment_4, ...args_4) => __awaiter(this, [invoiceItemId_4, xKillbillCreatedBy_4, tagDef_1, xKillbillReason_4, xKillbillComment_4, ...args_4], void 0, function* (invoiceItemId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'invoiceItemId' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoiceItemTags', 'invoiceItemId', invoiceItemId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoiceItemTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/tags`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve invoice item audit logs with history by id
         * @param {string} invoiceItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemAuditLogsWithHistory: (invoiceItemId_5, ...args_5) => __awaiter(this, [invoiceItemId_5, ...args_5], void 0, function* (invoiceItemId, options = {}) {
            // verify required parameter 'invoiceItemId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoiceItemAuditLogsWithHistory', 'invoiceItemId', invoiceItemId);
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/auditLogsWithHistory`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve invoice item custom fields
         * @param {string} invoiceItemId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemCustomFields: (invoiceItemId_6, audit_1, ...args_6) => __awaiter(this, [invoiceItemId_6, audit_1, ...args_6], void 0, function* (invoiceItemId, audit, options = {}) {
            // verify required parameter 'invoiceItemId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoiceItemCustomFields', 'invoiceItemId', invoiceItemId);
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/customFields`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve invoice item tags
         * @param {string} invoiceItemId
         * @param {string} accountId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemTags: (invoiceItemId_7, accountId_1, includedDeleted_1, audit_2, ...args_7) => __awaiter(this, [invoiceItemId_7, accountId_1, includedDeleted_1, audit_2, ...args_7], void 0, function* (invoiceItemId, accountId, includedDeleted, audit, options = {}) {
            // verify required parameter 'invoiceItemId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoiceItemTags', 'invoiceItemId', invoiceItemId);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoiceItemTags', 'accountId', accountId);
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/tags`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (accountId !== undefined) {
                localVarQueryParameter['accountId'] = accountId;
            }
            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Modify custom fields to invoice item
         * @param {Array<CustomField>} body
         * @param {string} invoiceItemId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoiceItemCustomFields: (body_3, invoiceItemId_8, xKillbillCreatedBy_5, xKillbillReason_5, xKillbillComment_5, ...args_8) => __awaiter(this, [body_3, invoiceItemId_8, xKillbillCreatedBy_5, xKillbillReason_5, xKillbillComment_5, ...args_8], void 0, function* (body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('modifyInvoiceItemCustomFields', 'body', body);
            // verify required parameter 'invoiceItemId' is not null or undefined
            (0, common_1.assertParamExists)('modifyInvoiceItemCustomFields', 'invoiceItemId', invoiceItemId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('modifyInvoiceItemCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoiceItems/{invoiceItemId}/customFields`
                .replace(`{${"invoiceItemId"}}`, encodeURIComponent(String(invoiceItemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.InvoiceItemApiAxiosParamCreator = InvoiceItemApiAxiosParamCreator;
/**
 * InvoiceItemApi - functional programming interface
 * @export
 */
const InvoiceItemApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.InvoiceItemApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Add custom fields to invoice item
         * @param {Array<CustomField>} body
         * @param {string} invoiceItemId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add tags to invoice item
         * @param {Array<string>} body
         * @param {string} invoiceItemId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItemTags(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createInvoiceItemTags(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove custom fields from invoice item
         * @param {string} invoiceItemId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItemCustomFields(invoiceItemId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteInvoiceItemCustomFields(invoiceItemId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove tags from invoice item
         * @param {string} invoiceItemId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItemTags(invoiceItemId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteInvoiceItemTags(invoiceItemId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve invoice item audit logs with history by id
         * @param {string} invoiceItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemAuditLogsWithHistory(invoiceItemId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoiceItemAuditLogsWithHistory(invoiceItemId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve invoice item custom fields
         * @param {string} invoiceItemId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemCustomFields(invoiceItemId, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoiceItemCustomFields(invoiceItemId, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve invoice item tags
         * @param {string} invoiceItemId
         * @param {string} accountId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemTags(invoiceItemId, accountId, includedDeleted, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoiceItemTags(invoiceItemId, accountId, includedDeleted, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Modify custom fields to invoice item
         * @param {Array<CustomField>} body
         * @param {string} invoiceItemId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.modifyInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.InvoiceItemApiFp = InvoiceItemApiFp;
/**
 * InvoiceItemApi - factory interface
 * @export
 */
const InvoiceItemApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.InvoiceItemApiFp)(configuration);
    return {
        /**
         *
         * @summary Add custom fields to invoice item
         * @param {Array<CustomField>} body
         * @param {string} invoiceItemId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add tags to invoice item
         * @param {Array<string>} body
         * @param {string} invoiceItemId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceItemTags(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createInvoiceItemTags(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove custom fields from invoice item
         * @param {string} invoiceItemId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItemCustomFields(invoiceItemId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteInvoiceItemCustomFields(invoiceItemId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove tags from invoice item
         * @param {string} invoiceItemId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceItemTags(invoiceItemId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteInvoiceItemTags(invoiceItemId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve invoice item audit logs with history by id
         * @param {string} invoiceItemId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemAuditLogsWithHistory(invoiceItemId, options) {
            return localVarFp.getInvoiceItemAuditLogsWithHistory(invoiceItemId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve invoice item custom fields
         * @param {string} invoiceItemId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemCustomFields(invoiceItemId, audit, options) {
            return localVarFp.getInvoiceItemCustomFields(invoiceItemId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve invoice item tags
         * @param {string} invoiceItemId
         * @param {string} accountId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceItemTags(invoiceItemId, accountId, includedDeleted, audit, options) {
            return localVarFp.getInvoiceItemTags(invoiceItemId, accountId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Modify custom fields to invoice item
         * @param {Array<CustomField>} body
         * @param {string} invoiceItemId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.modifyInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.InvoiceItemApiFactory = InvoiceItemApiFactory;
/**
 * InvoiceItemApi - object-oriented interface
 * @export
 * @class InvoiceItemApi
 * @extends {BaseAPI}
 */
class InvoiceItemApi extends base_1.BaseAPI {
    /**
     *
     * @summary Add custom fields to invoice item
     * @param {Array<CustomField>} body
     * @param {string} invoiceItemId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    createInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceItemApiFp)(this.configuration).createInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add tags to invoice item
     * @param {Array<string>} body
     * @param {string} invoiceItemId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    createInvoiceItemTags(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceItemApiFp)(this.configuration).createInvoiceItemTags(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove custom fields from invoice item
     * @param {string} invoiceItemId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [customField]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    deleteInvoiceItemCustomFields(invoiceItemId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceItemApiFp)(this.configuration).deleteInvoiceItemCustomFields(invoiceItemId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove tags from invoice item
     * @param {string} invoiceItemId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [tagDef]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    deleteInvoiceItemTags(invoiceItemId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceItemApiFp)(this.configuration).deleteInvoiceItemTags(invoiceItemId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve invoice item audit logs with history by id
     * @param {string} invoiceItemId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    getInvoiceItemAuditLogsWithHistory(invoiceItemId, options) {
        return (0, exports.InvoiceItemApiFp)(this.configuration).getInvoiceItemAuditLogsWithHistory(invoiceItemId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve invoice item custom fields
     * @param {string} invoiceItemId
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    getInvoiceItemCustomFields(invoiceItemId, audit, options) {
        return (0, exports.InvoiceItemApiFp)(this.configuration).getInvoiceItemCustomFields(invoiceItemId, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve invoice item tags
     * @param {string} invoiceItemId
     * @param {string} accountId
     * @param {boolean} [includedDeleted]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    getInvoiceItemTags(invoiceItemId, accountId, includedDeleted, audit, options) {
        return (0, exports.InvoiceItemApiFp)(this.configuration).getInvoiceItemTags(invoiceItemId, accountId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Modify custom fields to invoice item
     * @param {Array<CustomField>} body
     * @param {string} invoiceItemId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceItemApi
     */
    modifyInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoiceItemApiFp)(this.configuration).modifyInvoiceItemCustomFields(body, invoiceItemId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InvoiceItemApi = InvoiceItemApi;
/**
 * InvoicePaymentApi - axios parameter creator
 * @export
 */
const InvoicePaymentApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeInvoicePaymentTransaction: (body_1, paymentId_1, xKillbillCreatedBy_1, controlPluginName_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [body_1, paymentId_1, xKillbillCreatedBy_1, controlPluginName_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('completeInvoicePaymentTransaction', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('completeInvoicePaymentTransaction', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('completeInvoicePaymentTransaction', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Record a chargeback
         * @param {InvoicePaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChargeback: (body_2, paymentId_2, xKillbillCreatedBy_2, pluginProperty_2, xKillbillReason_2, xKillbillComment_2, ...args_2) => __awaiter(this, [body_2, paymentId_2, xKillbillCreatedBy_2, pluginProperty_2, xKillbillReason_2, xKillbillComment_2, ...args_2], void 0, function* (body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createChargeback', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('createChargeback', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createChargeback', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/chargebacks`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Record a chargebackReversal
         * @param {InvoicePaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChargebackReversal: (body_3, paymentId_3, xKillbillCreatedBy_3, pluginProperty_3, xKillbillReason_3, xKillbillComment_3, ...args_3) => __awaiter(this, [body_3, paymentId_3, xKillbillCreatedBy_3, pluginProperty_3, xKillbillReason_3, xKillbillComment_3, ...args_3], void 0, function* (body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createChargebackReversal', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('createChargebackReversal', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createChargebackReversal', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/chargebackReversals`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoicePaymentCustomFields: (body_4, paymentId_4, xKillbillCreatedBy_4, xKillbillReason_4, xKillbillComment_4, ...args_4) => __awaiter(this, [body_4, paymentId_4, xKillbillCreatedBy_4, xKillbillReason_4, xKillbillComment_4, ...args_4], void 0, function* (body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createInvoicePaymentCustomFields', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('createInvoicePaymentCustomFields', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createInvoicePaymentCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add tags to payment
         * @param {Array<string>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoicePaymentTags: (body_5, paymentId_5, xKillbillCreatedBy_5, xKillbillReason_5, xKillbillComment_5, ...args_5) => __awaiter(this, [body_5, paymentId_5, xKillbillCreatedBy_5, xKillbillReason_5, xKillbillComment_5, ...args_5], void 0, function* (body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createInvoicePaymentTags', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('createInvoicePaymentTags', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createInvoicePaymentTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Refund a payment, and adjust the invoice if needed
         * @param {InvoicePaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [externalPayment]
         * @param {string} [paymentMethodId]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefundWithAdjustments: (body_6, paymentId_6, xKillbillCreatedBy_6, externalPayment_1, paymentMethodId_1, pluginProperty_4, xKillbillReason_6, xKillbillComment_6, ...args_6) => __awaiter(this, [body_6, paymentId_6, xKillbillCreatedBy_6, externalPayment_1, paymentMethodId_1, pluginProperty_4, xKillbillReason_6, xKillbillComment_6, ...args_6], void 0, function* (body, paymentId, xKillbillCreatedBy, externalPayment, paymentMethodId, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createRefundWithAdjustments', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('createRefundWithAdjustments', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createRefundWithAdjustments', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/refunds`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (externalPayment !== undefined) {
                localVarQueryParameter['externalPayment'] = externalPayment;
            }
            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove custom fields from payment
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePaymentCustomFields: (paymentId_7, xKillbillCreatedBy_7, customField_1, xKillbillReason_7, xKillbillComment_7, ...args_7) => __awaiter(this, [paymentId_7, xKillbillCreatedBy_7, customField_1, xKillbillReason_7, xKillbillComment_7, ...args_7], void 0, function* (paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoicePaymentCustomFields', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoicePaymentCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove tags from payment
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePaymentTags: (paymentId_8, xKillbillCreatedBy_8, tagDef_1, xKillbillReason_8, xKillbillComment_8, ...args_8) => __awaiter(this, [paymentId_8, xKillbillCreatedBy_8, tagDef_1, xKillbillReason_8, xKillbillComment_8, ...args_8], void 0, function* (paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoicePaymentTags', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteInvoicePaymentTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a payment by id
         * @param {string} paymentId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePayment: (paymentId_9, withPluginInfo_1, withAttempts_1, pluginProperty_5, audit_1, ...args_9) => __awaiter(this, [paymentId_9, withPluginInfo_1, withAttempts_1, pluginProperty_5, audit_1, ...args_9], void 0, function* (paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options = {}) {
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoicePayment', 'paymentId', paymentId);
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }
            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve invoice payment audit logs with history by id
         * @param {string} invoicePaymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentAuditLogsWithHistory: (invoicePaymentId_1, ...args_10) => __awaiter(this, [invoicePaymentId_1, ...args_10], void 0, function* (invoicePaymentId, options = {}) {
            // verify required parameter 'invoicePaymentId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoicePaymentAuditLogsWithHistory', 'invoicePaymentId', invoicePaymentId);
            const localVarPath = `/1.0/kb/invoicePayments/{invoicePaymentId}/auditLogsWithHistory`
                .replace(`{${"invoicePaymentId"}}`, encodeURIComponent(String(invoicePaymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve payment custom fields
         * @param {string} paymentId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentCustomFields: (paymentId_10, audit_2, ...args_11) => __awaiter(this, [paymentId_10, audit_2, ...args_11], void 0, function* (paymentId, audit, options = {}) {
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoicePaymentCustomFields', 'paymentId', paymentId);
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve payment tags
         * @param {string} paymentId
         * @param {boolean} [includedDeleted]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentTags: (paymentId_11, includedDeleted_1, pluginProperty_6, audit_3, ...args_12) => __awaiter(this, [paymentId_11, includedDeleted_1, pluginProperty_6, audit_3, ...args_12], void 0, function* (paymentId, includedDeleted, pluginProperty, audit, options = {}) {
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('getInvoicePaymentTags', 'paymentId', paymentId);
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoicePaymentCustomFields: (body_7, paymentId_12, xKillbillCreatedBy_9, xKillbillReason_9, xKillbillComment_9, ...args_13) => __awaiter(this, [body_7, paymentId_12, xKillbillCreatedBy_9, xKillbillReason_9, xKillbillComment_9, ...args_13], void 0, function* (body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('modifyInvoicePaymentCustomFields', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('modifyInvoicePaymentCustomFields', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('modifyInvoicePaymentCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/invoicePayments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.InvoicePaymentApiAxiosParamCreator = InvoicePaymentApiAxiosParamCreator;
/**
 * InvoicePaymentApi - functional programming interface
 * @export
 */
const InvoicePaymentApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.InvoicePaymentApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeInvoicePaymentTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.completeInvoicePaymentTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Record a chargeback
         * @param {InvoicePaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChargeback(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createChargeback(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Record a chargebackReversal
         * @param {InvoicePaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChargebackReversal(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createChargebackReversal(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add tags to payment
         * @param {Array<string>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoicePaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createInvoicePaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Refund a payment, and adjust the invoice if needed
         * @param {InvoicePaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [externalPayment]
         * @param {string} [paymentMethodId]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefundWithAdjustments(body, paymentId, xKillbillCreatedBy, externalPayment, paymentMethodId, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createRefundWithAdjustments(body, paymentId, xKillbillCreatedBy, externalPayment, paymentMethodId, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove custom fields from payment
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteInvoicePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove tags from payment
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteInvoicePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a payment by id
         * @param {string} paymentId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoicePayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve invoice payment audit logs with history by id
         * @param {string} invoicePaymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentAuditLogsWithHistory(invoicePaymentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoicePaymentAuditLogsWithHistory(invoicePaymentId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve payment custom fields
         * @param {string} paymentId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentCustomFields(paymentId, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoicePaymentCustomFields(paymentId, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve payment tags
         * @param {string} paymentId
         * @param {boolean} [includedDeleted]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentTags(paymentId, includedDeleted, pluginProperty, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getInvoicePaymentTags(paymentId, includedDeleted, pluginProperty, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.modifyInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.InvoicePaymentApiFp = InvoicePaymentApiFp;
/**
 * InvoicePaymentApi - factory interface
 * @export
 */
const InvoicePaymentApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.InvoicePaymentApiFp)(configuration);
    return {
        /**
         *
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeInvoicePaymentTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.completeInvoicePaymentTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Record a chargeback
         * @param {InvoicePaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChargeback(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createChargeback(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Record a chargebackReversal
         * @param {InvoicePaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createChargebackReversal(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createChargebackReversal(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add tags to payment
         * @param {Array<string>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoicePaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createInvoicePaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Refund a payment, and adjust the invoice if needed
         * @param {InvoicePaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [externalPayment]
         * @param {string} [paymentMethodId]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createRefundWithAdjustments(body, paymentId, xKillbillCreatedBy, externalPayment, paymentMethodId, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createRefundWithAdjustments(body, paymentId, xKillbillCreatedBy, externalPayment, paymentMethodId, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove custom fields from payment
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteInvoicePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove tags from payment
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteInvoicePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a payment by id
         * @param {string} paymentId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options) {
            return localVarFp.getInvoicePayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve invoice payment audit logs with history by id
         * @param {string} invoicePaymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentAuditLogsWithHistory(invoicePaymentId, options) {
            return localVarFp.getInvoicePaymentAuditLogsWithHistory(invoicePaymentId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve payment custom fields
         * @param {string} paymentId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentCustomFields(paymentId, audit, options) {
            return localVarFp.getInvoicePaymentCustomFields(paymentId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve payment tags
         * @param {string} paymentId
         * @param {boolean} [includedDeleted]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePaymentTags(paymentId, includedDeleted, pluginProperty, audit, options) {
            return localVarFp.getInvoicePaymentTags(paymentId, includedDeleted, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.modifyInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.InvoicePaymentApiFactory = InvoicePaymentApiFactory;
/**
 * InvoicePaymentApi - object-oriented interface
 * @export
 * @class InvoicePaymentApi
 * @extends {BaseAPI}
 */
class InvoicePaymentApi extends base_1.BaseAPI {
    /**
     *
     * @summary Complete an existing transaction
     * @param {PaymentTransaction} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    completeInvoicePaymentTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoicePaymentApiFp)(this.configuration).completeInvoicePaymentTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Record a chargeback
     * @param {InvoicePaymentTransaction} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    createChargeback(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoicePaymentApiFp)(this.configuration).createChargeback(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Record a chargebackReversal
     * @param {InvoicePaymentTransaction} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    createChargebackReversal(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoicePaymentApiFp)(this.configuration).createChargebackReversal(body, paymentId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add custom fields to payment
     * @param {Array<CustomField>} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    createInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoicePaymentApiFp)(this.configuration).createInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add tags to payment
     * @param {Array<string>} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    createInvoicePaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoicePaymentApiFp)(this.configuration).createInvoicePaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Refund a payment, and adjust the invoice if needed
     * @param {InvoicePaymentTransaction} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {boolean} [externalPayment]
     * @param {string} [paymentMethodId]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    createRefundWithAdjustments(body, paymentId, xKillbillCreatedBy, externalPayment, paymentMethodId, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoicePaymentApiFp)(this.configuration).createRefundWithAdjustments(body, paymentId, xKillbillCreatedBy, externalPayment, paymentMethodId, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove custom fields from payment
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [customField]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    deleteInvoicePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoicePaymentApiFp)(this.configuration).deleteInvoicePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove tags from payment
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [tagDef]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    deleteInvoicePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoicePaymentApiFp)(this.configuration).deleteInvoicePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a payment by id
     * @param {string} paymentId
     * @param {boolean} [withPluginInfo]
     * @param {boolean} [withAttempts]
     * @param {Array<string>} [pluginProperty]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    getInvoicePayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options) {
        return (0, exports.InvoicePaymentApiFp)(this.configuration).getInvoicePayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve invoice payment audit logs with history by id
     * @param {string} invoicePaymentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    getInvoicePaymentAuditLogsWithHistory(invoicePaymentId, options) {
        return (0, exports.InvoicePaymentApiFp)(this.configuration).getInvoicePaymentAuditLogsWithHistory(invoicePaymentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve payment custom fields
     * @param {string} paymentId
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    getInvoicePaymentCustomFields(paymentId, audit, options) {
        return (0, exports.InvoicePaymentApiFp)(this.configuration).getInvoicePaymentCustomFields(paymentId, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve payment tags
     * @param {string} paymentId
     * @param {boolean} [includedDeleted]
     * @param {Array<string>} [pluginProperty]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    getInvoicePaymentTags(paymentId, includedDeleted, pluginProperty, audit, options) {
        return (0, exports.InvoicePaymentApiFp)(this.configuration).getInvoicePaymentTags(paymentId, includedDeleted, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Modify custom fields to payment
     * @param {Array<CustomField>} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePaymentApi
     */
    modifyInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.InvoicePaymentApiFp)(this.configuration).modifyInvoicePaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.InvoicePaymentApi = InvoicePaymentApi;
/**
 * NodesInfoApi - axios parameter creator
 * @export
 */
const NodesInfoApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Retrieve all the nodes infos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodesInfo: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/1.0/kb/nodesInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Trigger a node command
         * @param {NodeCommand} body
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [localNodeOnly]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerNodeCommand: (body_1, xKillbillCreatedBy_1, localNodeOnly_1, xKillbillReason_1, xKillbillComment_1, ...args_2) => __awaiter(this, [body_1, xKillbillCreatedBy_1, localNodeOnly_1, xKillbillReason_1, xKillbillComment_1, ...args_2], void 0, function* (body, xKillbillCreatedBy, localNodeOnly, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('triggerNodeCommand', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('triggerNodeCommand', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/nodesInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (localNodeOnly !== undefined) {
                localVarQueryParameter['localNodeOnly'] = localNodeOnly;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.NodesInfoApiAxiosParamCreator = NodesInfoApiAxiosParamCreator;
/**
 * NodesInfoApi - functional programming interface
 * @export
 */
const NodesInfoApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.NodesInfoApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve all the nodes infos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodesInfo(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getNodesInfo(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Trigger a node command
         * @param {NodeCommand} body
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [localNodeOnly]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerNodeCommand(body, xKillbillCreatedBy, localNodeOnly, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.triggerNodeCommand(body, xKillbillCreatedBy, localNodeOnly, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.NodesInfoApiFp = NodesInfoApiFp;
/**
 * NodesInfoApi - factory interface
 * @export
 */
const NodesInfoApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.NodesInfoApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve all the nodes infos
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodesInfo(options) {
            return localVarFp.getNodesInfo(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Trigger a node command
         * @param {NodeCommand} body
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [localNodeOnly]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerNodeCommand(body, xKillbillCreatedBy, localNodeOnly, xKillbillReason, xKillbillComment, options) {
            return localVarFp.triggerNodeCommand(body, xKillbillCreatedBy, localNodeOnly, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.NodesInfoApiFactory = NodesInfoApiFactory;
/**
 * NodesInfoApi - object-oriented interface
 * @export
 * @class NodesInfoApi
 * @extends {BaseAPI}
 */
class NodesInfoApi extends base_1.BaseAPI {
    /**
     *
     * @summary Retrieve all the nodes infos
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesInfoApi
     */
    getNodesInfo(options) {
        return (0, exports.NodesInfoApiFp)(this.configuration).getNodesInfo(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Trigger a node command
     * @param {NodeCommand} body
     * @param {string} xKillbillCreatedBy
     * @param {boolean} [localNodeOnly]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesInfoApi
     */
    triggerNodeCommand(body, xKillbillCreatedBy, localNodeOnly, xKillbillReason, xKillbillComment, options) {
        return (0, exports.NodesInfoApiFp)(this.configuration).triggerNodeCommand(body, xKillbillCreatedBy, localNodeOnly, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.NodesInfoApi = NodesInfoApi;
/**
 * OverdueApi - axios parameter creator
 * @export
 */
const OverdueApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Retrieve the overdue config as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueConfigJson: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/1.0/kb/overdue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve the overdue config as XML
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueConfigXml: (...args_2) => __awaiter(this, [...args_2], void 0, function* (options = {}) {
            const localVarPath = `/1.0/kb/overdue/xml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Upload the full overdue config as JSON
         * @param {Overdue} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOverdueConfigJson: (body_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_3) => __awaiter(this, [body_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_3], void 0, function* (body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('uploadOverdueConfigJson', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('uploadOverdueConfigJson', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/overdue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Upload the full overdue config as XML
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOverdueConfigXml: (body_2, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_4) => __awaiter(this, [body_2, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_4], void 0, function* (body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('uploadOverdueConfigXml', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('uploadOverdueConfigXml', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/overdue/xml`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'text/xml';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.OverdueApiAxiosParamCreator = OverdueApiAxiosParamCreator;
/**
 * OverdueApi - functional programming interface
 * @export
 */
const OverdueApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.OverdueApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve the overdue config as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueConfigJson(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOverdueConfigJson(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve the overdue config as XML
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueConfigXml(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getOverdueConfigXml(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Upload the full overdue config as JSON
         * @param {Overdue} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOverdueConfigJson(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadOverdueConfigJson(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Upload the full overdue config as XML
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOverdueConfigXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadOverdueConfigXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.OverdueApiFp = OverdueApiFp;
/**
 * OverdueApi - factory interface
 * @export
 */
const OverdueApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.OverdueApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve the overdue config as JSON
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueConfigJson(options) {
            return localVarFp.getOverdueConfigJson(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve the overdue config as XML
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOverdueConfigXml(options) {
            return localVarFp.getOverdueConfigXml(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload the full overdue config as JSON
         * @param {Overdue} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOverdueConfigJson(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.uploadOverdueConfigJson(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload the full overdue config as XML
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadOverdueConfigXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.uploadOverdueConfigXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.OverdueApiFactory = OverdueApiFactory;
/**
 * OverdueApi - object-oriented interface
 * @export
 * @class OverdueApi
 * @extends {BaseAPI}
 */
class OverdueApi extends base_1.BaseAPI {
    /**
     *
     * @summary Retrieve the overdue config as JSON
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverdueApi
     */
    getOverdueConfigJson(options) {
        return (0, exports.OverdueApiFp)(this.configuration).getOverdueConfigJson(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve the overdue config as XML
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverdueApi
     */
    getOverdueConfigXml(options) {
        return (0, exports.OverdueApiFp)(this.configuration).getOverdueConfigXml(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Upload the full overdue config as JSON
     * @param {Overdue} body
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverdueApi
     */
    uploadOverdueConfigJson(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.OverdueApiFp)(this.configuration).uploadOverdueConfigJson(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Upload the full overdue config as XML
     * @param {string} body
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OverdueApi
     */
    uploadOverdueConfigXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.OverdueApiFp)(this.configuration).uploadOverdueConfigXml(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.OverdueApi = OverdueApi;
/**
 * PaymentApi - axios parameter creator
 * @export
 */
const PaymentApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} transactionExternalKey
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelScheduledPaymentTransactionByExternalKey: (transactionExternalKey_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [transactionExternalKey_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (transactionExternalKey, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'transactionExternalKey' is not null or undefined
            (0, common_1.assertParamExists)('cancelScheduledPaymentTransactionByExternalKey', 'transactionExternalKey', transactionExternalKey);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('cancelScheduledPaymentTransactionByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/cancelScheduledPaymentTransaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (transactionExternalKey !== undefined) {
                localVarQueryParameter['transactionExternalKey'] = transactionExternalKey;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} paymentTransactionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelScheduledPaymentTransactionById: (paymentTransactionId_1, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2) => __awaiter(this, [paymentTransactionId_1, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2], void 0, function* (paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'paymentTransactionId' is not null or undefined
            (0, common_1.assertParamExists)('cancelScheduledPaymentTransactionById', 'paymentTransactionId', paymentTransactionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('cancelScheduledPaymentTransactionById', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/{paymentTransactionId}/cancelScheduledPaymentTransaction`
                .replace(`{${"paymentTransactionId"}}`, encodeURIComponent(String(paymentTransactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureAuthorization: (body_1, paymentId_1, xKillbillCreatedBy_3, controlPluginName_1, pluginProperty_1, xKillbillReason_3, xKillbillComment_3, ...args_3) => __awaiter(this, [body_1, paymentId_1, xKillbillCreatedBy_3, controlPluginName_1, pluginProperty_1, xKillbillReason_3, xKillbillComment_3, ...args_3], void 0, function* (body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('captureAuthorization', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('captureAuthorization', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('captureAuthorization', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureAuthorizationByExternalKey: (body_2, xKillbillCreatedBy_4, controlPluginName_2, pluginProperty_2, xKillbillReason_4, xKillbillComment_4, ...args_4) => __awaiter(this, [body_2, xKillbillCreatedBy_4, controlPluginName_2, pluginProperty_2, xKillbillReason_4, xKillbillComment_4, ...args_4], void 0, function* (body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('captureAuthorizationByExternalKey', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('captureAuthorizationByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Record a chargeback
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackPayment: (body_3, paymentId_2, xKillbillCreatedBy_5, controlPluginName_3, pluginProperty_3, xKillbillReason_5, xKillbillComment_5, ...args_5) => __awaiter(this, [body_3, paymentId_2, xKillbillCreatedBy_5, controlPluginName_3, pluginProperty_3, xKillbillReason_5, xKillbillComment_5, ...args_5], void 0, function* (body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('chargebackPayment', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('chargebackPayment', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('chargebackPayment', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/{paymentId}/chargebacks`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Record a chargeback
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackPaymentByExternalKey: (body_4, xKillbillCreatedBy_6, controlPluginName_4, pluginProperty_4, xKillbillReason_6, xKillbillComment_6, ...args_6) => __awaiter(this, [body_4, xKillbillCreatedBy_6, controlPluginName_4, pluginProperty_4, xKillbillReason_6, xKillbillComment_6, ...args_6], void 0, function* (body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('chargebackPaymentByExternalKey', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('chargebackPaymentByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/chargebacks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackReversalPayment: (body_5, paymentId_3, xKillbillCreatedBy_7, controlPluginName_5, pluginProperty_5, xKillbillReason_7, xKillbillComment_7, ...args_7) => __awaiter(this, [body_5, paymentId_3, xKillbillCreatedBy_7, controlPluginName_5, pluginProperty_5, xKillbillReason_7, xKillbillComment_7, ...args_7], void 0, function* (body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('chargebackReversalPayment', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('chargebackReversalPayment', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('chargebackReversalPayment', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/{paymentId}/chargebackReversals`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackReversalPaymentByExternalKey: (body_6, xKillbillCreatedBy_8, controlPluginName_6, pluginProperty_6, xKillbillReason_8, xKillbillComment_8, ...args_8) => __awaiter(this, [body_6, xKillbillCreatedBy_8, controlPluginName_6, pluginProperty_6, xKillbillReason_8, xKillbillComment_8, ...args_8], void 0, function* (body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('chargebackReversalPaymentByExternalKey', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('chargebackReversalPaymentByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/chargebackReversals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTransaction: (body_7, paymentId_4, xKillbillCreatedBy_9, controlPluginName_7, pluginProperty_7, xKillbillReason_9, xKillbillComment_9, ...args_9) => __awaiter(this, [body_7, paymentId_4, xKillbillCreatedBy_9, controlPluginName_7, pluginProperty_7, xKillbillReason_9, xKillbillComment_9, ...args_9], void 0, function* (body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('completeTransaction', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('completeTransaction', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('completeTransaction', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTransactionByExternalKey: (body_8, xKillbillCreatedBy_10, controlPluginName_8, pluginProperty_8, xKillbillReason_10, xKillbillComment_10, ...args_10) => __awaiter(this, [body_8, xKillbillCreatedBy_10, controlPluginName_8, pluginProperty_8, xKillbillReason_10, xKillbillComment_10, ...args_10], void 0, function* (body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('completeTransactionByExternalKey', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('completeTransactionByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Combo api to create a new payment transaction on a existing (or not) account
         * @param {ComboPaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComboPayment: (body_9, xKillbillCreatedBy_11, controlPluginName_9, xKillbillReason_11, xKillbillComment_11, ...args_11) => __awaiter(this, [body_9, xKillbillCreatedBy_11, controlPluginName_9, xKillbillReason_11, xKillbillComment_11, ...args_11], void 0, function* (body, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createComboPayment', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createComboPayment', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/combo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentCustomFields: (body_10, paymentId_5, xKillbillCreatedBy_12, xKillbillReason_12, xKillbillComment_12, ...args_12) => __awaiter(this, [body_10, paymentId_5, xKillbillCreatedBy_12, xKillbillReason_12, xKillbillComment_12, ...args_12], void 0, function* (body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentCustomFields', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentCustomFields', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add tags to payment payment
         * @param {Array<string>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentTags: (body_11, paymentId_6, xKillbillCreatedBy_13, xKillbillReason_13, xKillbillComment_13, ...args_13) => __awaiter(this, [body_11, paymentId_6, xKillbillCreatedBy_13, xKillbillReason_13, xKillbillComment_13, ...args_13], void 0, function* (body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentTags', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentTags', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove custom fields from payment payment
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentCustomFields: (paymentId_7, xKillbillCreatedBy_14, customField_1, xKillbillReason_14, xKillbillComment_14, ...args_14) => __awaiter(this, [paymentId_7, xKillbillCreatedBy_14, customField_1, xKillbillReason_14, xKillbillComment_14, ...args_14], void 0, function* (paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('deletePaymentCustomFields', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deletePaymentCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove tags from payment payment
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentTags: (paymentId_8, xKillbillCreatedBy_15, tagDef_1, xKillbillReason_15, xKillbillComment_15, ...args_15) => __awaiter(this, [paymentId_8, xKillbillCreatedBy_15, tagDef_1, xKillbillReason_15, xKillbillComment_15, ...args_15], void 0, function* (paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('deletePaymentTags', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deletePaymentTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a payment by id
         * @param {string} paymentId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment: (paymentId_9, withPluginInfo_1, withAttempts_1, pluginProperty_9, audit_1, ...args_16) => __awaiter(this, [paymentId_9, withPluginInfo_1, withAttempts_1, pluginProperty_9, audit_1, ...args_16], void 0, function* (paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options = {}) {
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('getPayment', 'paymentId', paymentId);
            const localVarPath = `/1.0/kb/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }
            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve payment attempt audit logs with history by id
         * @param {string} paymentAttemptId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentAttemptAuditLogsWithHistory: (paymentAttemptId_1, ...args_17) => __awaiter(this, [paymentAttemptId_1, ...args_17], void 0, function* (paymentAttemptId, options = {}) {
            // verify required parameter 'paymentAttemptId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentAttemptAuditLogsWithHistory', 'paymentAttemptId', paymentAttemptId);
            const localVarPath = `/1.0/kb/payments/attempts/{paymentAttemptId}/auditLogsWithHistory`
                .replace(`{${"paymentAttemptId"}}`, encodeURIComponent(String(paymentAttemptId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve payment audit logs with history by id
         * @param {string} paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentAuditLogsWithHistory: (paymentId_10, ...args_18) => __awaiter(this, [paymentId_10, ...args_18], void 0, function* (paymentId, options = {}) {
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentAuditLogsWithHistory', 'paymentId', paymentId);
            const localVarPath = `/1.0/kb/payments/{paymentId}/auditLogsWithHistory`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a payment by external key
         * @param {string} externalKey
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByExternalKey: (externalKey_1, withPluginInfo_2, withAttempts_2, pluginProperty_10, audit_2, ...args_19) => __awaiter(this, [externalKey_1, withPluginInfo_2, withAttempts_2, pluginProperty_10, audit_2, ...args_19], void 0, function* (externalKey, withPluginInfo, withAttempts, pluginProperty, audit, options = {}) {
            // verify required parameter 'externalKey' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentByExternalKey', 'externalKey', externalKey);
            const localVarPath = `/1.0/kb/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }
            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }
            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve payment custom fields
         * @param {string} paymentId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentCustomFields: (paymentId_11, audit_3, ...args_20) => __awaiter(this, [paymentId_11, audit_3, ...args_20], void 0, function* (paymentId, audit, options = {}) {
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentCustomFields', 'paymentId', paymentId);
            const localVarPath = `/1.0/kb/payments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve payment payment tags
         * @param {string} paymentId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTags: (paymentId_12, includedDeleted_1, audit_4, ...args_21) => __awaiter(this, [paymentId_12, includedDeleted_1, audit_4, ...args_21], void 0, function* (paymentId, includedDeleted, audit, options = {}) {
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentTags', 'paymentId', paymentId);
            const localVarPath = `/1.0/kb/payments/{paymentId}/tags`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get payments
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [pluginName]
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments: (offset_1, limit_1, pluginName_1, withPluginInfo_3, withAttempts_3, pluginProperty_11, audit_5, ...args_22) => __awaiter(this, [offset_1, limit_1, pluginName_1, withPluginInfo_3, withAttempts_3, pluginProperty_11, audit_5, ...args_22], void 0, function* (offset, limit, pluginName, withPluginInfo, withAttempts, pluginProperty, audit, options = {}) {
            const localVarPath = `/1.0/kb/payments/pagination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (pluginName !== undefined) {
                localVarQueryParameter['pluginName'] = pluginName;
            }
            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }
            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPaymentCustomFields: (body_12, paymentId_13, xKillbillCreatedBy_16, xKillbillReason_16, xKillbillComment_16, ...args_23) => __awaiter(this, [body_12, paymentId_13, xKillbillCreatedBy_16, xKillbillReason_16, xKillbillComment_16, ...args_23], void 0, function* (body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('modifyPaymentCustomFields', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('modifyPaymentCustomFields', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('modifyPaymentCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/{paymentId}/customFields`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment: (body_13, paymentId_14, xKillbillCreatedBy_17, controlPluginName_10, pluginProperty_12, xKillbillReason_17, xKillbillComment_17, ...args_24) => __awaiter(this, [body_13, paymentId_14, xKillbillCreatedBy_17, controlPluginName_10, pluginProperty_12, xKillbillReason_17, xKillbillComment_17, ...args_24], void 0, function* (body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('refundPayment', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('refundPayment', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('refundPayment', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/{paymentId}/refunds`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPaymentByExternalKey: (body_14, xKillbillCreatedBy_18, controlPluginName_11, pluginProperty_13, xKillbillReason_18, xKillbillComment_18, ...args_25) => __awaiter(this, [body_14, xKillbillCreatedBy_18, controlPluginName_11, pluginProperty_13, xKillbillReason_18, xKillbillComment_18, ...args_25], void 0, function* (body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('refundPaymentByExternalKey', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('refundPaymentByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/refunds`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Search payments
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {string} [pluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPayments: (searchKey_1, offset_2, limit_2, withPluginInfo_4, withAttempts_4, pluginName_2, pluginProperty_14, audit_6, ...args_26) => __awaiter(this, [searchKey_1, offset_2, limit_2, withPluginInfo_4, withAttempts_4, pluginName_2, pluginProperty_14, audit_6, ...args_26], void 0, function* (searchKey, offset, limit, withPluginInfo, withAttempts, pluginName, pluginProperty, audit, options = {}) {
            // verify required parameter 'searchKey' is not null or undefined
            (0, common_1.assertParamExists)('searchPayments', 'searchKey', searchKey);
            const localVarPath = `/1.0/kb/payments/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }
            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }
            if (pluginName !== undefined) {
                localVarQueryParameter['pluginName'] = pluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Void an existing payment
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPayment: (body_15, paymentId_15, xKillbillCreatedBy_19, controlPluginName_12, pluginProperty_15, xKillbillReason_19, xKillbillComment_19, ...args_27) => __awaiter(this, [body_15, paymentId_15, xKillbillCreatedBy_19, controlPluginName_12, pluginProperty_15, xKillbillReason_19, xKillbillComment_19, ...args_27], void 0, function* (body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('voidPayment', 'body', body);
            // verify required parameter 'paymentId' is not null or undefined
            (0, common_1.assertParamExists)('voidPayment', 'paymentId', paymentId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('voidPayment', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments/{paymentId}`
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Void an existing payment
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPaymentByExternalKey: (body_16, xKillbillCreatedBy_20, controlPluginName_13, pluginProperty_16, xKillbillReason_20, xKillbillComment_20, ...args_28) => __awaiter(this, [body_16, xKillbillCreatedBy_20, controlPluginName_13, pluginProperty_16, xKillbillReason_20, xKillbillComment_20, ...args_28], void 0, function* (body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('voidPaymentByExternalKey', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('voidPaymentByExternalKey', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/payments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PaymentApiAxiosParamCreator = PaymentApiAxiosParamCreator;
/**
 * PaymentApi - functional programming interface
 * @export
 */
const PaymentApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PaymentApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} transactionExternalKey
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} paymentTransactionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelScheduledPaymentTransactionById(paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelScheduledPaymentTransactionById(paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureAuthorization(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.captureAuthorization(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureAuthorizationByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.captureAuthorizationByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Record a chargeback
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.chargebackPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Record a chargeback
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.chargebackPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackReversalPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.chargebackReversalPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackReversalPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.chargebackReversalPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.completeTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTransactionByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.completeTransactionByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Combo api to create a new payment transaction on a existing (or not) account
         * @param {ComboPaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComboPayment(body, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createComboPayment(body, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add tags to payment payment
         * @param {Array<string>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove custom fields from payment payment
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove tags from payment payment
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a payment by id
         * @param {string} paymentId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve payment attempt audit logs with history by id
         * @param {string} paymentAttemptId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentAttemptAuditLogsWithHistory(paymentAttemptId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentAttemptAuditLogsWithHistory(paymentAttemptId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve payment audit logs with history by id
         * @param {string} paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentAuditLogsWithHistory(paymentId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentAuditLogsWithHistory(paymentId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a payment by external key
         * @param {string} externalKey
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByExternalKey(externalKey, withPluginInfo, withAttempts, pluginProperty, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentByExternalKey(externalKey, withPluginInfo, withAttempts, pluginProperty, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve payment custom fields
         * @param {string} paymentId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentCustomFields(paymentId, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentCustomFields(paymentId, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve payment payment tags
         * @param {string} paymentId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTags(paymentId, includedDeleted, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentTags(paymentId, includedDeleted, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get payments
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [pluginName]
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments(offset, limit, pluginName, withPluginInfo, withAttempts, pluginProperty, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPayments(offset, limit, pluginName, withPluginInfo, withAttempts, pluginProperty, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.modifyPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.refundPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.refundPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Search payments
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {string} [pluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPayments(searchKey, offset, limit, withPluginInfo, withAttempts, pluginName, pluginProperty, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchPayments(searchKey, offset, limit, withPluginInfo, withAttempts, pluginName, pluginProperty, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Void an existing payment
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.voidPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Void an existing payment
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.voidPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.PaymentApiFp = PaymentApiFp;
/**
 * PaymentApi - factory interface
 * @export
 */
const PaymentApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PaymentApiFp)(configuration);
    return {
        /**
         *
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} transactionExternalKey
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Cancels a scheduled payment attempt retry
         * @param {string} paymentTransactionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelScheduledPaymentTransactionById(paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.cancelScheduledPaymentTransactionById(paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureAuthorization(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.captureAuthorization(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Capture an existing authorization
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureAuthorizationByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.captureAuthorizationByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Record a chargeback
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.chargebackPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Record a chargeback
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.chargebackPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackReversalPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.chargebackReversalPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Record a chargeback reversal
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        chargebackReversalPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.chargebackReversalPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.completeTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Complete an existing transaction
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        completeTransactionByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.completeTransactionByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Combo api to create a new payment transaction on a existing (or not) account
         * @param {ComboPaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createComboPayment(body, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createComboPayment(body, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add custom fields to payment
         * @param {Array<CustomField>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add tags to payment payment
         * @param {Array<string>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createPaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove custom fields from payment payment
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deletePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove tags from payment payment
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deletePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a payment by id
         * @param {string} paymentId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options) {
            return localVarFp.getPayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve payment attempt audit logs with history by id
         * @param {string} paymentAttemptId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentAttemptAuditLogsWithHistory(paymentAttemptId, options) {
            return localVarFp.getPaymentAttemptAuditLogsWithHistory(paymentAttemptId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve payment audit logs with history by id
         * @param {string} paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentAuditLogsWithHistory(paymentId, options) {
            return localVarFp.getPaymentAuditLogsWithHistory(paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a payment by external key
         * @param {string} externalKey
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByExternalKey(externalKey, withPluginInfo, withAttempts, pluginProperty, audit, options) {
            return localVarFp.getPaymentByExternalKey(externalKey, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve payment custom fields
         * @param {string} paymentId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentCustomFields(paymentId, audit, options) {
            return localVarFp.getPaymentCustomFields(paymentId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve payment payment tags
         * @param {string} paymentId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentTags(paymentId, includedDeleted, audit, options) {
            return localVarFp.getPaymentTags(paymentId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get payments
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [pluginName]
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayments(offset, limit, pluginName, withPluginInfo, withAttempts, pluginProperty, audit, options) {
            return localVarFp.getPayments(offset, limit, pluginName, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Modify custom fields to payment
         * @param {Array<CustomField>} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.modifyPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.refundPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Refund an existing payment
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refundPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.refundPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Search payments
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {string} [pluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPayments(searchKey, offset, limit, withPluginInfo, withAttempts, pluginName, pluginProperty, audit, options) {
            return localVarFp.searchPayments(searchKey, offset, limit, withPluginInfo, withAttempts, pluginName, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Void an existing payment
         * @param {PaymentTransaction} body
         * @param {string} paymentId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.voidPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Void an existing payment
         * @param {PaymentTransaction} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voidPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.voidPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PaymentApiFactory = PaymentApiFactory;
/**
 * PaymentApi - object-oriented interface
 * @export
 * @class PaymentApi
 * @extends {BaseAPI}
 */
class PaymentApi extends base_1.BaseAPI {
    /**
     *
     * @summary Cancels a scheduled payment attempt retry
     * @param {string} transactionExternalKey
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).cancelScheduledPaymentTransactionByExternalKey(transactionExternalKey, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Cancels a scheduled payment attempt retry
     * @param {string} paymentTransactionId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    cancelScheduledPaymentTransactionById(paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).cancelScheduledPaymentTransactionById(paymentTransactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Capture an existing authorization
     * @param {PaymentTransaction} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    captureAuthorization(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).captureAuthorization(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Capture an existing authorization
     * @param {PaymentTransaction} body
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    captureAuthorizationByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).captureAuthorizationByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Record a chargeback
     * @param {PaymentTransaction} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    chargebackPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).chargebackPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Record a chargeback
     * @param {PaymentTransaction} body
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    chargebackPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).chargebackPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Record a chargeback reversal
     * @param {PaymentTransaction} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    chargebackReversalPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).chargebackReversalPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Record a chargeback reversal
     * @param {PaymentTransaction} body
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    chargebackReversalPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).chargebackReversalPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Complete an existing transaction
     * @param {PaymentTransaction} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    completeTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).completeTransaction(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Complete an existing transaction
     * @param {PaymentTransaction} body
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    completeTransactionByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).completeTransactionByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Combo api to create a new payment transaction on a existing (or not) account
     * @param {ComboPaymentTransaction} body
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    createComboPayment(body, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).createComboPayment(body, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add custom fields to payment
     * @param {Array<CustomField>} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    createPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).createPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add tags to payment payment
     * @param {Array<string>} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    createPaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).createPaymentTags(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove custom fields from payment payment
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [customField]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    deletePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).deletePaymentCustomFields(paymentId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove tags from payment payment
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [tagDef]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    deletePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).deletePaymentTags(paymentId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a payment by id
     * @param {string} paymentId
     * @param {boolean} [withPluginInfo]
     * @param {boolean} [withAttempts]
     * @param {Array<string>} [pluginProperty]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    getPayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options) {
        return (0, exports.PaymentApiFp)(this.configuration).getPayment(paymentId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve payment attempt audit logs with history by id
     * @param {string} paymentAttemptId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    getPaymentAttemptAuditLogsWithHistory(paymentAttemptId, options) {
        return (0, exports.PaymentApiFp)(this.configuration).getPaymentAttemptAuditLogsWithHistory(paymentAttemptId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve payment audit logs with history by id
     * @param {string} paymentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    getPaymentAuditLogsWithHistory(paymentId, options) {
        return (0, exports.PaymentApiFp)(this.configuration).getPaymentAuditLogsWithHistory(paymentId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a payment by external key
     * @param {string} externalKey
     * @param {boolean} [withPluginInfo]
     * @param {boolean} [withAttempts]
     * @param {Array<string>} [pluginProperty]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    getPaymentByExternalKey(externalKey, withPluginInfo, withAttempts, pluginProperty, audit, options) {
        return (0, exports.PaymentApiFp)(this.configuration).getPaymentByExternalKey(externalKey, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve payment custom fields
     * @param {string} paymentId
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    getPaymentCustomFields(paymentId, audit, options) {
        return (0, exports.PaymentApiFp)(this.configuration).getPaymentCustomFields(paymentId, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve payment payment tags
     * @param {string} paymentId
     * @param {boolean} [includedDeleted]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    getPaymentTags(paymentId, includedDeleted, audit, options) {
        return (0, exports.PaymentApiFp)(this.configuration).getPaymentTags(paymentId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get payments
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [pluginName]
     * @param {boolean} [withPluginInfo]
     * @param {boolean} [withAttempts]
     * @param {Array<string>} [pluginProperty]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    getPayments(offset, limit, pluginName, withPluginInfo, withAttempts, pluginProperty, audit, options) {
        return (0, exports.PaymentApiFp)(this.configuration).getPayments(offset, limit, pluginName, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Modify custom fields to payment
     * @param {Array<CustomField>} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    modifyPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).modifyPaymentCustomFields(body, paymentId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Refund an existing payment
     * @param {PaymentTransaction} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    refundPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).refundPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Refund an existing payment
     * @param {PaymentTransaction} body
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    refundPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).refundPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Search payments
     * @param {string} searchKey
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {boolean} [withPluginInfo]
     * @param {boolean} [withAttempts]
     * @param {string} [pluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    searchPayments(searchKey, offset, limit, withPluginInfo, withAttempts, pluginName, pluginProperty, audit, options) {
        return (0, exports.PaymentApiFp)(this.configuration).searchPayments(searchKey, offset, limit, withPluginInfo, withAttempts, pluginName, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Void an existing payment
     * @param {PaymentTransaction} body
     * @param {string} paymentId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    voidPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).voidPayment(body, paymentId, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Void an existing payment
     * @param {PaymentTransaction} body
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentApi
     */
    voidPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentApiFp)(this.configuration).voidPaymentByExternalKey(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PaymentApi = PaymentApi;
/**
 * PaymentGatewayApi - axios parameter creator
 * @export
 */
const PaymentGatewayApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Combo API to generate form data to redirect the customer to the gateway
         * @param {ComboHostedPaymentPage} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildComboFormDescriptor: (body_1, xKillbillCreatedBy_1, controlPluginName_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [body_1, xKillbillCreatedBy_1, controlPluginName_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('buildComboFormDescriptor', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('buildComboFormDescriptor', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/paymentGateways/hosted/form`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Generate form data to redirect the customer to the gateway
         * @param {HostedPaymentPageFields} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [paymentMethodId]
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildFormDescriptor: (body_2, accountId_1, xKillbillCreatedBy_2, paymentMethodId_1, controlPluginName_2, pluginProperty_2, xKillbillReason_2, xKillbillComment_2, ...args_2) => __awaiter(this, [body_2, accountId_1, xKillbillCreatedBy_2, paymentMethodId_1, controlPluginName_2, pluginProperty_2, xKillbillReason_2, xKillbillComment_2, ...args_2], void 0, function* (body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('buildFormDescriptor', 'body', body);
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)('buildFormDescriptor', 'accountId', accountId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('buildFormDescriptor', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/paymentGateways/hosted/form/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (paymentMethodId !== undefined) {
                localVarQueryParameter['paymentMethodId'] = paymentMethodId;
            }
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * The response is built by the appropriate plugin
         * @summary Process a gateway notification
         * @param {string} body
         * @param {string} pluginName
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processNotification: (body_3, pluginName_1, xKillbillCreatedBy_3, controlPluginName_3, pluginProperty_3, xKillbillReason_3, xKillbillComment_3, ...args_3) => __awaiter(this, [body_3, pluginName_1, xKillbillCreatedBy_3, controlPluginName_3, pluginProperty_3, xKillbillReason_3, xKillbillComment_3, ...args_3], void 0, function* (body, pluginName, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('processNotification', 'body', body);
            // verify required parameter 'pluginName' is not null or undefined
            (0, common_1.assertParamExists)('processNotification', 'pluginName', pluginName);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('processNotification', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/paymentGateways/notification/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PaymentGatewayApiAxiosParamCreator = PaymentGatewayApiAxiosParamCreator;
/**
 * PaymentGatewayApi - functional programming interface
 * @export
 */
const PaymentGatewayApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PaymentGatewayApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Combo API to generate form data to redirect the customer to the gateway
         * @param {ComboHostedPaymentPage} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildComboFormDescriptor(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.buildComboFormDescriptor(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Generate form data to redirect the customer to the gateway
         * @param {HostedPaymentPageFields} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [paymentMethodId]
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildFormDescriptor(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.buildFormDescriptor(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * The response is built by the appropriate plugin
         * @summary Process a gateway notification
         * @param {string} body
         * @param {string} pluginName
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processNotification(body, pluginName, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.processNotification(body, pluginName, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.PaymentGatewayApiFp = PaymentGatewayApiFp;
/**
 * PaymentGatewayApi - factory interface
 * @export
 */
const PaymentGatewayApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PaymentGatewayApiFp)(configuration);
    return {
        /**
         *
         * @summary Combo API to generate form data to redirect the customer to the gateway
         * @param {ComboHostedPaymentPage} body
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildComboFormDescriptor(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.buildComboFormDescriptor(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Generate form data to redirect the customer to the gateway
         * @param {HostedPaymentPageFields} body
         * @param {string} accountId
         * @param {string} xKillbillCreatedBy
         * @param {string} [paymentMethodId]
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        buildFormDescriptor(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.buildFormDescriptor(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         * The response is built by the appropriate plugin
         * @summary Process a gateway notification
         * @param {string} body
         * @param {string} pluginName
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        processNotification(body, pluginName, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.processNotification(body, pluginName, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PaymentGatewayApiFactory = PaymentGatewayApiFactory;
/**
 * PaymentGatewayApi - object-oriented interface
 * @export
 * @class PaymentGatewayApi
 * @extends {BaseAPI}
 */
class PaymentGatewayApi extends base_1.BaseAPI {
    /**
     *
     * @summary Combo API to generate form data to redirect the customer to the gateway
     * @param {ComboHostedPaymentPage} body
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentGatewayApi
     */
    buildComboFormDescriptor(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentGatewayApiFp)(this.configuration).buildComboFormDescriptor(body, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Generate form data to redirect the customer to the gateway
     * @param {HostedPaymentPageFields} body
     * @param {string} accountId
     * @param {string} xKillbillCreatedBy
     * @param {string} [paymentMethodId]
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentGatewayApi
     */
    buildFormDescriptor(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentGatewayApiFp)(this.configuration).buildFormDescriptor(body, accountId, xKillbillCreatedBy, paymentMethodId, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * The response is built by the appropriate plugin
     * @summary Process a gateway notification
     * @param {string} body
     * @param {string} pluginName
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentGatewayApi
     */
    processNotification(body, pluginName, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentGatewayApiFp)(this.configuration).processNotification(body, pluginName, xKillbillCreatedBy, controlPluginName, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PaymentGatewayApi = PaymentGatewayApi;
/**
 * PaymentMethodApi - axios parameter creator
 * @export
 */
const PaymentMethodApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Add custom fields to payment method
         * @param {Array<CustomField>} body
         * @param {string} paymentMethodId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethodCustomFields: (body_1, paymentMethodId_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [body_1, paymentMethodId_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentMethodCustomFields', 'body', body);
            // verify required parameter 'paymentMethodId' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentMethodCustomFields', 'paymentMethodId', paymentMethodId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createPaymentMethodCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}/customFields`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a payment method
         * @param {string} paymentMethodId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [deleteDefaultPmWithAutoPayOff]
         * @param {boolean} [forceDefaultPmDeletion]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethod: (paymentMethodId_2, xKillbillCreatedBy_2, deleteDefaultPmWithAutoPayOff_1, forceDefaultPmDeletion_1, pluginProperty_1, xKillbillReason_2, xKillbillComment_2, ...args_2) => __awaiter(this, [paymentMethodId_2, xKillbillCreatedBy_2, deleteDefaultPmWithAutoPayOff_1, forceDefaultPmDeletion_1, pluginProperty_1, xKillbillReason_2, xKillbillComment_2, ...args_2], void 0, function* (paymentMethodId, xKillbillCreatedBy, deleteDefaultPmWithAutoPayOff, forceDefaultPmDeletion, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'paymentMethodId' is not null or undefined
            (0, common_1.assertParamExists)('deletePaymentMethod', 'paymentMethodId', paymentMethodId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deletePaymentMethod', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (deleteDefaultPmWithAutoPayOff !== undefined) {
                localVarQueryParameter['deleteDefaultPmWithAutoPayOff'] = deleteDefaultPmWithAutoPayOff;
            }
            if (forceDefaultPmDeletion !== undefined) {
                localVarQueryParameter['forceDefaultPmDeletion'] = forceDefaultPmDeletion;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove custom fields from payment method
         * @param {string} paymentMethodId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethodCustomFields: (paymentMethodId_3, xKillbillCreatedBy_3, customField_1, xKillbillReason_3, xKillbillComment_3, ...args_3) => __awaiter(this, [paymentMethodId_3, xKillbillCreatedBy_3, customField_1, xKillbillReason_3, xKillbillComment_3, ...args_3], void 0, function* (paymentMethodId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'paymentMethodId' is not null or undefined
            (0, common_1.assertParamExists)('deletePaymentMethodCustomFields', 'paymentMethodId', paymentMethodId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deletePaymentMethodCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}/customFields`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a payment method by id
         * @param {string} paymentMethodId
         * @param {boolean} [includedDeleted]
         * @param {boolean} [withPluginInfo]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod: (paymentMethodId_4, includedDeleted_1, withPluginInfo_1, pluginProperty_2, audit_1, ...args_4) => __awaiter(this, [paymentMethodId_4, includedDeleted_1, withPluginInfo_1, pluginProperty_2, audit_1, ...args_4], void 0, function* (paymentMethodId, includedDeleted, withPluginInfo, pluginProperty, audit, options = {}) {
            // verify required parameter 'paymentMethodId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentMethod', 'paymentMethodId', paymentMethodId);
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }
            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve payment method audit logs with history by id
         * @param {string} paymentMethodId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodAuditLogsWithHistory: (paymentMethodId_5, ...args_5) => __awaiter(this, [paymentMethodId_5, ...args_5], void 0, function* (paymentMethodId, options = {}) {
            // verify required parameter 'paymentMethodId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentMethodAuditLogsWithHistory', 'paymentMethodId', paymentMethodId);
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}/auditLogsWithHistory`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a payment method by external key
         * @param {string} externalKey
         * @param {boolean} [includedDeleted]
         * @param {boolean} [withPluginInfo]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodByKey: (externalKey_1, includedDeleted_2, withPluginInfo_2, pluginProperty_3, audit_2, ...args_6) => __awaiter(this, [externalKey_1, includedDeleted_2, withPluginInfo_2, pluginProperty_3, audit_2, ...args_6], void 0, function* (externalKey, includedDeleted, withPluginInfo, pluginProperty, audit, options = {}) {
            // verify required parameter 'externalKey' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentMethodByKey', 'externalKey', externalKey);
            const localVarPath = `/1.0/kb/paymentMethods`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }
            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }
            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve payment method custom fields
         * @param {string} paymentMethodId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodCustomFields: (paymentMethodId_6, audit_3, ...args_7) => __awaiter(this, [paymentMethodId_6, audit_3, ...args_7], void 0, function* (paymentMethodId, audit, options = {}) {
            // verify required parameter 'paymentMethodId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentMethodCustomFields', 'paymentMethodId', paymentMethodId);
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}/customFields`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List payment methods
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [pluginName]
         * @param {boolean} [withPluginInfo]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethods: (offset_1, limit_1, pluginName_1, withPluginInfo_3, pluginProperty_4, audit_4, ...args_8) => __awaiter(this, [offset_1, limit_1, pluginName_1, withPluginInfo_3, pluginProperty_4, audit_4, ...args_8], void 0, function* (offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options = {}) {
            const localVarPath = `/1.0/kb/paymentMethods/pagination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (pluginName !== undefined) {
                localVarQueryParameter['pluginName'] = pluginName;
            }
            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Modify custom fields to payment method
         * @param {Array<CustomField>} body
         * @param {string} paymentMethodId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPaymentMethodCustomFields: (body_2, paymentMethodId_7, xKillbillCreatedBy_4, xKillbillReason_4, xKillbillComment_4, ...args_9) => __awaiter(this, [body_2, paymentMethodId_7, xKillbillCreatedBy_4, xKillbillReason_4, xKillbillComment_4, ...args_9], void 0, function* (body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('modifyPaymentMethodCustomFields', 'body', body);
            // verify required parameter 'paymentMethodId' is not null or undefined
            (0, common_1.assertParamExists)('modifyPaymentMethodCustomFields', 'paymentMethodId', paymentMethodId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('modifyPaymentMethodCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/paymentMethods/{paymentMethodId}/customFields`
                .replace(`{${"paymentMethodId"}}`, encodeURIComponent(String(paymentMethodId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Search payment methods
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [pluginName]
         * @param {boolean} [withPluginInfo]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPaymentMethods: (searchKey_1, offset_2, limit_2, pluginName_2, withPluginInfo_4, pluginProperty_5, audit_5, ...args_10) => __awaiter(this, [searchKey_1, offset_2, limit_2, pluginName_2, withPluginInfo_4, pluginProperty_5, audit_5, ...args_10], void 0, function* (searchKey, offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options = {}) {
            // verify required parameter 'searchKey' is not null or undefined
            (0, common_1.assertParamExists)('searchPaymentMethods', 'searchKey', searchKey);
            const localVarPath = `/1.0/kb/paymentMethods/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (pluginName !== undefined) {
                localVarQueryParameter['pluginName'] = pluginName;
            }
            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PaymentMethodApiAxiosParamCreator = PaymentMethodApiAxiosParamCreator;
/**
 * PaymentMethodApi - functional programming interface
 * @export
 */
const PaymentMethodApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PaymentMethodApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Add custom fields to payment method
         * @param {Array<CustomField>} body
         * @param {string} paymentMethodId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Delete a payment method
         * @param {string} paymentMethodId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [deleteDefaultPmWithAutoPayOff]
         * @param {boolean} [forceDefaultPmDeletion]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethod(paymentMethodId, xKillbillCreatedBy, deleteDefaultPmWithAutoPayOff, forceDefaultPmDeletion, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePaymentMethod(paymentMethodId, xKillbillCreatedBy, deleteDefaultPmWithAutoPayOff, forceDefaultPmDeletion, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove custom fields from payment method
         * @param {string} paymentMethodId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethodCustomFields(paymentMethodId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePaymentMethodCustomFields(paymentMethodId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a payment method by id
         * @param {string} paymentMethodId
         * @param {boolean} [includedDeleted]
         * @param {boolean} [withPluginInfo]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod(paymentMethodId, includedDeleted, withPluginInfo, pluginProperty, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentMethod(paymentMethodId, includedDeleted, withPluginInfo, pluginProperty, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve payment method audit logs with history by id
         * @param {string} paymentMethodId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodAuditLogsWithHistory(paymentMethodId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentMethodAuditLogsWithHistory(paymentMethodId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a payment method by external key
         * @param {string} externalKey
         * @param {boolean} [includedDeleted]
         * @param {boolean} [withPluginInfo]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodByKey(externalKey, includedDeleted, withPluginInfo, pluginProperty, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentMethodByKey(externalKey, includedDeleted, withPluginInfo, pluginProperty, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve payment method custom fields
         * @param {string} paymentMethodId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodCustomFields(paymentMethodId, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentMethodCustomFields(paymentMethodId, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List payment methods
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [pluginName]
         * @param {boolean} [withPluginInfo]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethods(offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentMethods(offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Modify custom fields to payment method
         * @param {Array<CustomField>} body
         * @param {string} paymentMethodId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.modifyPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Search payment methods
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [pluginName]
         * @param {boolean} [withPluginInfo]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPaymentMethods(searchKey, offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchPaymentMethods(searchKey, offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.PaymentMethodApiFp = PaymentMethodApiFp;
/**
 * PaymentMethodApi - factory interface
 * @export
 */
const PaymentMethodApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PaymentMethodApiFp)(configuration);
    return {
        /**
         *
         * @summary Add custom fields to payment method
         * @param {Array<CustomField>} body
         * @param {string} paymentMethodId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a payment method
         * @param {string} paymentMethodId
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [deleteDefaultPmWithAutoPayOff]
         * @param {boolean} [forceDefaultPmDeletion]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethod(paymentMethodId, xKillbillCreatedBy, deleteDefaultPmWithAutoPayOff, forceDefaultPmDeletion, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deletePaymentMethod(paymentMethodId, xKillbillCreatedBy, deleteDefaultPmWithAutoPayOff, forceDefaultPmDeletion, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove custom fields from payment method
         * @param {string} paymentMethodId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethodCustomFields(paymentMethodId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deletePaymentMethodCustomFields(paymentMethodId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a payment method by id
         * @param {string} paymentMethodId
         * @param {boolean} [includedDeleted]
         * @param {boolean} [withPluginInfo]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethod(paymentMethodId, includedDeleted, withPluginInfo, pluginProperty, audit, options) {
            return localVarFp.getPaymentMethod(paymentMethodId, includedDeleted, withPluginInfo, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve payment method audit logs with history by id
         * @param {string} paymentMethodId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodAuditLogsWithHistory(paymentMethodId, options) {
            return localVarFp.getPaymentMethodAuditLogsWithHistory(paymentMethodId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a payment method by external key
         * @param {string} externalKey
         * @param {boolean} [includedDeleted]
         * @param {boolean} [withPluginInfo]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodByKey(externalKey, includedDeleted, withPluginInfo, pluginProperty, audit, options) {
            return localVarFp.getPaymentMethodByKey(externalKey, includedDeleted, withPluginInfo, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve payment method custom fields
         * @param {string} paymentMethodId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethodCustomFields(paymentMethodId, audit, options) {
            return localVarFp.getPaymentMethodCustomFields(paymentMethodId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List payment methods
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [pluginName]
         * @param {boolean} [withPluginInfo]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethods(offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options) {
            return localVarFp.getPaymentMethods(offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Modify custom fields to payment method
         * @param {Array<CustomField>} body
         * @param {string} paymentMethodId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.modifyPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Search payment methods
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {string} [pluginName]
         * @param {boolean} [withPluginInfo]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPaymentMethods(searchKey, offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options) {
            return localVarFp.searchPaymentMethods(searchKey, offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PaymentMethodApiFactory = PaymentMethodApiFactory;
/**
 * PaymentMethodApi - object-oriented interface
 * @export
 * @class PaymentMethodApi
 * @extends {BaseAPI}
 */
class PaymentMethodApi extends base_1.BaseAPI {
    /**
     *
     * @summary Add custom fields to payment method
     * @param {Array<CustomField>} body
     * @param {string} paymentMethodId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    createPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentMethodApiFp)(this.configuration).createPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a payment method
     * @param {string} paymentMethodId
     * @param {string} xKillbillCreatedBy
     * @param {boolean} [deleteDefaultPmWithAutoPayOff]
     * @param {boolean} [forceDefaultPmDeletion]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    deletePaymentMethod(paymentMethodId, xKillbillCreatedBy, deleteDefaultPmWithAutoPayOff, forceDefaultPmDeletion, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentMethodApiFp)(this.configuration).deletePaymentMethod(paymentMethodId, xKillbillCreatedBy, deleteDefaultPmWithAutoPayOff, forceDefaultPmDeletion, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove custom fields from payment method
     * @param {string} paymentMethodId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [customField]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    deletePaymentMethodCustomFields(paymentMethodId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentMethodApiFp)(this.configuration).deletePaymentMethodCustomFields(paymentMethodId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a payment method by id
     * @param {string} paymentMethodId
     * @param {boolean} [includedDeleted]
     * @param {boolean} [withPluginInfo]
     * @param {Array<string>} [pluginProperty]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    getPaymentMethod(paymentMethodId, includedDeleted, withPluginInfo, pluginProperty, audit, options) {
        return (0, exports.PaymentMethodApiFp)(this.configuration).getPaymentMethod(paymentMethodId, includedDeleted, withPluginInfo, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve payment method audit logs with history by id
     * @param {string} paymentMethodId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    getPaymentMethodAuditLogsWithHistory(paymentMethodId, options) {
        return (0, exports.PaymentMethodApiFp)(this.configuration).getPaymentMethodAuditLogsWithHistory(paymentMethodId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a payment method by external key
     * @param {string} externalKey
     * @param {boolean} [includedDeleted]
     * @param {boolean} [withPluginInfo]
     * @param {Array<string>} [pluginProperty]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    getPaymentMethodByKey(externalKey, includedDeleted, withPluginInfo, pluginProperty, audit, options) {
        return (0, exports.PaymentMethodApiFp)(this.configuration).getPaymentMethodByKey(externalKey, includedDeleted, withPluginInfo, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve payment method custom fields
     * @param {string} paymentMethodId
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    getPaymentMethodCustomFields(paymentMethodId, audit, options) {
        return (0, exports.PaymentMethodApiFp)(this.configuration).getPaymentMethodCustomFields(paymentMethodId, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List payment methods
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [pluginName]
     * @param {boolean} [withPluginInfo]
     * @param {Array<string>} [pluginProperty]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    getPaymentMethods(offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options) {
        return (0, exports.PaymentMethodApiFp)(this.configuration).getPaymentMethods(offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Modify custom fields to payment method
     * @param {Array<CustomField>} body
     * @param {string} paymentMethodId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    modifyPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentMethodApiFp)(this.configuration).modifyPaymentMethodCustomFields(body, paymentMethodId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Search payment methods
     * @param {string} searchKey
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {string} [pluginName]
     * @param {boolean} [withPluginInfo]
     * @param {Array<string>} [pluginProperty]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    searchPaymentMethods(searchKey, offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options) {
        return (0, exports.PaymentMethodApiFp)(this.configuration).searchPaymentMethods(searchKey, offset, limit, pluginName, withPluginInfo, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PaymentMethodApi = PaymentMethodApi;
/**
 * PaymentTransactionApi - axios parameter creator
 * @export
 */
const PaymentTransactionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Add custom fields to payment transaction
         * @param {Array<CustomField>} body
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionCustomFields: (body_1, transactionId_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [body_1, transactionId_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createTransactionCustomFields', 'body', body);
            // verify required parameter 'transactionId' is not null or undefined
            (0, common_1.assertParamExists)('createTransactionCustomFields', 'transactionId', transactionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createTransactionCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/customFields`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add tags to payment transaction
         * @param {Array<string>} body
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionTags: (body_2, transactionId_2, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2) => __awaiter(this, [body_2, transactionId_2, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2], void 0, function* (body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createTransactionTags', 'body', body);
            // verify required parameter 'transactionId' is not null or undefined
            (0, common_1.assertParamExists)('createTransactionTags', 'transactionId', transactionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createTransactionTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/tags`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove custom fields from payment transaction
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionCustomFields: (transactionId_3, xKillbillCreatedBy_3, customField_1, xKillbillReason_3, xKillbillComment_3, ...args_3) => __awaiter(this, [transactionId_3, xKillbillCreatedBy_3, customField_1, xKillbillReason_3, xKillbillComment_3, ...args_3], void 0, function* (transactionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'transactionId' is not null or undefined
            (0, common_1.assertParamExists)('deleteTransactionCustomFields', 'transactionId', transactionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteTransactionCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/customFields`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove tags from payment transaction
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionTags: (transactionId_4, xKillbillCreatedBy_4, tagDef_1, xKillbillReason_4, xKillbillComment_4, ...args_4) => __awaiter(this, [transactionId_4, xKillbillCreatedBy_4, tagDef_1, xKillbillReason_4, xKillbillComment_4, ...args_4], void 0, function* (transactionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'transactionId' is not null or undefined
            (0, common_1.assertParamExists)('deleteTransactionTags', 'transactionId', transactionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteTransactionTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/tags`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a payment by transaction external key
         * @param {string} transactionExternalKey
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByTransactionExternalKey: (transactionExternalKey_1, withPluginInfo_1, withAttempts_1, pluginProperty_1, audit_1, ...args_5) => __awaiter(this, [transactionExternalKey_1, withPluginInfo_1, withAttempts_1, pluginProperty_1, audit_1, ...args_5], void 0, function* (transactionExternalKey, withPluginInfo, withAttempts, pluginProperty, audit, options = {}) {
            // verify required parameter 'transactionExternalKey' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentByTransactionExternalKey', 'transactionExternalKey', transactionExternalKey);
            const localVarPath = `/1.0/kb/paymentTransactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (transactionExternalKey !== undefined) {
                localVarQueryParameter['transactionExternalKey'] = transactionExternalKey;
            }
            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }
            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a payment by transaction id
         * @param {string} transactionId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByTransactionId: (transactionId_5, withPluginInfo_2, withAttempts_2, pluginProperty_2, audit_2, ...args_6) => __awaiter(this, [transactionId_5, withPluginInfo_2, withAttempts_2, pluginProperty_2, audit_2, ...args_6], void 0, function* (transactionId, withPluginInfo, withAttempts, pluginProperty, audit, options = {}) {
            // verify required parameter 'transactionId' is not null or undefined
            (0, common_1.assertParamExists)('getPaymentByTransactionId', 'transactionId', transactionId);
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (withPluginInfo !== undefined) {
                localVarQueryParameter['withPluginInfo'] = withPluginInfo;
            }
            if (withAttempts !== undefined) {
                localVarQueryParameter['withAttempts'] = withAttempts;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve payment transaction audit logs with history by id
         * @param {string} transactionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionAuditLogsWithHistory: (transactionId_6, ...args_7) => __awaiter(this, [transactionId_6, ...args_7], void 0, function* (transactionId, options = {}) {
            // verify required parameter 'transactionId' is not null or undefined
            (0, common_1.assertParamExists)('getTransactionAuditLogsWithHistory', 'transactionId', transactionId);
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/auditLogsWithHistory`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve payment transaction custom fields
         * @param {string} transactionId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCustomFields: (transactionId_7, audit_3, ...args_8) => __awaiter(this, [transactionId_7, audit_3, ...args_8], void 0, function* (transactionId, audit, options = {}) {
            // verify required parameter 'transactionId' is not null or undefined
            (0, common_1.assertParamExists)('getTransactionCustomFields', 'transactionId', transactionId);
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/customFields`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve payment transaction tags
         * @param {string} transactionId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionTags: (transactionId_8, includedDeleted_1, audit_4, ...args_9) => __awaiter(this, [transactionId_8, includedDeleted_1, audit_4, ...args_9], void 0, function* (transactionId, includedDeleted, audit, options = {}) {
            // verify required parameter 'transactionId' is not null or undefined
            (0, common_1.assertParamExists)('getTransactionTags', 'transactionId', transactionId);
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/tags`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Modify custom fields to payment transaction
         * @param {Array<CustomField>} body
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTransactionCustomFields: (body_3, transactionId_9, xKillbillCreatedBy_5, xKillbillReason_5, xKillbillComment_5, ...args_10) => __awaiter(this, [body_3, transactionId_9, xKillbillCreatedBy_5, xKillbillReason_5, xKillbillComment_5, ...args_10], void 0, function* (body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('modifyTransactionCustomFields', 'body', body);
            // verify required parameter 'transactionId' is not null or undefined
            (0, common_1.assertParamExists)('modifyTransactionCustomFields', 'transactionId', transactionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('modifyTransactionCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}/customFields`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Mark a pending payment transaction as succeeded or failed
         * @param {PaymentTransaction} body
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyStateChanged: (body_4, transactionId_10, xKillbillCreatedBy_6, controlPluginName_1, xKillbillReason_6, xKillbillComment_6, ...args_11) => __awaiter(this, [body_4, transactionId_10, xKillbillCreatedBy_6, controlPluginName_1, xKillbillReason_6, xKillbillComment_6, ...args_11], void 0, function* (body, transactionId, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('notifyStateChanged', 'body', body);
            // verify required parameter 'transactionId' is not null or undefined
            (0, common_1.assertParamExists)('notifyStateChanged', 'transactionId', transactionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('notifyStateChanged', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/paymentTransactions/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (controlPluginName) {
                localVarQueryParameter['controlPluginName'] = controlPluginName;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PaymentTransactionApiAxiosParamCreator = PaymentTransactionApiAxiosParamCreator;
/**
 * PaymentTransactionApi - functional programming interface
 * @export
 */
const PaymentTransactionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PaymentTransactionApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Add custom fields to payment transaction
         * @param {Array<CustomField>} body
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add tags to payment transaction
         * @param {Array<string>} body
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionTags(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTransactionTags(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove custom fields from payment transaction
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionCustomFields(transactionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteTransactionCustomFields(transactionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove tags from payment transaction
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionTags(transactionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteTransactionTags(transactionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a payment by transaction external key
         * @param {string} transactionExternalKey
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByTransactionExternalKey(transactionExternalKey, withPluginInfo, withAttempts, pluginProperty, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentByTransactionExternalKey(transactionExternalKey, withPluginInfo, withAttempts, pluginProperty, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a payment by transaction id
         * @param {string} transactionId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByTransactionId(transactionId, withPluginInfo, withAttempts, pluginProperty, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPaymentByTransactionId(transactionId, withPluginInfo, withAttempts, pluginProperty, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve payment transaction audit logs with history by id
         * @param {string} transactionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionAuditLogsWithHistory(transactionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTransactionAuditLogsWithHistory(transactionId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve payment transaction custom fields
         * @param {string} transactionId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCustomFields(transactionId, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTransactionCustomFields(transactionId, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve payment transaction tags
         * @param {string} transactionId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionTags(transactionId, includedDeleted, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTransactionTags(transactionId, includedDeleted, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Modify custom fields to payment transaction
         * @param {Array<CustomField>} body
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.modifyTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Mark a pending payment transaction as succeeded or failed
         * @param {PaymentTransaction} body
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyStateChanged(body, transactionId, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.notifyStateChanged(body, transactionId, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.PaymentTransactionApiFp = PaymentTransactionApiFp;
/**
 * PaymentTransactionApi - factory interface
 * @export
 */
const PaymentTransactionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PaymentTransactionApiFp)(configuration);
    return {
        /**
         *
         * @summary Add custom fields to payment transaction
         * @param {Array<CustomField>} body
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add tags to payment transaction
         * @param {Array<string>} body
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTransactionTags(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createTransactionTags(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove custom fields from payment transaction
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionCustomFields(transactionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteTransactionCustomFields(transactionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove tags from payment transaction
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransactionTags(transactionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteTransactionTags(transactionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a payment by transaction external key
         * @param {string} transactionExternalKey
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByTransactionExternalKey(transactionExternalKey, withPluginInfo, withAttempts, pluginProperty, audit, options) {
            return localVarFp.getPaymentByTransactionExternalKey(transactionExternalKey, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a payment by transaction id
         * @param {string} transactionId
         * @param {boolean} [withPluginInfo]
         * @param {boolean} [withAttempts]
         * @param {Array<string>} [pluginProperty]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentByTransactionId(transactionId, withPluginInfo, withAttempts, pluginProperty, audit, options) {
            return localVarFp.getPaymentByTransactionId(transactionId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve payment transaction audit logs with history by id
         * @param {string} transactionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionAuditLogsWithHistory(transactionId, options) {
            return localVarFp.getTransactionAuditLogsWithHistory(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve payment transaction custom fields
         * @param {string} transactionId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionCustomFields(transactionId, audit, options) {
            return localVarFp.getTransactionCustomFields(transactionId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve payment transaction tags
         * @param {string} transactionId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionTags(transactionId, includedDeleted, audit, options) {
            return localVarFp.getTransactionTags(transactionId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Modify custom fields to payment transaction
         * @param {Array<CustomField>} body
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.modifyTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Mark a pending payment transaction as succeeded or failed
         * @param {PaymentTransaction} body
         * @param {string} transactionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [controlPluginName]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        notifyStateChanged(body, transactionId, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options) {
            return localVarFp.notifyStateChanged(body, transactionId, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.PaymentTransactionApiFactory = PaymentTransactionApiFactory;
/**
 * PaymentTransactionApi - object-oriented interface
 * @export
 * @class PaymentTransactionApi
 * @extends {BaseAPI}
 */
class PaymentTransactionApi extends base_1.BaseAPI {
    /**
     *
     * @summary Add custom fields to payment transaction
     * @param {Array<CustomField>} body
     * @param {string} transactionId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    createTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentTransactionApiFp)(this.configuration).createTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add tags to payment transaction
     * @param {Array<string>} body
     * @param {string} transactionId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    createTransactionTags(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentTransactionApiFp)(this.configuration).createTransactionTags(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove custom fields from payment transaction
     * @param {string} transactionId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [customField]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    deleteTransactionCustomFields(transactionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentTransactionApiFp)(this.configuration).deleteTransactionCustomFields(transactionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove tags from payment transaction
     * @param {string} transactionId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [tagDef]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    deleteTransactionTags(transactionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentTransactionApiFp)(this.configuration).deleteTransactionTags(transactionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a payment by transaction external key
     * @param {string} transactionExternalKey
     * @param {boolean} [withPluginInfo]
     * @param {boolean} [withAttempts]
     * @param {Array<string>} [pluginProperty]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    getPaymentByTransactionExternalKey(transactionExternalKey, withPluginInfo, withAttempts, pluginProperty, audit, options) {
        return (0, exports.PaymentTransactionApiFp)(this.configuration).getPaymentByTransactionExternalKey(transactionExternalKey, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a payment by transaction id
     * @param {string} transactionId
     * @param {boolean} [withPluginInfo]
     * @param {boolean} [withAttempts]
     * @param {Array<string>} [pluginProperty]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    getPaymentByTransactionId(transactionId, withPluginInfo, withAttempts, pluginProperty, audit, options) {
        return (0, exports.PaymentTransactionApiFp)(this.configuration).getPaymentByTransactionId(transactionId, withPluginInfo, withAttempts, pluginProperty, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve payment transaction audit logs with history by id
     * @param {string} transactionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    getTransactionAuditLogsWithHistory(transactionId, options) {
        return (0, exports.PaymentTransactionApiFp)(this.configuration).getTransactionAuditLogsWithHistory(transactionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve payment transaction custom fields
     * @param {string} transactionId
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    getTransactionCustomFields(transactionId, audit, options) {
        return (0, exports.PaymentTransactionApiFp)(this.configuration).getTransactionCustomFields(transactionId, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve payment transaction tags
     * @param {string} transactionId
     * @param {boolean} [includedDeleted]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    getTransactionTags(transactionId, includedDeleted, audit, options) {
        return (0, exports.PaymentTransactionApiFp)(this.configuration).getTransactionTags(transactionId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Modify custom fields to payment transaction
     * @param {Array<CustomField>} body
     * @param {string} transactionId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    modifyTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentTransactionApiFp)(this.configuration).modifyTransactionCustomFields(body, transactionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Mark a pending payment transaction as succeeded or failed
     * @param {PaymentTransaction} body
     * @param {string} transactionId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [controlPluginName]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentTransactionApi
     */
    notifyStateChanged(body, transactionId, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options) {
        return (0, exports.PaymentTransactionApiFp)(this.configuration).notifyStateChanged(body, transactionId, xKillbillCreatedBy, controlPluginName, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PaymentTransactionApi = PaymentTransactionApi;
/**
 * PluginInfoApi - axios parameter creator
 * @export
 */
const PluginInfoApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Retrieve the list of registered plugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsInfo: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/1.0/kb/pluginsInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PluginInfoApiAxiosParamCreator = PluginInfoApiAxiosParamCreator;
/**
 * PluginInfoApi - functional programming interface
 * @export
 */
const PluginInfoApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PluginInfoApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve the list of registered plugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsInfo(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPluginsInfo(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.PluginInfoApiFp = PluginInfoApiFp;
/**
 * PluginInfoApi - factory interface
 * @export
 */
const PluginInfoApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PluginInfoApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve the list of registered plugins
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginsInfo(options) {
            return localVarFp.getPluginsInfo(options).then((request) => request(axios, basePath));
        },
    };
};
exports.PluginInfoApiFactory = PluginInfoApiFactory;
/**
 * PluginInfoApi - object-oriented interface
 * @export
 * @class PluginInfoApi
 * @extends {BaseAPI}
 */
class PluginInfoApi extends base_1.BaseAPI {
    /**
     *
     * @summary Retrieve the list of registered plugins
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PluginInfoApi
     */
    getPluginsInfo(options) {
        return (0, exports.PluginInfoApiFp)(this.configuration).getPluginsInfo(options).then((request) => request(this.axios, this.basePath));
    }
}
exports.PluginInfoApi = PluginInfoApi;
/**
 * SecurityApi - axios parameter creator
 * @export
 */
const SecurityApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Add a new role definition)
         * @param {RoleDefinition} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleDefinition: (body_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [body_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('addRoleDefinition', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('addRoleDefinition', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/security/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add a new user with roles (to make api requests)
         * @param {UserRoles} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserRoles: (body_2, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2) => __awaiter(this, [body_2, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2], void 0, function* (body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('addUserRoles', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('addUserRoles', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/security/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List user permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserPermissions: (...args_3) => __awaiter(this, [...args_3], void 0, function* (options = {}) {
            const localVarPath = `/1.0/kb/security/permissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserSubject: (...args_4) => __awaiter(this, [...args_4], void 0, function* (options = {}) {
            const localVarPath = `/1.0/kb/security/subject`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get role definition
         * @param {string} role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleDefinition: (role_1, ...args_5) => __awaiter(this, [role_1, ...args_5], void 0, function* (role, options = {}) {
            // verify required parameter 'role' is not null or undefined
            (0, common_1.assertParamExists)('getRoleDefinition', 'role', role);
            const localVarPath = `/1.0/kb/security/roles/{role}`
                .replace(`{${"role"}}`, encodeURIComponent(String(role)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get roles associated to a user
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles: (username_1, ...args_6) => __awaiter(this, [username_1, ...args_6], void 0, function* (username, options = {}) {
            // verify required parameter 'username' is not null or undefined
            (0, common_1.assertParamExists)('getUserRoles', 'username', username);
            const localVarPath = `/1.0/kb/security/users/{username}/roles`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Invalidate an existing user
         * @param {string} username
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateUser: (username_2, xKillbillCreatedBy_3, xKillbillReason_3, xKillbillComment_3, ...args_7) => __awaiter(this, [username_2, xKillbillCreatedBy_3, xKillbillReason_3, xKillbillComment_3, ...args_7], void 0, function* (username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'username' is not null or undefined
            (0, common_1.assertParamExists)('invalidateUser', 'username', username);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('invalidateUser', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/security/users/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update a new role definition)
         * @param {RoleDefinition} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleDefinition: (body_3, xKillbillCreatedBy_4, xKillbillReason_4, xKillbillComment_4, ...args_8) => __awaiter(this, [body_3, xKillbillCreatedBy_4, xKillbillReason_4, xKillbillComment_4, ...args_8], void 0, function* (body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateRoleDefinition', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('updateRoleDefinition', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/security/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update a user password
         * @param {UserRoles} body
         * @param {string} username
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword: (body_4, username_3, xKillbillCreatedBy_5, xKillbillReason_5, xKillbillComment_5, ...args_9) => __awaiter(this, [body_4, username_3, xKillbillCreatedBy_5, xKillbillReason_5, xKillbillComment_5, ...args_9], void 0, function* (body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateUserPassword', 'body', body);
            // verify required parameter 'username' is not null or undefined
            (0, common_1.assertParamExists)('updateUserPassword', 'username', username);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('updateUserPassword', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/security/users/{username}/password`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update roles associated to a user
         * @param {UserRoles} body
         * @param {string} username
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoles: (body_5, username_4, xKillbillCreatedBy_6, xKillbillReason_6, xKillbillComment_6, ...args_10) => __awaiter(this, [body_5, username_4, xKillbillCreatedBy_6, xKillbillReason_6, xKillbillComment_6, ...args_10], void 0, function* (body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateUserRoles', 'body', body);
            // verify required parameter 'username' is not null or undefined
            (0, common_1.assertParamExists)('updateUserRoles', 'username', username);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('updateUserRoles', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/security/users/{username}/roles`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SecurityApiAxiosParamCreator = SecurityApiAxiosParamCreator;
/**
 * SecurityApi - functional programming interface
 * @export
 */
const SecurityApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SecurityApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Add a new role definition)
         * @param {RoleDefinition} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add a new user with roles (to make api requests)
         * @param {UserRoles} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserRoles(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addUserRoles(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List user permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserPermissions(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCurrentUserPermissions(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserSubject(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getCurrentUserSubject(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get role definition
         * @param {string} role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleDefinition(role, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getRoleDefinition(role, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get roles associated to a user
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserRoles(username, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Invalidate an existing user
         * @param {string} username
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateUser(username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.invalidateUser(username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Update a new role definition)
         * @param {RoleDefinition} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Update a user password
         * @param {UserRoles} body
         * @param {string} username
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserPassword(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Update roles associated to a user
         * @param {UserRoles} body
         * @param {string} username
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoles(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateUserRoles(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.SecurityApiFp = SecurityApiFp;
/**
 * SecurityApi - factory interface
 * @export
 */
const SecurityApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SecurityApiFp)(configuration);
    return {
        /**
         *
         * @summary Add a new role definition)
         * @param {RoleDefinition} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.addRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add a new user with roles (to make api requests)
         * @param {UserRoles} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUserRoles(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.addUserRoles(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List user permissions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserPermissions(options) {
            return localVarFp.getCurrentUserPermissions(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get user information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUserSubject(options) {
            return localVarFp.getCurrentUserSubject(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get role definition
         * @param {string} role
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoleDefinition(role, options) {
            return localVarFp.getRoleDefinition(role, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get roles associated to a user
         * @param {string} username
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserRoles(username, options) {
            return localVarFp.getUserRoles(username, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Invalidate an existing user
         * @param {string} username
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invalidateUser(username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.invalidateUser(username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a new role definition)
         * @param {RoleDefinition} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.updateRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a user password
         * @param {UserRoles} body
         * @param {string} username
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPassword(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.updateUserPassword(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update roles associated to a user
         * @param {UserRoles} body
         * @param {string} username
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserRoles(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.updateUserRoles(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SecurityApiFactory = SecurityApiFactory;
/**
 * SecurityApi - object-oriented interface
 * @export
 * @class SecurityApi
 * @extends {BaseAPI}
 */
class SecurityApi extends base_1.BaseAPI {
    /**
     *
     * @summary Add a new role definition)
     * @param {RoleDefinition} body
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    addRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SecurityApiFp)(this.configuration).addRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add a new user with roles (to make api requests)
     * @param {UserRoles} body
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    addUserRoles(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SecurityApiFp)(this.configuration).addUserRoles(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List user permissions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    getCurrentUserPermissions(options) {
        return (0, exports.SecurityApiFp)(this.configuration).getCurrentUserPermissions(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get user information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    getCurrentUserSubject(options) {
        return (0, exports.SecurityApiFp)(this.configuration).getCurrentUserSubject(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get role definition
     * @param {string} role
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    getRoleDefinition(role, options) {
        return (0, exports.SecurityApiFp)(this.configuration).getRoleDefinition(role, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get roles associated to a user
     * @param {string} username
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    getUserRoles(username, options) {
        return (0, exports.SecurityApiFp)(this.configuration).getUserRoles(username, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Invalidate an existing user
     * @param {string} username
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    invalidateUser(username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SecurityApiFp)(this.configuration).invalidateUser(username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a new role definition)
     * @param {RoleDefinition} body
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    updateRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SecurityApiFp)(this.configuration).updateRoleDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a user password
     * @param {UserRoles} body
     * @param {string} username
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    updateUserPassword(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SecurityApiFp)(this.configuration).updateUserPassword(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update roles associated to a user
     * @param {UserRoles} body
     * @param {string} username
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityApi
     */
    updateUserRoles(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SecurityApiFp)(this.configuration).updateUserRoles(body, username, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SecurityApi = SecurityApi;
/**
 * SubscriptionApi - axios parameter creator
 * @export
 */
const SubscriptionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Block a subscription
         * @param {BlockingState} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscriptionBlockingState: (body_1, subscriptionId_1, xKillbillCreatedBy_1, requestedDate_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [body_1, subscriptionId_1, xKillbillCreatedBy_1, requestedDate_1, pluginProperty_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (body, subscriptionId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('addSubscriptionBlockingState', 'body', body);
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('addSubscriptionBlockingState', 'subscriptionId', subscriptionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('addSubscriptionBlockingState', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/block`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString().substr(0, 10) :
                    requestedDate;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Cancel an entitlement plan
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {boolean} [callCompletion]
         * @param {number} [callTimeoutSec]
         * @param {'IMMEDIATE' | 'END_OF_TERM'} [entitlementPolicy]
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy]
         * @param {boolean} [useRequestedDateForBilling]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscriptionPlan: (subscriptionId_2, xKillbillCreatedBy_2, requestedDate_2, callCompletion_1, callTimeoutSec_1, entitlementPolicy_1, billingPolicy_1, useRequestedDateForBilling_1, pluginProperty_2, xKillbillReason_2, xKillbillComment_2, ...args_2) => __awaiter(this, [subscriptionId_2, xKillbillCreatedBy_2, requestedDate_2, callCompletion_1, callTimeoutSec_1, entitlementPolicy_1, billingPolicy_1, useRequestedDateForBilling_1, pluginProperty_2, xKillbillReason_2, xKillbillComment_2, ...args_2], void 0, function* (subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, entitlementPolicy, billingPolicy, useRequestedDateForBilling, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('cancelSubscriptionPlan', 'subscriptionId', subscriptionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('cancelSubscriptionPlan', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString().substr(0, 10) :
                    requestedDate;
            }
            if (callCompletion !== undefined) {
                localVarQueryParameter['callCompletion'] = callCompletion;
            }
            if (callTimeoutSec !== undefined) {
                localVarQueryParameter['callTimeoutSec'] = callTimeoutSec;
            }
            if (entitlementPolicy !== undefined) {
                localVarQueryParameter['entitlementPolicy'] = entitlementPolicy;
            }
            if (billingPolicy !== undefined) {
                localVarQueryParameter['billingPolicy'] = billingPolicy;
            }
            if (useRequestedDateForBilling !== undefined) {
                localVarQueryParameter['useRequestedDateForBilling'] = useRequestedDateForBilling;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Change entitlement plan
         * @param {Subscription} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {boolean} [callCompletion]
         * @param {number} [callTimeoutSec]
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscriptionPlan: (body_2, subscriptionId_3, xKillbillCreatedBy_3, requestedDate_3, callCompletion_2, callTimeoutSec_2, billingPolicy_2, pluginProperty_3, xKillbillReason_3, xKillbillComment_3, ...args_3) => __awaiter(this, [body_2, subscriptionId_3, xKillbillCreatedBy_3, requestedDate_3, callCompletion_2, callTimeoutSec_2, billingPolicy_2, pluginProperty_3, xKillbillReason_3, xKillbillComment_3, ...args_3], void 0, function* (body, subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('changeSubscriptionPlan', 'body', body);
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('changeSubscriptionPlan', 'subscriptionId', subscriptionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('changeSubscriptionPlan', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (requestedDate !== undefined) {
                localVarQueryParameter['requestedDate'] = (requestedDate instanceof Date) ?
                    requestedDate.toISOString().substr(0, 10) :
                    requestedDate;
            }
            if (callCompletion !== undefined) {
                localVarQueryParameter['callCompletion'] = callCompletion;
            }
            if (callTimeoutSec !== undefined) {
                localVarQueryParameter['callTimeoutSec'] = callTimeoutSec;
            }
            if (billingPolicy !== undefined) {
                localVarQueryParameter['billingPolicy'] = billingPolicy;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create an subscription
         * @param {Subscription} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [entitlementDate]
         * @param {string} [billingDate]
         * @param {boolean} [renameKeyIfExistsAndUnused]
         * @param {boolean} [migrated]
         * @param {boolean} [skipResponse]
         * @param {boolean} [callCompletion]
         * @param {number} [callTimeoutSec]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription: (body_3, xKillbillCreatedBy_4, entitlementDate_1, billingDate_1, renameKeyIfExistsAndUnused_1, migrated_1, skipResponse_1, callCompletion_3, callTimeoutSec_3, pluginProperty_4, xKillbillReason_4, xKillbillComment_4, ...args_4) => __awaiter(this, [body_3, xKillbillCreatedBy_4, entitlementDate_1, billingDate_1, renameKeyIfExistsAndUnused_1, migrated_1, skipResponse_1, callCompletion_3, callTimeoutSec_3, pluginProperty_4, xKillbillReason_4, xKillbillComment_4, ...args_4], void 0, function* (body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createSubscription', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createSubscription', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (entitlementDate !== undefined) {
                localVarQueryParameter['entitlementDate'] = (entitlementDate instanceof Date) ?
                    entitlementDate.toISOString().substr(0, 10) :
                    entitlementDate;
            }
            if (billingDate !== undefined) {
                localVarQueryParameter['billingDate'] = (billingDate instanceof Date) ?
                    billingDate.toISOString().substr(0, 10) :
                    billingDate;
            }
            if (renameKeyIfExistsAndUnused !== undefined) {
                localVarQueryParameter['renameKeyIfExistsAndUnused'] = renameKeyIfExistsAndUnused;
            }
            if (migrated !== undefined) {
                localVarQueryParameter['migrated'] = migrated;
            }
            if (skipResponse !== undefined) {
                localVarQueryParameter['skipResponse'] = skipResponse;
            }
            if (callCompletion !== undefined) {
                localVarQueryParameter['callCompletion'] = callCompletion;
            }
            if (callTimeoutSec !== undefined) {
                localVarQueryParameter['callTimeoutSec'] = callTimeoutSec;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add custom fields to subscription
         * @param {Array<CustomField>} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionCustomFields: (body_4, subscriptionId_4, xKillbillCreatedBy_5, xKillbillReason_5, xKillbillComment_5, ...args_5) => __awaiter(this, [body_4, subscriptionId_4, xKillbillCreatedBy_5, xKillbillReason_5, xKillbillComment_5, ...args_5], void 0, function* (body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createSubscriptionCustomFields', 'body', body);
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('createSubscriptionCustomFields', 'subscriptionId', subscriptionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createSubscriptionCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/customFields`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @param {Array<string>} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionTags: (body_5, subscriptionId_5, xKillbillCreatedBy_6, xKillbillReason_6, xKillbillComment_6, ...args_6) => __awaiter(this, [body_5, subscriptionId_5, xKillbillCreatedBy_6, xKillbillReason_6, xKillbillComment_6, ...args_6], void 0, function* (body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createSubscriptionTags', 'body', body);
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('createSubscriptionTags', 'subscriptionId', subscriptionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createSubscriptionTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/tags`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create an entitlement with addOn products
         * @param {Array<Subscription>} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [entitlementDate]
         * @param {string} [billingDate]
         * @param {boolean} [migrated]
         * @param {boolean} [skipResponse]
         * @param {boolean} [renameKeyIfExistsAndUnused]
         * @param {boolean} [callCompletion]
         * @param {number} [callTimeoutSec]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionWithAddOns: (body_6, xKillbillCreatedBy_7, entitlementDate_2, billingDate_2, migrated_2, skipResponse_2, renameKeyIfExistsAndUnused_2, callCompletion_4, callTimeoutSec_4, pluginProperty_5, xKillbillReason_7, xKillbillComment_7, ...args_7) => __awaiter(this, [body_6, xKillbillCreatedBy_7, entitlementDate_2, billingDate_2, migrated_2, skipResponse_2, renameKeyIfExistsAndUnused_2, callCompletion_4, callTimeoutSec_4, pluginProperty_5, xKillbillReason_7, xKillbillComment_7, ...args_7], void 0, function* (body, xKillbillCreatedBy, entitlementDate, billingDate, migrated, skipResponse, renameKeyIfExistsAndUnused, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createSubscriptionWithAddOns', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createSubscriptionWithAddOns', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/subscriptions/createSubscriptionWithAddOns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (entitlementDate !== undefined) {
                localVarQueryParameter['entitlementDate'] = (entitlementDate instanceof Date) ?
                    entitlementDate.toISOString().substr(0, 10) :
                    entitlementDate;
            }
            if (billingDate !== undefined) {
                localVarQueryParameter['billingDate'] = (billingDate instanceof Date) ?
                    billingDate.toISOString().substr(0, 10) :
                    billingDate;
            }
            if (migrated !== undefined) {
                localVarQueryParameter['migrated'] = migrated;
            }
            if (skipResponse !== undefined) {
                localVarQueryParameter['skipResponse'] = skipResponse;
            }
            if (renameKeyIfExistsAndUnused !== undefined) {
                localVarQueryParameter['renameKeyIfExistsAndUnused'] = renameKeyIfExistsAndUnused;
            }
            if (callCompletion !== undefined) {
                localVarQueryParameter['callCompletion'] = callCompletion;
            }
            if (callTimeoutSec !== undefined) {
                localVarQueryParameter['callTimeoutSec'] = callTimeoutSec;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create multiple entitlements with addOn products
         * @param {Array<BulkSubscriptionsBundle>} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [entitlementDate]
         * @param {string} [billingDate]
         * @param {boolean} [renameKeyIfExistsAndUnused]
         * @param {boolean} [migrated]
         * @param {boolean} [skipResponse]
         * @param {boolean} [callCompletion]
         * @param {number} [callTimeoutSec]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionsWithAddOns: (body_7, xKillbillCreatedBy_8, entitlementDate_3, billingDate_3, renameKeyIfExistsAndUnused_3, migrated_3, skipResponse_3, callCompletion_5, callTimeoutSec_5, pluginProperty_6, xKillbillReason_8, xKillbillComment_8, ...args_8) => __awaiter(this, [body_7, xKillbillCreatedBy_8, entitlementDate_3, billingDate_3, renameKeyIfExistsAndUnused_3, migrated_3, skipResponse_3, callCompletion_5, callTimeoutSec_5, pluginProperty_6, xKillbillReason_8, xKillbillComment_8, ...args_8], void 0, function* (body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createSubscriptionsWithAddOns', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createSubscriptionsWithAddOns', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/subscriptions/createSubscriptionsWithAddOns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (entitlementDate !== undefined) {
                localVarQueryParameter['entitlementDate'] = (entitlementDate instanceof Date) ?
                    entitlementDate.toISOString().substr(0, 10) :
                    entitlementDate;
            }
            if (billingDate !== undefined) {
                localVarQueryParameter['billingDate'] = (billingDate instanceof Date) ?
                    billingDate.toISOString().substr(0, 10) :
                    billingDate;
            }
            if (renameKeyIfExistsAndUnused !== undefined) {
                localVarQueryParameter['renameKeyIfExistsAndUnused'] = renameKeyIfExistsAndUnused;
            }
            if (migrated !== undefined) {
                localVarQueryParameter['migrated'] = migrated;
            }
            if (skipResponse !== undefined) {
                localVarQueryParameter['skipResponse'] = skipResponse;
            }
            if (callCompletion !== undefined) {
                localVarQueryParameter['callCompletion'] = callCompletion;
            }
            if (callTimeoutSec !== undefined) {
                localVarQueryParameter['callTimeoutSec'] = callTimeoutSec;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove custom fields from subscription
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionCustomFields: (subscriptionId_6, xKillbillCreatedBy_9, customField_1, xKillbillReason_9, xKillbillComment_9, ...args_9) => __awaiter(this, [subscriptionId_6, xKillbillCreatedBy_9, customField_1, xKillbillReason_9, xKillbillComment_9, ...args_9], void 0, function* (subscriptionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('deleteSubscriptionCustomFields', 'subscriptionId', subscriptionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteSubscriptionCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/customFields`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (customField) {
                localVarQueryParameter['customField'] = customField;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Remove tags from subscription
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionTags: (subscriptionId_7, xKillbillCreatedBy_10, tagDef_1, xKillbillReason_10, xKillbillComment_10, ...args_10) => __awaiter(this, [subscriptionId_7, xKillbillCreatedBy_10, tagDef_1, xKillbillReason_10, xKillbillComment_10, ...args_10], void 0, function* (subscriptionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('deleteSubscriptionTags', 'subscriptionId', subscriptionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteSubscriptionTags', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/tags`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (tagDef) {
                localVarQueryParameter['tagDef'] = tagDef;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a subscription by id
         * @param {string} subscriptionId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription: (subscriptionId_8, audit_1, ...args_11) => __awaiter(this, [subscriptionId_8, audit_1, ...args_11], void 0, function* (subscriptionId, audit, options = {}) {
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('getSubscription', 'subscriptionId', subscriptionId);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve subscription audit logs with history by id
         * @param {string} subscriptionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionAuditLogsWithHistory: (subscriptionId_9, ...args_12) => __awaiter(this, [subscriptionId_9, ...args_12], void 0, function* (subscriptionId, options = {}) {
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('getSubscriptionAuditLogsWithHistory', 'subscriptionId', subscriptionId);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/auditLogsWithHistory`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a subscription by external key
         * @param {string} externalKey
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionByKey: (externalKey_1, audit_2, ...args_13) => __awaiter(this, [externalKey_1, audit_2, ...args_13], void 0, function* (externalKey, audit, options = {}) {
            // verify required parameter 'externalKey' is not null or undefined
            (0, common_1.assertParamExists)('getSubscriptionByKey', 'externalKey', externalKey);
            const localVarPath = `/1.0/kb/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (externalKey !== undefined) {
                localVarQueryParameter['externalKey'] = externalKey;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve subscription custom fields
         * @param {string} subscriptionId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionCustomFields: (subscriptionId_10, audit_3, ...args_14) => __awaiter(this, [subscriptionId_10, audit_3, ...args_14], void 0, function* (subscriptionId, audit, options = {}) {
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('getSubscriptionCustomFields', 'subscriptionId', subscriptionId);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/customFields`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve subscription event audit logs with history by id
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionEventAuditLogsWithHistory: (eventId_1, ...args_15) => __awaiter(this, [eventId_1, ...args_15], void 0, function* (eventId, options = {}) {
            // verify required parameter 'eventId' is not null or undefined
            (0, common_1.assertParamExists)('getSubscriptionEventAuditLogsWithHistory', 'eventId', eventId);
            const localVarPath = `/1.0/kb/subscriptions/events/{eventId}/auditLogsWithHistory`
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve subscription tags
         * @param {string} subscriptionId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTags: (subscriptionId_11, includedDeleted_1, audit_4, ...args_16) => __awaiter(this, [subscriptionId_11, includedDeleted_1, audit_4, ...args_16], void 0, function* (subscriptionId, includedDeleted, audit, options = {}) {
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('getSubscriptionTags', 'subscriptionId', subscriptionId);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/tags`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (includedDeleted !== undefined) {
                localVarQueryParameter['includedDeleted'] = includedDeleted;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Modify custom fields to subscription
         * @param {Array<CustomField>} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionCustomFields: (body_8, subscriptionId_12, xKillbillCreatedBy_11, xKillbillReason_11, xKillbillComment_11, ...args_17) => __awaiter(this, [body_8, subscriptionId_12, xKillbillCreatedBy_11, xKillbillReason_11, xKillbillComment_11, ...args_17], void 0, function* (body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('modifySubscriptionCustomFields', 'body', body);
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('modifySubscriptionCustomFields', 'subscriptionId', subscriptionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('modifySubscriptionCustomFields', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/customFields`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Un-cancel an entitlement
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uncancelSubscriptionPlan: (subscriptionId_13, xKillbillCreatedBy_12, pluginProperty_7, xKillbillReason_12, xKillbillComment_12, ...args_18) => __awaiter(this, [subscriptionId_13, xKillbillCreatedBy_12, pluginProperty_7, xKillbillReason_12, xKillbillComment_12, ...args_18], void 0, function* (subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('uncancelSubscriptionPlan', 'subscriptionId', subscriptionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('uncancelSubscriptionPlan', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/uncancel`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Undo a pending change plan on an entitlement
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undoChangeSubscriptionPlan: (subscriptionId_14, xKillbillCreatedBy_13, pluginProperty_8, xKillbillReason_13, xKillbillComment_13, ...args_19) => __awaiter(this, [subscriptionId_14, xKillbillCreatedBy_13, pluginProperty_8, xKillbillReason_13, xKillbillComment_13, ...args_19], void 0, function* (subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('undoChangeSubscriptionPlan', 'subscriptionId', subscriptionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('undoChangeSubscriptionPlan', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/undoChangePlan`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update the BCD associated to a subscription
         * @param {Subscription} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [effectiveFromDate]
         * @param {boolean} [forceNewBcdWithPastEffectiveDate]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionBCD: (body_9, subscriptionId_15, xKillbillCreatedBy_14, effectiveFromDate_1, forceNewBcdWithPastEffectiveDate_1, xKillbillReason_14, xKillbillComment_14, ...args_20) => __awaiter(this, [body_9, subscriptionId_15, xKillbillCreatedBy_14, effectiveFromDate_1, forceNewBcdWithPastEffectiveDate_1, xKillbillReason_14, xKillbillComment_14, ...args_20], void 0, function* (body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewBcdWithPastEffectiveDate, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateSubscriptionBCD', 'body', body);
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('updateSubscriptionBCD', 'subscriptionId', subscriptionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('updateSubscriptionBCD', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/bcd`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (effectiveFromDate !== undefined) {
                localVarQueryParameter['effectiveFromDate'] = (effectiveFromDate instanceof Date) ?
                    effectiveFromDate.toISOString().substr(0, 10) :
                    effectiveFromDate;
            }
            if (forceNewBcdWithPastEffectiveDate !== undefined) {
                localVarQueryParameter['forceNewBcdWithPastEffectiveDate'] = forceNewBcdWithPastEffectiveDate;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Update the quantity associated to a subscription
         * @param {Subscription} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [effectiveFromDate]
         * @param {boolean} [forceNewQuantityWithPastEffectiveDate]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionQuantity: (body_10, subscriptionId_16, xKillbillCreatedBy_15, effectiveFromDate_2, forceNewQuantityWithPastEffectiveDate_1, xKillbillReason_15, xKillbillComment_15, ...args_21) => __awaiter(this, [body_10, subscriptionId_16, xKillbillCreatedBy_15, effectiveFromDate_2, forceNewQuantityWithPastEffectiveDate_1, xKillbillReason_15, xKillbillComment_15, ...args_21], void 0, function* (body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewQuantityWithPastEffectiveDate, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('updateSubscriptionQuantity', 'body', body);
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('updateSubscriptionQuantity', 'subscriptionId', subscriptionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('updateSubscriptionQuantity', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/subscriptions/{subscriptionId}/quantity`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (effectiveFromDate !== undefined) {
                localVarQueryParameter['effectiveFromDate'] = (effectiveFromDate instanceof Date) ?
                    effectiveFromDate.toISOString().substr(0, 10) :
                    effectiveFromDate;
            }
            if (forceNewQuantityWithPastEffectiveDate !== undefined) {
                localVarQueryParameter['forceNewQuantityWithPastEffectiveDate'] = forceNewQuantityWithPastEffectiveDate;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SubscriptionApiAxiosParamCreator = SubscriptionApiAxiosParamCreator;
/**
 * SubscriptionApi - functional programming interface
 * @export
 */
const SubscriptionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SubscriptionApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Block a subscription
         * @param {BlockingState} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscriptionBlockingState(body, subscriptionId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.addSubscriptionBlockingState(body, subscriptionId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Cancel an entitlement plan
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {boolean} [callCompletion]
         * @param {number} [callTimeoutSec]
         * @param {'IMMEDIATE' | 'END_OF_TERM'} [entitlementPolicy]
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy]
         * @param {boolean} [useRequestedDateForBilling]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, entitlementPolicy, billingPolicy, useRequestedDateForBilling, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.cancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, entitlementPolicy, billingPolicy, useRequestedDateForBilling, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Change entitlement plan
         * @param {Subscription} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {boolean} [callCompletion]
         * @param {number} [callTimeoutSec]
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscriptionPlan(body, subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.changeSubscriptionPlan(body, subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Create an subscription
         * @param {Subscription} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [entitlementDate]
         * @param {string} [billingDate]
         * @param {boolean} [renameKeyIfExistsAndUnused]
         * @param {boolean} [migrated]
         * @param {boolean} [skipResponse]
         * @param {boolean} [callCompletion]
         * @param {number} [callTimeoutSec]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createSubscription(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add custom fields to subscription
         * @param {Array<CustomField>} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createSubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @param {Array<string>} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionTags(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createSubscriptionTags(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Create an entitlement with addOn products
         * @param {Array<Subscription>} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [entitlementDate]
         * @param {string} [billingDate]
         * @param {boolean} [migrated]
         * @param {boolean} [skipResponse]
         * @param {boolean} [renameKeyIfExistsAndUnused]
         * @param {boolean} [callCompletion]
         * @param {number} [callTimeoutSec]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, migrated, skipResponse, renameKeyIfExistsAndUnused, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createSubscriptionWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, migrated, skipResponse, renameKeyIfExistsAndUnused, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Create multiple entitlements with addOn products
         * @param {Array<BulkSubscriptionsBundle>} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [entitlementDate]
         * @param {string} [billingDate]
         * @param {boolean} [renameKeyIfExistsAndUnused]
         * @param {boolean} [migrated]
         * @param {boolean} [skipResponse]
         * @param {boolean} [callCompletion]
         * @param {number} [callTimeoutSec]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionsWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createSubscriptionsWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove custom fields from subscription
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionCustomFields(subscriptionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteSubscriptionCustomFields(subscriptionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Remove tags from subscription
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionTags(subscriptionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteSubscriptionTags(subscriptionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a subscription by id
         * @param {string} subscriptionId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(subscriptionId, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSubscription(subscriptionId, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve subscription audit logs with history by id
         * @param {string} subscriptionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionAuditLogsWithHistory(subscriptionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSubscriptionAuditLogsWithHistory(subscriptionId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a subscription by external key
         * @param {string} externalKey
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionByKey(externalKey, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSubscriptionByKey(externalKey, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve subscription custom fields
         * @param {string} subscriptionId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionCustomFields(subscriptionId, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSubscriptionCustomFields(subscriptionId, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve subscription event audit logs with history by id
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionEventAuditLogsWithHistory(eventId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSubscriptionEventAuditLogsWithHistory(eventId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve subscription tags
         * @param {string} subscriptionId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTags(subscriptionId, includedDeleted, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getSubscriptionTags(subscriptionId, includedDeleted, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Modify custom fields to subscription
         * @param {Array<CustomField>} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.modifySubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Un-cancel an entitlement
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uncancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uncancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Undo a pending change plan on an entitlement
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undoChangeSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.undoChangeSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Update the BCD associated to a subscription
         * @param {Subscription} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [effectiveFromDate]
         * @param {boolean} [forceNewBcdWithPastEffectiveDate]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionBCD(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewBcdWithPastEffectiveDate, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateSubscriptionBCD(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewBcdWithPastEffectiveDate, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Update the quantity associated to a subscription
         * @param {Subscription} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [effectiveFromDate]
         * @param {boolean} [forceNewQuantityWithPastEffectiveDate]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionQuantity(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewQuantityWithPastEffectiveDate, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.updateSubscriptionQuantity(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewQuantityWithPastEffectiveDate, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.SubscriptionApiFp = SubscriptionApiFp;
/**
 * SubscriptionApi - factory interface
 * @export
 */
const SubscriptionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SubscriptionApiFp)(configuration);
    return {
        /**
         *
         * @summary Block a subscription
         * @param {BlockingState} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addSubscriptionBlockingState(body, subscriptionId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.addSubscriptionBlockingState(body, subscriptionId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Cancel an entitlement plan
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {boolean} [callCompletion]
         * @param {number} [callTimeoutSec]
         * @param {'IMMEDIATE' | 'END_OF_TERM'} [entitlementPolicy]
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy]
         * @param {boolean} [useRequestedDateForBilling]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, entitlementPolicy, billingPolicy, useRequestedDateForBilling, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.cancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, entitlementPolicy, billingPolicy, useRequestedDateForBilling, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Change entitlement plan
         * @param {Subscription} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [requestedDate]
         * @param {boolean} [callCompletion]
         * @param {number} [callTimeoutSec]
         * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeSubscriptionPlan(body, subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.changeSubscriptionPlan(body, subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create an subscription
         * @param {Subscription} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [entitlementDate]
         * @param {string} [billingDate]
         * @param {boolean} [renameKeyIfExistsAndUnused]
         * @param {boolean} [migrated]
         * @param {boolean} [skipResponse]
         * @param {boolean} [callCompletion]
         * @param {number} [callTimeoutSec]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscription(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createSubscription(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add custom fields to subscription
         * @param {Array<CustomField>} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createSubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @param {Array<string>} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionTags(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createSubscriptionTags(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create an entitlement with addOn products
         * @param {Array<Subscription>} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [entitlementDate]
         * @param {string} [billingDate]
         * @param {boolean} [migrated]
         * @param {boolean} [skipResponse]
         * @param {boolean} [renameKeyIfExistsAndUnused]
         * @param {boolean} [callCompletion]
         * @param {number} [callTimeoutSec]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, migrated, skipResponse, renameKeyIfExistsAndUnused, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createSubscriptionWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, migrated, skipResponse, renameKeyIfExistsAndUnused, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create multiple entitlements with addOn products
         * @param {Array<BulkSubscriptionsBundle>} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [entitlementDate]
         * @param {string} [billingDate]
         * @param {boolean} [renameKeyIfExistsAndUnused]
         * @param {boolean} [migrated]
         * @param {boolean} [skipResponse]
         * @param {boolean} [callCompletion]
         * @param {number} [callTimeoutSec]
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSubscriptionsWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createSubscriptionsWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove custom fields from subscription
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [customField]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionCustomFields(subscriptionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteSubscriptionCustomFields(subscriptionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove tags from subscription
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [tagDef]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSubscriptionTags(subscriptionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteSubscriptionTags(subscriptionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a subscription by id
         * @param {string} subscriptionId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscription(subscriptionId, audit, options) {
            return localVarFp.getSubscription(subscriptionId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve subscription audit logs with history by id
         * @param {string} subscriptionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionAuditLogsWithHistory(subscriptionId, options) {
            return localVarFp.getSubscriptionAuditLogsWithHistory(subscriptionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a subscription by external key
         * @param {string} externalKey
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionByKey(externalKey, audit, options) {
            return localVarFp.getSubscriptionByKey(externalKey, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve subscription custom fields
         * @param {string} subscriptionId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionCustomFields(subscriptionId, audit, options) {
            return localVarFp.getSubscriptionCustomFields(subscriptionId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve subscription event audit logs with history by id
         * @param {string} eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionEventAuditLogsWithHistory(eventId, options) {
            return localVarFp.getSubscriptionEventAuditLogsWithHistory(eventId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve subscription tags
         * @param {string} subscriptionId
         * @param {boolean} [includedDeleted]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTags(subscriptionId, includedDeleted, audit, options) {
            return localVarFp.getSubscriptionTags(subscriptionId, includedDeleted, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Modify custom fields to subscription
         * @param {Array<CustomField>} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifySubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.modifySubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Un-cancel an entitlement
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uncancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.uncancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Undo a pending change plan on an entitlement
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {Array<string>} [pluginProperty]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        undoChangeSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options) {
            return localVarFp.undoChangeSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update the BCD associated to a subscription
         * @param {Subscription} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [effectiveFromDate]
         * @param {boolean} [forceNewBcdWithPastEffectiveDate]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionBCD(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewBcdWithPastEffectiveDate, xKillbillReason, xKillbillComment, options) {
            return localVarFp.updateSubscriptionBCD(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewBcdWithPastEffectiveDate, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update the quantity associated to a subscription
         * @param {Subscription} body
         * @param {string} subscriptionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [effectiveFromDate]
         * @param {boolean} [forceNewQuantityWithPastEffectiveDate]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSubscriptionQuantity(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewQuantityWithPastEffectiveDate, xKillbillReason, xKillbillComment, options) {
            return localVarFp.updateSubscriptionQuantity(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewQuantityWithPastEffectiveDate, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.SubscriptionApiFactory = SubscriptionApiFactory;
/**
 * SubscriptionApi - object-oriented interface
 * @export
 * @class SubscriptionApi
 * @extends {BaseAPI}
 */
class SubscriptionApi extends base_1.BaseAPI {
    /**
     *
     * @summary Block a subscription
     * @param {BlockingState} body
     * @param {string} subscriptionId
     * @param {string} xKillbillCreatedBy
     * @param {string} [requestedDate]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    addSubscriptionBlockingState(body, subscriptionId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).addSubscriptionBlockingState(body, subscriptionId, xKillbillCreatedBy, requestedDate, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Cancel an entitlement plan
     * @param {string} subscriptionId
     * @param {string} xKillbillCreatedBy
     * @param {string} [requestedDate]
     * @param {boolean} [callCompletion]
     * @param {number} [callTimeoutSec]
     * @param {'IMMEDIATE' | 'END_OF_TERM'} [entitlementPolicy]
     * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy]
     * @param {boolean} [useRequestedDateForBilling]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    cancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, entitlementPolicy, billingPolicy, useRequestedDateForBilling, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).cancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, entitlementPolicy, billingPolicy, useRequestedDateForBilling, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Change entitlement plan
     * @param {Subscription} body
     * @param {string} subscriptionId
     * @param {string} xKillbillCreatedBy
     * @param {string} [requestedDate]
     * @param {boolean} [callCompletion]
     * @param {number} [callTimeoutSec]
     * @param {'START_OF_TERM' | 'END_OF_TERM' | 'IMMEDIATE' | 'ILLEGAL'} [billingPolicy]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    changeSubscriptionPlan(body, subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).changeSubscriptionPlan(body, subscriptionId, xKillbillCreatedBy, requestedDate, callCompletion, callTimeoutSec, billingPolicy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create an subscription
     * @param {Subscription} body
     * @param {string} xKillbillCreatedBy
     * @param {string} [entitlementDate]
     * @param {string} [billingDate]
     * @param {boolean} [renameKeyIfExistsAndUnused]
     * @param {boolean} [migrated]
     * @param {boolean} [skipResponse]
     * @param {boolean} [callCompletion]
     * @param {number} [callTimeoutSec]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    createSubscription(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).createSubscription(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add custom fields to subscription
     * @param {Array<CustomField>} body
     * @param {string} subscriptionId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    createSubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).createSubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @param {Array<string>} body
     * @param {string} subscriptionId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    createSubscriptionTags(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).createSubscriptionTags(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create an entitlement with addOn products
     * @param {Array<Subscription>} body
     * @param {string} xKillbillCreatedBy
     * @param {string} [entitlementDate]
     * @param {string} [billingDate]
     * @param {boolean} [migrated]
     * @param {boolean} [skipResponse]
     * @param {boolean} [renameKeyIfExistsAndUnused]
     * @param {boolean} [callCompletion]
     * @param {number} [callTimeoutSec]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    createSubscriptionWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, migrated, skipResponse, renameKeyIfExistsAndUnused, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).createSubscriptionWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, migrated, skipResponse, renameKeyIfExistsAndUnused, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create multiple entitlements with addOn products
     * @param {Array<BulkSubscriptionsBundle>} body
     * @param {string} xKillbillCreatedBy
     * @param {string} [entitlementDate]
     * @param {string} [billingDate]
     * @param {boolean} [renameKeyIfExistsAndUnused]
     * @param {boolean} [migrated]
     * @param {boolean} [skipResponse]
     * @param {boolean} [callCompletion]
     * @param {number} [callTimeoutSec]
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    createSubscriptionsWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).createSubscriptionsWithAddOns(body, xKillbillCreatedBy, entitlementDate, billingDate, renameKeyIfExistsAndUnused, migrated, skipResponse, callCompletion, callTimeoutSec, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove custom fields from subscription
     * @param {string} subscriptionId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [customField]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    deleteSubscriptionCustomFields(subscriptionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).deleteSubscriptionCustomFields(subscriptionId, xKillbillCreatedBy, customField, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove tags from subscription
     * @param {string} subscriptionId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [tagDef]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    deleteSubscriptionTags(subscriptionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).deleteSubscriptionTags(subscriptionId, xKillbillCreatedBy, tagDef, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a subscription by id
     * @param {string} subscriptionId
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    getSubscription(subscriptionId, audit, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).getSubscription(subscriptionId, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve subscription audit logs with history by id
     * @param {string} subscriptionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    getSubscriptionAuditLogsWithHistory(subscriptionId, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).getSubscriptionAuditLogsWithHistory(subscriptionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a subscription by external key
     * @param {string} externalKey
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    getSubscriptionByKey(externalKey, audit, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).getSubscriptionByKey(externalKey, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve subscription custom fields
     * @param {string} subscriptionId
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    getSubscriptionCustomFields(subscriptionId, audit, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).getSubscriptionCustomFields(subscriptionId, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve subscription event audit logs with history by id
     * @param {string} eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    getSubscriptionEventAuditLogsWithHistory(eventId, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).getSubscriptionEventAuditLogsWithHistory(eventId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve subscription tags
     * @param {string} subscriptionId
     * @param {boolean} [includedDeleted]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    getSubscriptionTags(subscriptionId, includedDeleted, audit, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).getSubscriptionTags(subscriptionId, includedDeleted, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Modify custom fields to subscription
     * @param {Array<CustomField>} body
     * @param {string} subscriptionId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    modifySubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).modifySubscriptionCustomFields(body, subscriptionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Un-cancel an entitlement
     * @param {string} subscriptionId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    uncancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).uncancelSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Undo a pending change plan on an entitlement
     * @param {string} subscriptionId
     * @param {string} xKillbillCreatedBy
     * @param {Array<string>} [pluginProperty]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    undoChangeSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).undoChangeSubscriptionPlan(subscriptionId, xKillbillCreatedBy, pluginProperty, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update the BCD associated to a subscription
     * @param {Subscription} body
     * @param {string} subscriptionId
     * @param {string} xKillbillCreatedBy
     * @param {string} [effectiveFromDate]
     * @param {boolean} [forceNewBcdWithPastEffectiveDate]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    updateSubscriptionBCD(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewBcdWithPastEffectiveDate, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).updateSubscriptionBCD(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewBcdWithPastEffectiveDate, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update the quantity associated to a subscription
     * @param {Subscription} body
     * @param {string} subscriptionId
     * @param {string} xKillbillCreatedBy
     * @param {string} [effectiveFromDate]
     * @param {boolean} [forceNewQuantityWithPastEffectiveDate]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionApi
     */
    updateSubscriptionQuantity(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewQuantityWithPastEffectiveDate, xKillbillReason, xKillbillComment, options) {
        return (0, exports.SubscriptionApiFp)(this.configuration).updateSubscriptionQuantity(body, subscriptionId, xKillbillCreatedBy, effectiveFromDate, forceNewQuantityWithPastEffectiveDate, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.SubscriptionApi = SubscriptionApi;
/**
 * TagApi - axios parameter creator
 * @export
 */
const TagApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Retrieve tag audit logs with history by id
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAuditLogsWithHistory: (tagId_1, ...args_1) => __awaiter(this, [tagId_1, ...args_1], void 0, function* (tagId, options = {}) {
            // verify required parameter 'tagId' is not null or undefined
            (0, common_1.assertParamExists)('getTagAuditLogsWithHistory', 'tagId', tagId);
            const localVarPath = `/1.0/kb/tags/{tagId}/auditLogsWithHistory`
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List tags
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags: (offset_1, limit_1, audit_1, ...args_2) => __awaiter(this, [offset_1, limit_1, audit_1, ...args_2], void 0, function* (offset, limit, audit, options = {}) {
            const localVarPath = `/1.0/kb/tags/pagination`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Search tags
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTags: (searchKey_1, offset_2, limit_2, audit_2, ...args_3) => __awaiter(this, [searchKey_1, offset_2, limit_2, audit_2, ...args_3], void 0, function* (searchKey, offset, limit, audit, options = {}) {
            // verify required parameter 'searchKey' is not null or undefined
            (0, common_1.assertParamExists)('searchTags', 'searchKey', searchKey);
            const localVarPath = `/1.0/kb/tags/search/{searchKey}`
                .replace(`{${"searchKey"}}`, encodeURIComponent(String(searchKey)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TagApiAxiosParamCreator = TagApiAxiosParamCreator;
/**
 * TagApi - functional programming interface
 * @export
 */
const TagApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TagApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve tag audit logs with history by id
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAuditLogsWithHistory(tagId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTagAuditLogsWithHistory(tagId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List tags
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(offset, limit, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTags(offset, limit, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Search tags
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTags(searchKey, offset, limit, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.searchTags(searchKey, offset, limit, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TagApiFp = TagApiFp;
/**
 * TagApi - factory interface
 * @export
 */
const TagApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TagApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve tag audit logs with history by id
         * @param {string} tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagAuditLogsWithHistory(tagId, options) {
            return localVarFp.getTagAuditLogsWithHistory(tagId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List tags
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(offset, limit, audit, options) {
            return localVarFp.getTags(offset, limit, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Search tags
         * @param {string} searchKey
         * @param {number} [offset]
         * @param {number} [limit]
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTags(searchKey, offset, limit, audit, options) {
            return localVarFp.searchTags(searchKey, offset, limit, audit, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TagApiFactory = TagApiFactory;
/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
class TagApi extends base_1.BaseAPI {
    /**
     *
     * @summary Retrieve tag audit logs with history by id
     * @param {string} tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    getTagAuditLogsWithHistory(tagId, options) {
        return (0, exports.TagApiFp)(this.configuration).getTagAuditLogsWithHistory(tagId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List tags
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    getTags(offset, limit, audit, options) {
        return (0, exports.TagApiFp)(this.configuration).getTags(offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Search tags
     * @param {string} searchKey
     * @param {number} [offset]
     * @param {number} [limit]
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    searchTags(searchKey, offset, limit, audit, options) {
        return (0, exports.TagApiFp)(this.configuration).searchTags(searchKey, offset, limit, audit, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TagApi = TagApi;
/**
 * TagDefinitionApi - axios parameter creator
 * @export
 */
const TagDefinitionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a tag definition
         * @param {TagDefinition} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTagDefinition: (body_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [body_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createTagDefinition', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createTagDefinition', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/tagDefinitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a tag definition
         * @param {string} tagDefinitionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagDefinition: (tagDefinitionId_1, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2) => __awaiter(this, [tagDefinitionId_1, xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2], void 0, function* (tagDefinitionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'tagDefinitionId' is not null or undefined
            (0, common_1.assertParamExists)('deleteTagDefinition', 'tagDefinitionId', tagDefinitionId);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteTagDefinition', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/tagDefinitions/{tagDefinitionId}`
                .replace(`{${"tagDefinitionId"}}`, encodeURIComponent(String(tagDefinitionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a tag definition
         * @param {string} tagDefinitionId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinition: (tagDefinitionId_2, audit_1, ...args_3) => __awaiter(this, [tagDefinitionId_2, audit_1, ...args_3], void 0, function* (tagDefinitionId, audit, options = {}) {
            // verify required parameter 'tagDefinitionId' is not null or undefined
            (0, common_1.assertParamExists)('getTagDefinition', 'tagDefinitionId', tagDefinitionId);
            const localVarPath = `/1.0/kb/tagDefinitions/{tagDefinitionId}`
                .replace(`{${"tagDefinitionId"}}`, encodeURIComponent(String(tagDefinitionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve tag definition audit logs with history by id
         * @param {string} tagDefinitionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinitionAuditLogsWithHistory: (tagDefinitionId_3, ...args_4) => __awaiter(this, [tagDefinitionId_3, ...args_4], void 0, function* (tagDefinitionId, options = {}) {
            // verify required parameter 'tagDefinitionId' is not null or undefined
            (0, common_1.assertParamExists)('getTagDefinitionAuditLogsWithHistory', 'tagDefinitionId', tagDefinitionId);
            const localVarPath = `/1.0/kb/tagDefinitions/{tagDefinitionId}/auditLogsWithHistory`
                .replace(`{${"tagDefinitionId"}}`, encodeURIComponent(String(tagDefinitionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary List tag definitions
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinitions: (audit_2, ...args_5) => __awaiter(this, [audit_2, ...args_5], void 0, function* (audit, options = {}) {
            const localVarPath = `/1.0/kb/tagDefinitions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (audit !== undefined) {
                localVarQueryParameter['audit'] = audit;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TagDefinitionApiAxiosParamCreator = TagDefinitionApiAxiosParamCreator;
/**
 * TagDefinitionApi - functional programming interface
 * @export
 */
const TagDefinitionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TagDefinitionApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a tag definition
         * @param {TagDefinition} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTagDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTagDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Delete a tag definition
         * @param {string} tagDefinitionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagDefinition(tagDefinitionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteTagDefinition(tagDefinitionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a tag definition
         * @param {string} tagDefinitionId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinition(tagDefinitionId, audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTagDefinition(tagDefinitionId, audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve tag definition audit logs with history by id
         * @param {string} tagDefinitionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinitionAuditLogsWithHistory(tagDefinitionId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTagDefinitionAuditLogsWithHistory(tagDefinitionId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary List tag definitions
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinitions(audit, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTagDefinitions(audit, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TagDefinitionApiFp = TagDefinitionApiFp;
/**
 * TagDefinitionApi - factory interface
 * @export
 */
const TagDefinitionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TagDefinitionApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a tag definition
         * @param {TagDefinition} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTagDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createTagDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a tag definition
         * @param {string} tagDefinitionId
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagDefinition(tagDefinitionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteTagDefinition(tagDefinitionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a tag definition
         * @param {string} tagDefinitionId
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinition(tagDefinitionId, audit, options) {
            return localVarFp.getTagDefinition(tagDefinitionId, audit, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve tag definition audit logs with history by id
         * @param {string} tagDefinitionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinitionAuditLogsWithHistory(tagDefinitionId, options) {
            return localVarFp.getTagDefinitionAuditLogsWithHistory(tagDefinitionId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary List tag definitions
         * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagDefinitions(audit, options) {
            return localVarFp.getTagDefinitions(audit, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TagDefinitionApiFactory = TagDefinitionApiFactory;
/**
 * TagDefinitionApi - object-oriented interface
 * @export
 * @class TagDefinitionApi
 * @extends {BaseAPI}
 */
class TagDefinitionApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create a tag definition
     * @param {TagDefinition} body
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDefinitionApi
     */
    createTagDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.TagDefinitionApiFp)(this.configuration).createTagDefinition(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a tag definition
     * @param {string} tagDefinitionId
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDefinitionApi
     */
    deleteTagDefinition(tagDefinitionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.TagDefinitionApiFp)(this.configuration).deleteTagDefinition(tagDefinitionId, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a tag definition
     * @param {string} tagDefinitionId
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDefinitionApi
     */
    getTagDefinition(tagDefinitionId, audit, options) {
        return (0, exports.TagDefinitionApiFp)(this.configuration).getTagDefinition(tagDefinitionId, audit, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve tag definition audit logs with history by id
     * @param {string} tagDefinitionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDefinitionApi
     */
    getTagDefinitionAuditLogsWithHistory(tagDefinitionId, options) {
        return (0, exports.TagDefinitionApiFp)(this.configuration).getTagDefinitionAuditLogsWithHistory(tagDefinitionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary List tag definitions
     * @param {'FULL' | 'MINIMAL' | 'NONE'} [audit]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagDefinitionApi
     */
    getTagDefinitions(audit, options) {
        return (0, exports.TagDefinitionApiFp)(this.configuration).getTagDefinitions(audit, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TagDefinitionApi = TagDefinitionApi;
/**
 * TenantApi - axios parameter creator
 * @export
 */
const TenantApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a tenant
         * @param {Tenant} body
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [useGlobalDefault]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant: (body_1, xKillbillCreatedBy_1, useGlobalDefault_1, xKillbillReason_1, xKillbillComment_1, ...args_1) => __awaiter(this, [body_1, xKillbillCreatedBy_1, useGlobalDefault_1, xKillbillReason_1, xKillbillComment_1, ...args_1], void 0, function* (body, xKillbillCreatedBy, useGlobalDefault, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('createTenant', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('createTenant', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (useGlobalDefault !== undefined) {
                localVarQueryParameter['useGlobalDefault'] = useGlobalDefault;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a per tenant configuration (system properties)
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerTenantConfiguration: (xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2) => __awaiter(this, [xKillbillCreatedBy_2, xKillbillReason_2, xKillbillComment_2, ...args_2], void 0, function* (xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deletePerTenantConfiguration', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/tenants/uploadPerTenantConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a per tenant configuration for a plugin
         * @param {string} pluginName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginConfiguration: (pluginName_1, xKillbillCreatedBy_3, xKillbillReason_3, xKillbillComment_3, ...args_3) => __awaiter(this, [pluginName_1, xKillbillCreatedBy_3, xKillbillReason_3, xKillbillComment_3, ...args_3], void 0, function* (pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'pluginName' is not null or undefined
            (0, common_1.assertParamExists)('deletePluginConfiguration', 'pluginName', pluginName);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deletePluginConfiguration', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/tenants/uploadPluginConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a per tenant payment state machine for a plugin
         * @param {string} pluginName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginPaymentStateMachineConfig: (pluginName_2, xKillbillCreatedBy_4, xKillbillReason_4, xKillbillComment_4, ...args_4) => __awaiter(this, [pluginName_2, xKillbillCreatedBy_4, xKillbillReason_4, xKillbillComment_4, ...args_4], void 0, function* (pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'pluginName' is not null or undefined
            (0, common_1.assertParamExists)('deletePluginPaymentStateMachineConfig', 'pluginName', pluginName);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deletePluginPaymentStateMachineConfig', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/tenants/uploadPluginPaymentStateMachineConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete a push notification
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePushNotificationCallbacks: (xKillbillCreatedBy_5, xKillbillReason_5, xKillbillComment_5, ...args_5) => __awaiter(this, [xKillbillCreatedBy_5, xKillbillReason_5, xKillbillComment_5, ...args_5], void 0, function* (xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deletePushNotificationCallbacks', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/tenants/registerNotificationCallback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Delete  a per tenant user key/value
         * @param {string} keyName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKeyValue: (keyName_1, xKillbillCreatedBy_6, xKillbillReason_6, xKillbillComment_6, ...args_6) => __awaiter(this, [keyName_1, xKillbillCreatedBy_6, xKillbillReason_6, xKillbillComment_6, ...args_6], void 0, function* (keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'keyName' is not null or undefined
            (0, common_1.assertParamExists)('deleteUserKeyValue', 'keyName', keyName);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('deleteUserKeyValue', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/tenants/userKeyValue/{keyName}`
                .replace(`{${"keyName"}}`, encodeURIComponent(String(keyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a per tenant key value based on key prefix
         * @param {string} keyPrefix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPluginConfiguration: (keyPrefix_1, ...args_7) => __awaiter(this, [keyPrefix_1, ...args_7], void 0, function* (keyPrefix, options = {}) {
            // verify required parameter 'keyPrefix' is not null or undefined
            (0, common_1.assertParamExists)('getAllPluginConfiguration', 'keyPrefix', keyPrefix);
            const localVarPath = `/1.0/kb/tenants/uploadPerTenantConfig/{keyPrefix}/search`
                .replace(`{${"keyPrefix"}}`, encodeURIComponent(String(keyPrefix)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a per tenant configuration (system properties)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerTenantConfiguration: (...args_8) => __awaiter(this, [...args_8], void 0, function* (options = {}) {
            const localVarPath = `/1.0/kb/tenants/uploadPerTenantConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a per tenant configuration for a plugin
         * @param {string} pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfiguration: (pluginName_3, ...args_9) => __awaiter(this, [pluginName_3, ...args_9], void 0, function* (pluginName, options = {}) {
            // verify required parameter 'pluginName' is not null or undefined
            (0, common_1.assertParamExists)('getPluginConfiguration', 'pluginName', pluginName);
            const localVarPath = `/1.0/kb/tenants/uploadPluginConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a per tenant payment state machine for a plugin
         * @param {string} pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginPaymentStateMachineConfig: (pluginName_4, ...args_10) => __awaiter(this, [pluginName_4, ...args_10], void 0, function* (pluginName, options = {}) {
            // verify required parameter 'pluginName' is not null or undefined
            (0, common_1.assertParamExists)('getPluginPaymentStateMachineConfig', 'pluginName', pluginName);
            const localVarPath = `/1.0/kb/tenants/uploadPluginPaymentStateMachineConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a push notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushNotificationCallbacks: (...args_11) => __awaiter(this, [...args_11], void 0, function* (options = {}) {
            const localVarPath = `/1.0/kb/tenants/registerNotificationCallback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a tenant by id
         * @param {string} tenantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenant: (tenantId_1, ...args_12) => __awaiter(this, [tenantId_1, ...args_12], void 0, function* (tenantId, options = {}) {
            // verify required parameter 'tenantId' is not null or undefined
            (0, common_1.assertParamExists)('getTenant', 'tenantId', tenantId);
            const localVarPath = `/1.0/kb/tenants/{tenantId}`
                .replace(`{${"tenantId"}}`, encodeURIComponent(String(tenantId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a tenant by its API key
         * @param {string} [apiKey]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantByApiKey: (apiKey_1, ...args_13) => __awaiter(this, [apiKey_1, ...args_13], void 0, function* (apiKey, options = {}) {
            const localVarPath = `/1.0/kb/tenants`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (apiKey !== undefined) {
                localVarQueryParameter['apiKey'] = apiKey;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve a per tenant user key/value
         * @param {string} keyName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserKeyValue: (keyName_2, ...args_14) => __awaiter(this, [keyName_2, ...args_14], void 0, function* (keyName, options = {}) {
            // verify required parameter 'keyName' is not null or undefined
            (0, common_1.assertParamExists)('getUserKeyValue', 'keyName', keyName);
            const localVarPath = `/1.0/kb/tenants/userKeyValue/{keyName}`
                .replace(`{${"keyName"}}`, encodeURIComponent(String(keyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add a per tenant user key/value
         * @param {string} body
         * @param {string} keyName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertUserKeyValue: (body_2, keyName_3, xKillbillCreatedBy_7, xKillbillReason_7, xKillbillComment_7, ...args_15) => __awaiter(this, [body_2, keyName_3, xKillbillCreatedBy_7, xKillbillReason_7, xKillbillComment_7, ...args_15], void 0, function* (body, keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('insertUserKeyValue', 'body', body);
            // verify required parameter 'keyName' is not null or undefined
            (0, common_1.assertParamExists)('insertUserKeyValue', 'keyName', keyName);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('insertUserKeyValue', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/tenants/userKeyValue/{keyName}`
                .replace(`{${"keyName"}}`, encodeURIComponent(String(keyName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'text/plain';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Create a push notification
         * @param {string} xKillbillCreatedBy
         * @param {string} [cb]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPushNotificationCallback: (xKillbillCreatedBy_8, cb_1, xKillbillReason_8, xKillbillComment_8, ...args_16) => __awaiter(this, [xKillbillCreatedBy_8, cb_1, xKillbillReason_8, xKillbillComment_8, ...args_16], void 0, function* (xKillbillCreatedBy, cb, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('registerPushNotificationCallback', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/tenants/registerNotificationCallback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (cb !== undefined) {
                localVarQueryParameter['cb'] = cb;
            }
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add a per tenant configuration (system properties)
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPerTenantConfiguration: (body_3, xKillbillCreatedBy_9, xKillbillReason_9, xKillbillComment_9, ...args_17) => __awaiter(this, [body_3, xKillbillCreatedBy_9, xKillbillReason_9, xKillbillComment_9, ...args_17], void 0, function* (body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('uploadPerTenantConfiguration', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('uploadPerTenantConfiguration', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/tenants/uploadPerTenantConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'text/plain';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add a per tenant configuration for a plugin
         * @param {string} body
         * @param {string} pluginName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginConfiguration: (body_4, pluginName_5, xKillbillCreatedBy_10, xKillbillReason_10, xKillbillComment_10, ...args_18) => __awaiter(this, [body_4, pluginName_5, xKillbillCreatedBy_10, xKillbillReason_10, xKillbillComment_10, ...args_18], void 0, function* (body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('uploadPluginConfiguration', 'body', body);
            // verify required parameter 'pluginName' is not null or undefined
            (0, common_1.assertParamExists)('uploadPluginConfiguration', 'pluginName', pluginName);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('uploadPluginConfiguration', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/tenants/uploadPluginConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'text/plain';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Add a per tenant payment state machine for a plugin
         * @param {string} body
         * @param {string} pluginName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginPaymentStateMachineConfig: (body_5, pluginName_6, xKillbillCreatedBy_11, xKillbillReason_11, xKillbillComment_11, ...args_19) => __awaiter(this, [body_5, pluginName_6, xKillbillCreatedBy_11, xKillbillReason_11, xKillbillComment_11, ...args_19], void 0, function* (body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('uploadPluginPaymentStateMachineConfig', 'body', body);
            // verify required parameter 'pluginName' is not null or undefined
            (0, common_1.assertParamExists)('uploadPluginPaymentStateMachineConfig', 'pluginName', pluginName);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('uploadPluginPaymentStateMachineConfig', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/tenants/uploadPluginPaymentStateMachineConfig/{pluginName}`
                .replace(`{${"pluginName"}}`, encodeURIComponent(String(pluginName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'text/plain';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TenantApiAxiosParamCreator = TenantApiAxiosParamCreator;
/**
 * TenantApi - functional programming interface
 * @export
 */
const TenantApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TenantApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a tenant
         * @param {Tenant} body
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [useGlobalDefault]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant(body, xKillbillCreatedBy, useGlobalDefault, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createTenant(body, xKillbillCreatedBy, useGlobalDefault, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Delete a per tenant configuration (system properties)
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerTenantConfiguration(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePerTenantConfiguration(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Delete a per tenant configuration for a plugin
         * @param {string} pluginName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginConfiguration(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePluginConfiguration(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Delete a per tenant payment state machine for a plugin
         * @param {string} pluginName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginPaymentStateMachineConfig(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePluginPaymentStateMachineConfig(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Delete a push notification
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePushNotificationCallbacks(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deletePushNotificationCallbacks(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Delete  a per tenant user key/value
         * @param {string} keyName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKeyValue(keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.deleteUserKeyValue(keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a per tenant key value based on key prefix
         * @param {string} keyPrefix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPluginConfiguration(keyPrefix, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllPluginConfiguration(keyPrefix, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a per tenant configuration (system properties)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerTenantConfiguration(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPerTenantConfiguration(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a per tenant configuration for a plugin
         * @param {string} pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfiguration(pluginName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPluginConfiguration(pluginName, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a per tenant payment state machine for a plugin
         * @param {string} pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginPaymentStateMachineConfig(pluginName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPluginPaymentStateMachineConfig(pluginName, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a push notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushNotificationCallbacks(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getPushNotificationCallbacks(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a tenant by id
         * @param {string} tenantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenant(tenantId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTenant(tenantId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a tenant by its API key
         * @param {string} [apiKey]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantByApiKey(apiKey, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getTenantByApiKey(apiKey, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve a per tenant user key/value
         * @param {string} keyName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserKeyValue(keyName, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUserKeyValue(keyName, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add a per tenant user key/value
         * @param {string} body
         * @param {string} keyName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertUserKeyValue(body, keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.insertUserKeyValue(body, keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Create a push notification
         * @param {string} xKillbillCreatedBy
         * @param {string} [cb]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPushNotificationCallback(xKillbillCreatedBy, cb, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.registerPushNotificationCallback(xKillbillCreatedBy, cb, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add a per tenant configuration (system properties)
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPerTenantConfiguration(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadPerTenantConfiguration(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add a per tenant configuration for a plugin
         * @param {string} body
         * @param {string} pluginName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginConfiguration(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadPluginConfiguration(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Add a per tenant payment state machine for a plugin
         * @param {string} body
         * @param {string} pluginName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginPaymentStateMachineConfig(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.uploadPluginPaymentStateMachineConfig(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TenantApiFp = TenantApiFp;
/**
 * TenantApi - factory interface
 * @export
 */
const TenantApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TenantApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a tenant
         * @param {Tenant} body
         * @param {string} xKillbillCreatedBy
         * @param {boolean} [useGlobalDefault]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createTenant(body, xKillbillCreatedBy, useGlobalDefault, xKillbillReason, xKillbillComment, options) {
            return localVarFp.createTenant(body, xKillbillCreatedBy, useGlobalDefault, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a per tenant configuration (system properties)
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePerTenantConfiguration(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deletePerTenantConfiguration(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a per tenant configuration for a plugin
         * @param {string} pluginName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginConfiguration(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deletePluginConfiguration(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a per tenant payment state machine for a plugin
         * @param {string} pluginName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePluginPaymentStateMachineConfig(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deletePluginPaymentStateMachineConfig(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a push notification
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePushNotificationCallbacks(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deletePushNotificationCallbacks(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete  a per tenant user key/value
         * @param {string} keyName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserKeyValue(keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.deleteUserKeyValue(keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a per tenant key value based on key prefix
         * @param {string} keyPrefix
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPluginConfiguration(keyPrefix, options) {
            return localVarFp.getAllPluginConfiguration(keyPrefix, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a per tenant configuration (system properties)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPerTenantConfiguration(options) {
            return localVarFp.getPerTenantConfiguration(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a per tenant configuration for a plugin
         * @param {string} pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginConfiguration(pluginName, options) {
            return localVarFp.getPluginConfiguration(pluginName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a per tenant payment state machine for a plugin
         * @param {string} pluginName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPluginPaymentStateMachineConfig(pluginName, options) {
            return localVarFp.getPluginPaymentStateMachineConfig(pluginName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a push notification
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPushNotificationCallbacks(options) {
            return localVarFp.getPushNotificationCallbacks(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a tenant by id
         * @param {string} tenantId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenant(tenantId, options) {
            return localVarFp.getTenant(tenantId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a tenant by its API key
         * @param {string} [apiKey]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTenantByApiKey(apiKey, options) {
            return localVarFp.getTenantByApiKey(apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve a per tenant user key/value
         * @param {string} keyName
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserKeyValue(keyName, options) {
            return localVarFp.getUserKeyValue(keyName, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add a per tenant user key/value
         * @param {string} body
         * @param {string} keyName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insertUserKeyValue(body, keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.insertUserKeyValue(body, keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a push notification
         * @param {string} xKillbillCreatedBy
         * @param {string} [cb]
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPushNotificationCallback(xKillbillCreatedBy, cb, xKillbillReason, xKillbillComment, options) {
            return localVarFp.registerPushNotificationCallback(xKillbillCreatedBy, cb, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add a per tenant configuration (system properties)
         * @param {string} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPerTenantConfiguration(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.uploadPerTenantConfiguration(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add a per tenant configuration for a plugin
         * @param {string} body
         * @param {string} pluginName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginConfiguration(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.uploadPluginConfiguration(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Add a per tenant payment state machine for a plugin
         * @param {string} body
         * @param {string} pluginName
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadPluginPaymentStateMachineConfig(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.uploadPluginPaymentStateMachineConfig(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.TenantApiFactory = TenantApiFactory;
/**
 * TenantApi - object-oriented interface
 * @export
 * @class TenantApi
 * @extends {BaseAPI}
 */
class TenantApi extends base_1.BaseAPI {
    /**
     *
     * @summary Create a tenant
     * @param {Tenant} body
     * @param {string} xKillbillCreatedBy
     * @param {boolean} [useGlobalDefault]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    createTenant(body, xKillbillCreatedBy, useGlobalDefault, xKillbillReason, xKillbillComment, options) {
        return (0, exports.TenantApiFp)(this.configuration).createTenant(body, xKillbillCreatedBy, useGlobalDefault, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a per tenant configuration (system properties)
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    deletePerTenantConfiguration(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.TenantApiFp)(this.configuration).deletePerTenantConfiguration(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a per tenant configuration for a plugin
     * @param {string} pluginName
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    deletePluginConfiguration(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.TenantApiFp)(this.configuration).deletePluginConfiguration(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a per tenant payment state machine for a plugin
     * @param {string} pluginName
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    deletePluginPaymentStateMachineConfig(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.TenantApiFp)(this.configuration).deletePluginPaymentStateMachineConfig(pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a push notification
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    deletePushNotificationCallbacks(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.TenantApiFp)(this.configuration).deletePushNotificationCallbacks(xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete  a per tenant user key/value
     * @param {string} keyName
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    deleteUserKeyValue(keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.TenantApiFp)(this.configuration).deleteUserKeyValue(keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a per tenant key value based on key prefix
     * @param {string} keyPrefix
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    getAllPluginConfiguration(keyPrefix, options) {
        return (0, exports.TenantApiFp)(this.configuration).getAllPluginConfiguration(keyPrefix, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a per tenant configuration (system properties)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    getPerTenantConfiguration(options) {
        return (0, exports.TenantApiFp)(this.configuration).getPerTenantConfiguration(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a per tenant configuration for a plugin
     * @param {string} pluginName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    getPluginConfiguration(pluginName, options) {
        return (0, exports.TenantApiFp)(this.configuration).getPluginConfiguration(pluginName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a per tenant payment state machine for a plugin
     * @param {string} pluginName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    getPluginPaymentStateMachineConfig(pluginName, options) {
        return (0, exports.TenantApiFp)(this.configuration).getPluginPaymentStateMachineConfig(pluginName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a push notification
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    getPushNotificationCallbacks(options) {
        return (0, exports.TenantApiFp)(this.configuration).getPushNotificationCallbacks(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a tenant by id
     * @param {string} tenantId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    getTenant(tenantId, options) {
        return (0, exports.TenantApiFp)(this.configuration).getTenant(tenantId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a tenant by its API key
     * @param {string} [apiKey]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    getTenantByApiKey(apiKey, options) {
        return (0, exports.TenantApiFp)(this.configuration).getTenantByApiKey(apiKey, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve a per tenant user key/value
     * @param {string} keyName
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    getUserKeyValue(keyName, options) {
        return (0, exports.TenantApiFp)(this.configuration).getUserKeyValue(keyName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add a per tenant user key/value
     * @param {string} body
     * @param {string} keyName
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    insertUserKeyValue(body, keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.TenantApiFp)(this.configuration).insertUserKeyValue(body, keyName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a push notification
     * @param {string} xKillbillCreatedBy
     * @param {string} [cb]
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    registerPushNotificationCallback(xKillbillCreatedBy, cb, xKillbillReason, xKillbillComment, options) {
        return (0, exports.TenantApiFp)(this.configuration).registerPushNotificationCallback(xKillbillCreatedBy, cb, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add a per tenant configuration (system properties)
     * @param {string} body
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    uploadPerTenantConfiguration(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.TenantApiFp)(this.configuration).uploadPerTenantConfiguration(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add a per tenant configuration for a plugin
     * @param {string} body
     * @param {string} pluginName
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    uploadPluginConfiguration(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.TenantApiFp)(this.configuration).uploadPluginConfiguration(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Add a per tenant payment state machine for a plugin
     * @param {string} body
     * @param {string} pluginName
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TenantApi
     */
    uploadPluginPaymentStateMachineConfig(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.TenantApiFp)(this.configuration).uploadPluginPaymentStateMachineConfig(body, pluginName, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.TenantApi = TenantApi;
/**
 * UsageApi - axios parameter creator
 * @export
 */
const UsageApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Retrieve usage for a subscription
         * @param {string} subscriptionId
         * @param {string} [startDate]
         * @param {string} [endDate]
         * @param {Array<string>} [pluginProperty]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsage: (subscriptionId_1, startDate_1, endDate_1, pluginProperty_1, ...args_1) => __awaiter(this, [subscriptionId_1, startDate_1, endDate_1, pluginProperty_1, ...args_1], void 0, function* (subscriptionId, startDate, endDate, pluginProperty, options = {}) {
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('getAllUsage', 'subscriptionId', subscriptionId);
            const localVarPath = `/1.0/kb/usages/{subscriptionId}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate instanceof Date) ?
                    startDate.toISOString().substr(0, 10) :
                    startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate instanceof Date) ?
                    endDate.toISOString().substr(0, 10) :
                    endDate;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Retrieve usage for a subscription and unit type
         * @param {string} subscriptionId
         * @param {string} unitType
         * @param {string} [startDate]
         * @param {string} [endDate]
         * @param {Array<string>} [pluginProperty]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage: (subscriptionId_2, unitType_1, startDate_2, endDate_2, pluginProperty_2, ...args_2) => __awaiter(this, [subscriptionId_2, unitType_1, startDate_2, endDate_2, pluginProperty_2, ...args_2], void 0, function* (subscriptionId, unitType, startDate, endDate, pluginProperty, options = {}) {
            // verify required parameter 'subscriptionId' is not null or undefined
            (0, common_1.assertParamExists)('getUsage', 'subscriptionId', subscriptionId);
            // verify required parameter 'unitType' is not null or undefined
            (0, common_1.assertParamExists)('getUsage', 'unitType', unitType);
            const localVarPath = `/1.0/kb/usages/{subscriptionId}/{unitType}`
                .replace(`{${"subscriptionId"}}`, encodeURIComponent(String(subscriptionId)))
                .replace(`{${"unitType"}}`, encodeURIComponent(String(unitType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = (startDate instanceof Date) ?
                    startDate.toISOString().substr(0, 10) :
                    startDate;
            }
            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = (endDate instanceof Date) ?
                    endDate.toISOString().substr(0, 10) :
                    endDate;
            }
            if (pluginProperty) {
                localVarQueryParameter['pluginProperty'] = pluginProperty;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Record usage for a subscription
         * @param {SubscriptionUsageRecord} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordUsage: (body_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_3) => __awaiter(this, [body_1, xKillbillCreatedBy_1, xKillbillReason_1, xKillbillComment_1, ...args_3], void 0, function* (body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options = {}) {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('recordUsage', 'body', body);
            // verify required parameter 'xKillbillCreatedBy' is not null or undefined
            (0, common_1.assertParamExists)('recordUsage', 'xKillbillCreatedBy', xKillbillCreatedBy);
            const localVarPath = `/1.0/kb/usages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            // authentication Killbill Api Key required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiKey", configuration);
            // authentication Killbill Api Secret required
            yield (0, common_1.setApiKeyToObject)(localVarHeaderParameter, "X-Killbill-ApiSecret", configuration);
            // authentication basicAuth required
            // http basic authentication required
            (0, common_1.setBasicAuthToObject)(localVarRequestOptions, configuration);
            if (xKillbillCreatedBy != null) {
                localVarHeaderParameter['X-Killbill-CreatedBy'] = String(xKillbillCreatedBy);
            }
            if (xKillbillReason != null) {
                localVarHeaderParameter['X-Killbill-Reason'] = String(xKillbillReason);
            }
            if (xKillbillComment != null) {
                localVarHeaderParameter['X-Killbill-Comment'] = String(xKillbillComment);
            }
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.UsageApiAxiosParamCreator = UsageApiAxiosParamCreator;
/**
 * UsageApi - functional programming interface
 * @export
 */
const UsageApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.UsageApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Retrieve usage for a subscription
         * @param {string} subscriptionId
         * @param {string} [startDate]
         * @param {string} [endDate]
         * @param {Array<string>} [pluginProperty]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsage(subscriptionId, startDate, endDate, pluginProperty, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getAllUsage(subscriptionId, startDate, endDate, pluginProperty, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Retrieve usage for a subscription and unit type
         * @param {string} subscriptionId
         * @param {string} unitType
         * @param {string} [startDate]
         * @param {string} [endDate]
         * @param {Array<string>} [pluginProperty]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage(subscriptionId, unitType, startDate, endDate, pluginProperty, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.getUsage(subscriptionId, unitType, startDate, endDate, pluginProperty, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Record usage for a subscription
         * @param {SubscriptionUsageRecord} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordUsage(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.recordUsage(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.UsageApiFp = UsageApiFp;
/**
 * UsageApi - factory interface
 * @export
 */
const UsageApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.UsageApiFp)(configuration);
    return {
        /**
         *
         * @summary Retrieve usage for a subscription
         * @param {string} subscriptionId
         * @param {string} [startDate]
         * @param {string} [endDate]
         * @param {Array<string>} [pluginProperty]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsage(subscriptionId, startDate, endDate, pluginProperty, options) {
            return localVarFp.getAllUsage(subscriptionId, startDate, endDate, pluginProperty, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Retrieve usage for a subscription and unit type
         * @param {string} subscriptionId
         * @param {string} unitType
         * @param {string} [startDate]
         * @param {string} [endDate]
         * @param {Array<string>} [pluginProperty]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsage(subscriptionId, unitType, startDate, endDate, pluginProperty, options) {
            return localVarFp.getUsage(subscriptionId, unitType, startDate, endDate, pluginProperty, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Record usage for a subscription
         * @param {SubscriptionUsageRecord} body
         * @param {string} xKillbillCreatedBy
         * @param {string} [xKillbillReason]
         * @param {string} [xKillbillComment]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordUsage(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
            return localVarFp.recordUsage(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(axios, basePath));
        },
    };
};
exports.UsageApiFactory = UsageApiFactory;
/**
 * UsageApi - object-oriented interface
 * @export
 * @class UsageApi
 * @extends {BaseAPI}
 */
class UsageApi extends base_1.BaseAPI {
    /**
     *
     * @summary Retrieve usage for a subscription
     * @param {string} subscriptionId
     * @param {string} [startDate]
     * @param {string} [endDate]
     * @param {Array<string>} [pluginProperty]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    getAllUsage(subscriptionId, startDate, endDate, pluginProperty, options) {
        return (0, exports.UsageApiFp)(this.configuration).getAllUsage(subscriptionId, startDate, endDate, pluginProperty, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Retrieve usage for a subscription and unit type
     * @param {string} subscriptionId
     * @param {string} unitType
     * @param {string} [startDate]
     * @param {string} [endDate]
     * @param {Array<string>} [pluginProperty]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    getUsage(subscriptionId, unitType, startDate, endDate, pluginProperty, options) {
        return (0, exports.UsageApiFp)(this.configuration).getUsage(subscriptionId, unitType, startDate, endDate, pluginProperty, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Record usage for a subscription
     * @param {SubscriptionUsageRecord} body
     * @param {string} xKillbillCreatedBy
     * @param {string} [xKillbillReason]
     * @param {string} [xKillbillComment]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsageApi
     */
    recordUsage(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options) {
        return (0, exports.UsageApiFp)(this.configuration).recordUsage(body, xKillbillCreatedBy, xKillbillReason, xKillbillComment, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.UsageApi = UsageApi;
